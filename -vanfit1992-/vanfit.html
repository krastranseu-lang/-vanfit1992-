<!-- @format -->

<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Van Pack – widget demo v8</title>
    <style>
      :root {
        --accent: #FF7A00;
        --accent-ink: #ffffff;
        --gridMinor: rgba(0, 0, 0, 0.08);
        --gridMajor: rgba(0, 0, 0, 0.16);
        --font-sans: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
        --z-floor: 1;
        --z-overlay: 2;
        --z-labels: 3;
        --z-toolbar: 8;
        --z-toast: 9999;
      }
      body { font-size: clamp(14px, 1.2vw, 16px); font-family: var(--font-sans); }
      /* Generic viewport layering skeleton */
      #viewport { position: relative; }
      #floor, #overlay, #labels { position: absolute; inset: 0; }
      #floor { z-index: var(--z-floor); }
      #overlay { z-index: var(--z-overlay); }
      #labels { z-index: var(--z-labels); pointer-events: none; }
      /* Minimal toolbar styling */
      #toolbar {
        position: sticky; top: 0; z-index: var(--z-toolbar);
        display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
        padding: 8px 12px; border-bottom: 1px solid rgba(0,0,0,.1);
        background: rgba(255, 255, 255, 0.04);
        backdrop-filter: saturate(120%) blur(6px);
      }
      #toolbar .spacer { flex: 1; }
      /* Language switcher (toolbar) */
      .hdr-lang { position: relative; margin-left: 8px; }
      /* Make the language button same size as theme toggle */
      .hdr-btn { width:62px; height:28px; display:inline-flex; align-items:center; justify-content:center; gap:6px; padding:0 8px; border-radius:20px; border:1px solid var(--line); background: var(--soft); color: var(--ink); cursor:pointer; }
      .hdr-btn .hdr-flag { font-size: 14px; line-height: 1; }
      .hdr-btn .hdr-lang-code { font-weight: 700; letter-spacing: .5px; font-size: 12px; }
      /* Override global .vp svg sizing for this tiny chevron icon */
      #toolbar .hdr-ico { width:14px !important; height:14px !important; display:inline-block !important; background: none !important; }
      .hdr-popover { position:absolute; right:0; top:calc(100% + 6px); background: var(--card); border:1px solid var(--line); border-radius:12px; padding:6px; box-shadow: 0 12px 28px rgba(0,0,0,.25); min-width: 220px; z-index: 50; }
      .hdr-popover[hidden] { display: none; }
      .hdr-lang-list { list-style:none; margin:0; padding:0; display:flex; flex-direction:column; gap:4px; }
      .hdr-lang-list button { width:100%; display:flex; align-items:center; gap:8px; padding:6px 8px; border-radius:8px; border:1px solid transparent; background:transparent; color:inherit; cursor:pointer; }
      .hdr-lang-list button[aria-checked="true"] { background: var(--soft); border-color: var(--line); }
      .hdr-lang-list b { min-width: 26px; text-align:center; }
      .hdr-lang-list em { opacity:.8; font-style: normal; }
      #toolbar button {
        appearance: none; border: none; cursor: pointer;
        background: var(--accent); color: var(--accent-ink);
        padding: 6px 10px; border-radius: 8px; font-weight: 600;
      }
      #toolbar button.secondary {
        background: transparent; color: inherit; border: 1px dashed rgba(127,127,127,.35);
      }
      #toolbar #status { margin-left: auto; color: inherit; opacity: .85; }
      /* Toast */
      #toast {
        position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%);
        z-index: var(--z-toast); display: none;
        background: var(--accent); color: var(--accent-ink);
        padding: 8px 12px; border-radius: 10px; box-shadow: 0 8px 24px rgba(0,0,0,.18);
      }
      /* ===================== THEME TOKENS ===================== */
      .vp {
        --bg: #0f1117;
        --ink: #e8eef9;
        --muted: #9fb0ca;
        --accent: #ff5a00;
        --accent-ink: #fff;
        --ok: #1fcf6d;
        --bad: #ff4d4f;
        --line: #223047;
        --card: #121a2b;
        --soft: #1a2236;
        --rad: 14px;
        --gap: 12px;
        --grid: 5;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial,
          sans-serif;
        color: var(--ink);
      }
      @media (prefers-color-scheme: light) {
        .vp:not([data-theme="dark"]) {
          --bg: #f5f7fb;
          --ink: #141a2a;
          --muted: #5b6a85;
          --accent: #ef5a00;
          --accent-ink: #fff;
          --ok: #0f9b5f;
          --bad: #d43030;
          --line: #d5dcef;
          --card: #ffffff;
          --soft: #f0f3fa;
        }
      }
      .vp[data-theme="light"] {
        --bg: #f5f7fb;
        --ink: #141a2a;
        --muted: #5b6a85;
        --accent: #ef5a00;
        --accent-ink: #fff;
        --ok: #0f9b5f;
        --bad: #d43030;
        --line: #d5dcef;
        --card: #ffffff;
        --soft: #f0f3fa;
      }

      /* Sepia / Reading mode (ciepły, żółtawy) */
      .vp[data-theme="sepia"] {
        --bg: #f6f1e3;       /* kremowe tło */
        --ink: #2b2110;      /* brązowy tusz */
        --muted: #6b5b45;
        --accent: #c36a00;   /* przygaszony pomarańcz */
        --accent-ink: #fff;
        --ok: #0f9b5f;
        --bad: #c0392b;
        --line: #d9ccb1;     /* delikatne linie */
        --card: #fffaf0;     /* jaśniejsze karty */
        --soft: #f2eadb;     /* miękki panel */
        --gridMinor: rgba(43, 33, 16, 0.08); /* cieplejsza siatka */
        --gridMajor: rgba(43, 33, 16, 0.16);
      }

      /* ===================== BASE ===================== */
      .vp * {
        box-sizing: border-box;
      }
      .vp a {
        color: var(--accent);
      }
      /* Brand (VanFit) */
      .vp .brand {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 6px;
      }
      .vp .brand-name {
        font-weight: 800;
        letter-spacing: .3px;
        color: var(--accent);
        font-size: 1.05rem;
      }
      
      /* Goodloading-style header */
      .vp .header-bar {
        background: #1e3a8a;
        color: white;
        padding: 12px 20px;
        border-radius: 8px 8px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: -16px -16px 16px -16px;
      }
      
      .vp .header-left {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      
      .vp .header-icon {
        width: 32px;
        height: 32px;
        background: rgba(255,255,255,0.1);
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s;
      }
      
      .vp .header-icon:hover {
        background: rgba(255,255,255,0.2);
      }
      
      .vp .header-right {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      
      .vp .pro-button {
        background: #10b981;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
      }
      
      .vp .user-icon {
        width: 32px;
        height: 32px;
        background: #3b82f6;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
      }
      
      /* Welcome banner */
      .vp .welcome-banner {
        background: #d1fae5;
        border: 1px solid #10b981;
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 20px;
        position: relative;
      }
      
      .vp .welcome-banner .close-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
        color: #065f46;
      }
      
      /* Left sidebar styling */
      .vp .side {
        background: #dbeafe;
        border: 1px solid #93c5fd;
        border-radius: var(--rad);
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        position: relative;
        color: #1e40af;
      }
      
      .vp .side h4 {
        margin: 0;
        font-size: 1rem;
        color: #1e40af;
        font-weight: 600;
      }
      
      .vp .side .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      
      .vp .side .add-btn {
        background: #3b82f6;
        color: white;
        border: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .vp .side .menu-btn {
        background: none;
        border: none;
        color: #1e40af;
        cursor: pointer;
        font-size: 18px;
      }
      
      /* Algorithm settings */
      .vp .algorithm-settings {
        background: white;
        border: 1px solid #93c5fd;
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 16px;
      }
      
      .vp .radio-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 12px;
      }
      
      .vp .radio-item {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
      }
      
      .vp .radio-item input[type="radio"] {
        accent-color: #3b82f6;
      }
      
      .vp .info-icon {
        color: #6b7280;
        cursor: help;
        font-size: 14px;
      }
      
      /* Cargo list styling */
      .vp .cargo-item {
        background: white;
        border: 1px solid #93c5fd;
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 8px;
      }
      
      .vp .cargo-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      
      .vp .cargo-title {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 600;
      }
      
      .vp .cargo-icon {
        width: 20px;
        height: 20px;
        background: #3b82f6;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 12px;
      }
      
      .vp .cargo-dropdown {
        background: none;
        border: none;
        color: #1e40af;
        cursor: pointer;
        font-size: 16px;
      }
      
      .vp .cargo-menu {
        background: none;
        border: none;
        color: #1e40af;
        cursor: pointer;
        font-size: 18px;
      }
      
      .vp .pallet-item {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 8px;
        margin: 4px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .vp .pallet-count {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .vp .count-btn {
        background: #3b82f6;
        color: white;
        border: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .vp .vp-wrap {
        position: relative;
        background: var(--bg);
        border: 1px solid var(--line);
        border-radius: var(--rad);
        padding: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        /* Widen the workspace for better readability on long cargo spaces */
        max-width: 98vw;
        margin: 0 auto;
      }
      .vp .topbar {
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
      }
      .vp .title {
        font-weight: 700;
        letter-spacing: 0.2px;
      }
      .vp .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        margin-top: 10px;
      }
      /* Inline custom vehicle bar */
      .vp .veh-inline { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
      .vp .veh-inline label { color: var(--muted); font-size: .9rem; }
      .vp .veh-inline input.small { width: 84px; padding: 6px 8px; border-radius: 8px; }
      .vp[data-theme="light"] .veh-inline input.small { background:#fff; }
      .vp[data-theme="sepia"] .veh-inline input.small { background:#fffaf0; color:#2b2110; }
      /* Expander (nowoczesne rozwijanie) */
      .vp .expander { border:1px solid var(--line); border-radius:12px; background:var(--soft); margin:8px 0; overflow:hidden; }
      .vp .expander-head { display:flex; align-items:center; gap:10px; padding:8px 10px; cursor:pointer; user-select:none; }
      .vp .expander-head .spacer{ flex:1; }
      .vp .expander-head .head-actions { display:flex; align-items:center; gap:8px; }
      .vp .expander-head .caret { width:10px; height:10px; border-right:2px solid var(--muted); border-bottom:2px solid var(--muted); transform: rotate(-45deg); margin-left:6px; transition: transform .18s ease; opacity:.7; }
      .vp .expander[data-open="true"] .expander-head .caret { transform: rotate(45deg); }
      .vp .expander-body { overflow:hidden; max-height:0; opacity:.0; transition: max-height .22s ease, opacity .22s ease, padding .22s ease; padding:0 10px; }
      .vp .expander[data-open="true"] .expander-body { opacity:1; padding:10px; }
      /* Detale (help) – ujednolicone z expanderem */
      .vp details { background: var(--soft); border:1px solid var(--line); border-radius:12px; padding:0; }
      .vp details > summary { list-style:none; cursor:pointer; padding:10px; margin:0; font-weight:600; }
      .vp details > summary::-webkit-details-marker{ display:none; }
      .vp details[open] { padding-bottom:8px; }
      /* Tiny buttons (ikonowe) */
      .vp .btn.tiny { padding: 4px 8px; min-width: 32px; line-height: 1; }
      /* Vehicle picker (kolumny wg grup) */
      .vp .veh-picker { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px,1fr)); gap:10px; }
      .vp .veh-col { background: var(--card); border:1px solid var(--line); border-radius:10px; padding:8px; }
      .vp .veh-col h5 { margin:4px 0 8px; font-size:.95rem; color: var(--muted); }
      .vp .veh-opt { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:8px; border:1px solid var(--line); border-radius:8px; cursor:pointer; background: var(--soft); }
      .vp .veh-opt:hover { border-color: var(--accent); }
      .vp .veh-opt small { color: var(--muted); }
      .vp .veh-dd { position:absolute; z-index: 40; background: var(--card); border:1px solid var(--line); border-radius:12px; padding:10px; box-shadow: 0 12px 28px rgba(0,0,0,.25); display:none; }
      .vp select,
      .vp input[type="number"],
      .vp input[type="text"],
      .vp input[type="date"],
      .vp input[type="time"],
      .vp textarea {
        background: #0c1322;
        color: var(--ink);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
      }
      .vp[data-theme="light"] select,
      .vp[data-theme="light"] input[type="number"],
      .vp[data-theme="light"] input[type="text"],
      .vp[data-theme="light"] input[type="date"],
      .vp[data-theme="light"] input[type="time"],
      .vp[data-theme="light"] textarea { background:#fff; color:#141a2a; }
      .vp[data-theme="sepia"] select,
      .vp[data-theme="sepia"] input[type="number"],
      .vp[data-theme="sepia"] input[type="text"],
      .vp[data-theme="sepia"] input[type="date"],
      .vp[data-theme="sepia"] input[type="time"],
      .vp[data-theme="sepia"] textarea { background:#fffaf0; color:#2b2110; }
      /* Select "Pojazd" – szerokość dopasowana do treści */
      .vp #vehSel { width:auto; min-width: 160px; max-width: 70vw; }
      /* Własny dropdown dla Pojazd – select jako hotspot */
      .vp #vehRow { position: relative; }
      .vp #vehSel { pointer-events: auto; user-select: none; }
      .vp[data-theme="light"] select,
      .vp[data-theme="light"] input,
      .vp[data-theme="light"] textarea {
        background: #fff;
      }
      .vp label {
        color: var(--muted);
        font-size: 0.95rem;
      }
      .vp .chip {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 0.9rem;
        color: var(--muted);
      }
      /* Make inline plus icon green for visibility */
      .vp .chip .plus-green { color: var(--ok); }
      .vp .chip.click { cursor:pointer; user-select:none; }

      /* Theme toggle */
      .vp .theme {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .vp .toggle {
        width: 62px;
        height: 28px;
        border-radius: 20px;
        border: 1px solid var(--line);
        background: var(--soft);
        position: relative;
        cursor: pointer;
      }
      .vp .knob {
        position: absolute;
        top: 3px;
        left: 3px;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: #ffd166;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease;
      }
      .vp[data-theme="light"] .knob {
        transform: translateX(34px);
        background: #ffe08a;
      }
      .vp[data-theme="dark"] .knob {
        transform: translateX(0);
      }
      /* Grid */
      .vp .grid {
        display: grid;
        grid-template-columns: minmax(240px, 1fr) 400px;
        gap: 16px;
      }
      @media (max-width: 1120px) {
        .vp .grid {
          grid-template-columns: 1fr;
        }
      }

      /* Stage */
      .vp .stage-card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: var(--rad);
        padding: 10px;
        position: relative;
      }
      .vp .stage-wrap {
        position: relative;
        width: 100%;
        /* More responsive height for better visibility */
        height: clamp(520px, 68vh, 860px);
      }
      .vp .stage-wrap.compare {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        align-items: stretch;
      }
      @media (min-width: 1400px) {
        .vp .stage-wrap {
          height: 640px;
        }
      }
      .vp svg {
        width: 100%;
        height: 100%;
        display: block;
        /* Subtle orange‑tinted gradient for nicer depth */
        background: radial-gradient(1000px 520px at 20% 0%, rgba(255,90,0,.08), rgba(255,90,0,0) 60%),
          linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.02),
            rgba(255, 255, 255, 0) 30%
          ),
          var(--soft);
        border-radius: 10px;
        /* Better touch precision on iOS/Android */
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
      }
      /* Sunlight: stronger contrast and outlines */
      html.sunlight .vp .gridline { stroke: #1f2b44; stroke-width: 0.35; }
      html.sunlight .vp .hull { stroke-width: 1.2; }
      html.sunlight .vp .item { stroke-width: 1.1; filter: drop-shadow(0 2px 4px rgba(0,0,0,.45)); }
      html.sunlight .vp .label { stroke-width: 0.9; }
      .vp svg.boardB { display: none; }
      .vp canvas.board3d {
        width: 100%;
        height: 100%;
        display: none;
        background: radial-gradient(1200px 600px at 50% 30%, rgba(255,255,255,0.05), transparent 60%), var(--soft);
        border-radius: 10px;
      }
      .vp .board { outline: 1px solid #2b3958; }
      .vp[data-theme="light"] .board { outline-color: #d5dcef; }
      .vp[data-theme="sepia"] .board { outline-color: #d9ccb1; }
      .vp .gridline { stroke: #26334e; stroke-width: 0.2; }
      .vp[data-theme="light"] .gridline { stroke: #e8eef9; }
      .vp[data-theme="sepia"] .gridline { stroke: #d9ccb1; }
      .vp .hull {
        fill: #0e1526;
        stroke: #3a4d77;
        stroke-width: 0.8;
      }
      .vp[data-theme="light"] .hull {
        fill: #f2f5fb;
        stroke: #d5dcef;
      }
      .vp .sectionline {
        stroke: var(--accent);
        stroke-width: 0.8;
        stroke-dasharray: 3 3;
        opacity: 0.8;
      }
      /* Axle/CoG overlay */
      .vp .axline { stroke: var(--accent); stroke-width: 1; stroke-dasharray: 4 3; opacity: .9; }
      .vp .axmark { fill: var(--accent); opacity: .9; }
      .vp .axbar { fill: rgba(255,90,0,.18); stroke: var(--accent); stroke-width: .6; }
      .vp .axtext { font-size: 3.2px; fill: var(--muted); }
      /* HUD overlay for readable labels */
      .vp .hud-layer {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      /* Overlay viewport: canvas -> svg -> div(labels) order */
      .vp #viewport {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 5;
        display: block;
      }
      /* Print mode: show overlay viewport */
      html.print .vp #viewport { display: block !important; }
      .vp #viewport > canvas,
      .vp #viewport > svg,
      .vp #viewport > div {
        position: absolute;
        inset: 0;
      }
      .vp #floor { width: 100%; height: 100%; display: block; background: transparent; }
      .vp #overlay { width: 100%; height: 100%; display: block; background: transparent !important; }
      .vp #labels { width: 100%; height: 100%; pointer-events: none; }
      /* Three.js viewport container */
      .vp #view3d { position: absolute; inset: 0; display: none; 
        /* subtle studio background for 3D */
        background: linear-gradient(180deg, rgba(248,250,252,0.95) 0%, rgba(255,255,255,1) 55%, rgba(241,245,249,0.95) 100%);
      }
      .vp[data-theme="dark"] #view3d { background: linear-gradient(180deg, rgba(10,14,24,0.95) 0%, rgba(12,19,34,1) 50%, rgba(8,12,20,0.95) 100%); }
      .vp[data-theme="sepia"] #view3d { background: linear-gradient(180deg, rgba(249,245,233,0.95) 0%, rgba(255,250,240,1) 55%, rgba(244,237,222,0.95) 100%); }
      /* Minimal label style (non-scaling DOM labels) */
      .vp #labels .label {
        position: absolute;
        font: 600 clamp(10px, 0.95vw, 14px)/1.2 system-ui;
        padding: 2px 6px;
        border-radius: 6px;
        white-space: nowrap;
        pointer-events: none;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
        background: rgba(0, 0, 0, 0.72);
        color: #fff;
        /* Auto-show on hover/selection */
        opacity: 0;
        transition: opacity 120ms ease;
        /* Readability boost over saturated fills */
        text-shadow: 0 1px 2px rgba(0,0,0,.35);
      }
      .vp #labels .label.is-hot { opacity: 1; }
      .vp #labels .label .lineA { display: block; font-weight: 800; letter-spacing: .2px; }
      .vp #labels .label .lineB { display: block; opacity: .9; font-weight: 600; }
      /* Light pill variant for better contrast on dark backgrounds */
      .vp #labels .label.label--contrast {
        background: rgba(255, 255, 255, 0.92);
        color: #121212;
      }
      .vp #labels .label .body { pointer-events:auto; }
      .vp #labels .label.is-selected { outline:2px solid var(--accent); box-shadow:0 0 0 2px rgba(255,90,0,0.35); background:var(--accent); color:var(--accent-ink); z-index: 20; }
      .vp .leaderline { stroke: var(--accent); stroke-width: 1.4; stroke-dasharray: 3 2; opacity:.85; display: none !important; }
      /* Icon inside overlay label */
      .label .ico { width:1em; height:1em; vertical-align:-0.15em; margin-left:.35em; fill:currentColor; opacity:.9; }
      .vp .hud {
        position: absolute;
        padding: 2px 4px;
        border-radius: 6px;
        font-size: 12px;
        line-height: 1;
        color: var(--ink);
        background: rgba(0, 0, 0, 0.25);
      }
      .vp[data-theme="light"] .hud {
        background: rgba(255, 255, 255, 0.7);
        border: 1px solid rgba(0, 0, 0, 0.08);
      }
      .vp[data-theme="sepia"] .hud {
        background: rgba(255, 250, 240, 0.82);
        border: 1px solid #e3d4b7;
        color: #2b2110;
      }

      .vp .item {
        /* Default fill/stroke are overridden via JS for per-item colors */
        fill: #2a3b60;
        stroke: #83a1ff;
        stroke-width: 0.7;
        cursor: grab;
        /* Add subtle drop shadow for a pseudo‑3D effect */
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.35));
      }
      /* Larger, invisible hit area for easier dragging on touch devices */
      .vp .dragHit { fill: transparent; stroke: none; pointer-events: all; cursor: grab; }
      /* Ensure in-rect texts/icons never steal pointer events */
      .vp svg.board .label,
      .vp svg.board text { pointer-events: none; }
      .vp[data-theme="light"] .item {
        fill: #cdd7f7;
        stroke: #4a77ff;
      }
      .vp .dragging .item.selected {
        cursor: grabbing;
      }
      .vp .item.collide {
        stroke: var(--bad);
      }
      .vp .item.selected {
        filter: drop-shadow(0 0 10px rgba(90, 163, 255, 0.6));
      }
      /* Larger, responsive in-SVG text (inside pallets) */
      .vp .label {
        font-size: clamp(11px, 1.0vw, 18px);
        fill: #d7e3ff;
        paint-order: stroke;
        stroke: #0b1020;
        stroke-width: 0.6;
        /* Try to improve readability on saturated backgrounds */
        text-shadow: 0 1px 2px rgba(0,0,0,.35);
      }
      .vp .label.dimA { font-size: clamp(8px, 0.7vw, 12px); font-weight: 800; }
      .vp .label.dimB { font-size: clamp(7px, 0.6vw, 10px); opacity: .98; }
      /* Compact label mode: hide the secondary line when zoomed out */
      .vp g.compact .label.dimB { display: none; }
      /* Print: hide in-rect labels, rely on overlay labels placed outside */
      html.print .vp .label { display: none !important; }
      /* Print: show all overlay labels */
      html.print .vp #labels .label { opacity: 1 !important; }
      /* Print: small frame for printable areas */
      html.print .vp .board { outline: 2px solid #000; background: #fff; }
      html.print .vp svg.section { outline: 1px solid #000; background: #fff; }
      .vp .rulerText { font-size: 4.8px; fill: var(--muted); }
      .vp .rulerTick { stroke: #435273; stroke-width: 1.1; }
      .vp[data-theme="light"] .rulerTick { stroke: #c6d2ef; }
      /* Ukryj drobne liczby F/R na górnej krawędzi (overlay osi) */
      .vp .axtext { display: none !important; }
      .vp .rotBtn {
        fill: #0c1322;
        stroke: #83a1ff;
        stroke-width: 0.5;
        cursor: pointer;
      }
      .vp .rotHit {
        fill: transparent;
        pointer-events: all;
        cursor: pointer;
      }

      /* Side cut (W×H) preview */
      .vp .section-cut {
        margin-top: 10px;
        background: var(--soft);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
      }
      .vp svg.section {
        width: 100%;
        height: 180px;
        display: block;
        background: linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.02),
            rgba(255, 255, 255, 0) 30%
          ),
          var(--soft);
        border-radius: 8px;
      }
      .vp .sec-gridline { stroke: #26334e; stroke-width: 0.2; }
      .vp[data-theme="light"] .sec-gridline { stroke: #e8eef9; }
      .vp[data-theme="sepia"] .sec-gridline { stroke: #d9ccb1; }

      /* Underbar */
      .vp .underbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding-top: 10px;
        border-top: 1px dashed #2b3958;
        margin-top: 10px;
      }

      /* Metrics bar inside underbar */
      .vp .metrics-bar .card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
        min-width: 120px;
      }
      .vp .metrics-bar progress {
        width: 100%;
        height: 10px;
      }
      .vp .metrics-bar progress::-webkit-progress-value {
        background: var(--accent);
      }
      .vp .metrics-bar progress::-webkit-progress-bar {
        background: #23314d;
      }
      .vp[data-theme="light"] .metrics-bar progress::-webkit-progress-bar {
        background: #e8eef9;
      }
      .vp .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        background: var(--accent);
        color: var(--accent-ink);
        border: none;
        border-radius: 10px;
        padding: 10px 12px;
        cursor: pointer;
        /* Interactive: smooth transform/shadow for hover/press */
        transition: transform 120ms ease, box-shadow 180ms ease, filter 180ms ease, background-color 180ms ease;
        transform: translateZ(0);
        will-change: transform, box-shadow, filter;
      }
      .vp .btn.secondary {
        background: var(--soft);
        color: var(--ink);
        border: 1px solid var(--line);
      }
      .vp .btn.ghost {
        background: transparent;
        border: 1px dashed var(--line);
      }
      /* Hover lift effect for primary/secondary/ghost */
      .vp .btn:hover {
        transform: translateY(-2px) scale(1.03);
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
        filter: brightness(1.04);
      }
      /* Press effect (mousedown) */
      .vp .btn:active,
      .vp .btn.is-pressing {
        transform: translateY(0) scale(0.98);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.18);
        filter: brightness(0.98);
      }
      /* Toolbar buttons get same interaction */
      #toolbar button {
        transition: transform 120ms ease, box-shadow 180ms ease, filter 180ms ease, background-color 180ms ease;
        transform: translateZ(0);
        will-change: transform, box-shadow, filter;
      }
      #toolbar button:hover { transform: translateY(-2px) scale(1.03); box-shadow: 0 8px 18px rgba(0,0,0,.22); filter: brightness(1.04); }
      #toolbar button:active, #toolbar button.is-pressing { transform: translateY(0) scale(0.98); box-shadow: 0 4px 10px rgba(0,0,0,.16); filter: brightness(0.98); }
      /* Language trigger button hover/press */
      .hdr-btn { transition: transform 120ms ease, box-shadow 180ms ease, filter 180ms ease; transform: translateZ(0); will-change: transform, box-shadow, filter; }
      .hdr-btn:hover { transform: translateY(-2px) scale(1.03); box-shadow: 0 8px 18px rgba(0,0,0,.22); filter: brightness(1.04); }
      .hdr-btn:active, .hdr-btn.is-pressing { transform: translateY(0) scale(0.98); box-shadow: 0 4px 10px rgba(0,0,0,.16); filter: brightness(0.98); }

      /* ======== Responsive device modes ======== */
      /* Mobile-only helper */
      .mobile-only { display: none; }
      .vp[data-device="mobile"] .mobile-only { display: inline-flex; }
      /* Hide 3D view on mobile */
      .vp[data-device="mobile"] #view3d { display: none !important; }
      /* Hide 3D control buttons on mobile */
      .vp[data-device="mobile"] .actions-bar [data-act^="cam"],
      .vp[data-device="mobile"] .actions-bar #view3D,
      .vp[data-device="mobile"] .actions-bar [data-act="sectionToggle"],
      .vp[data-device="mobile"] #sectionSlider,
      .vp[data-device="mobile"] .actions-bar [data-act^="layer"] {
        display: none !important;
      }
      /* Tablet: hide clipping controls */
      .vp[data-device="tablet"] .actions-bar [data-act="sectionToggle"],
      .vp[data-device="tablet"] #sectionSlider {
        display: none !important;
      }

      /* Bottom sheet for side panel on mobile */
      .vp[data-device="mobile"] .side {
        position: fixed;
        left: 0; right: 0; bottom: 0;
        max-height: 72vh;
        overflow: auto;
        border-radius: 14px 14px 0 0;
        box-shadow: 0 -10px 30px rgba(0,0,0,.35);
        transform: translateY(92%);
        transition: transform .24s ease;
        z-index: 20;
      }
      .vp[data-device="mobile"] .side.open { transform: translateY(0); }
      .vp[data-device="mobile"] #toggleSheet { display: inline-flex; }
      .vp:not([data-device="mobile"]) #toggleSheet { display: none; }
      /* Provide some bottom spacing for main content when sheet handle is used */
      .vp[data-device="mobile"] .stage-card { padding-bottom: 48px; }

      /* Side */
      .vp .side {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: var(--rad);
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        position: relative;
      }
      .vp .side h4 {
        margin: 0;
        font-size: 1rem;
        color: #d7e3ff;
      }
      .vp[data-theme="light"] .side h4 {
        color: #1a2233;
      }
      .vp .preset-list {
        display: grid;
        grid-template-columns: repeat(1, minmax(0, 1fr));
        gap: 8px;
      }
      .vp .preset {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        background: var(--soft);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
      }
      .vp .preset small {
        color: var(--muted);
      }
      .vp .qty {
        display: flex;
        gap: 6px;
        align-items: center;
      }
      .vp .qty input {
        width: 64px;
      }

      /* Bulk */
      .vp .bulk {
        background: var(--soft);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 10px;
      }
      .vp .bulk .out {
        background: #0c1322;
        border: 1px dashed #33425f;
        border-radius: 8px;
        padding: 8px;
        min-height: 40px;
        color: #c9d6f0;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        white-space: pre-wrap;
      }
      .vp[data-theme="light"] .bulk .out { background: #fff; color: #2b3b55; border-color: #cfd8ef; }
      .vp[data-theme="sepia"] .bulk .out { background: #fffaf0; color: #2b2110; border-color: #e3d4b7; }
      .vp .note {
        color: var(--muted);
        font-size: 0.9rem;
      }

      /* Custom small form */
      .vp .custom {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }
      .vp .custom .row {
        display: flex;
        flex-direction: column;
      }
      .vp .custom .wide {
        grid-column: 1 / -1;
      }

      /* New one‑line custom input */
      .vp .custom-line {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .vp .custom-line input[type="text"] {
        flex: 1 1 240px;
        min-width: 180px;
      }
      .vp .custom-hint {
        color: var(--muted);
        font-size: .85rem;
        margin: 6px 0 12px 0;
      }

      /* Add vehicle */
      .vp .vehbox {
        background: var(--soft);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
      }
      .vp .vehgrid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 8px;
      }
      @media (max-width: 560px) {
        .vp .vehgrid {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      .vp .meters {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .vp .meters .card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
      }
      progress {
        width: 100%;
        height: 10px;
      }
      progress::-webkit-progress-value {
        background: var(--accent);
      }
      progress::-webkit-progress-bar {
        background: #23314d;
      }
      .vp[data-theme="light"] progress::-webkit-progress-bar {
        background: #e8eef9;
      }

      .vp .status {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .vp .badge {
        padding: 6px 10px;
        border-radius: 999px;
        font-weight: 600;
      }
      .vp .badge.ok {
        background: rgba(31, 207, 109, 0.12);
        color: #0be481;
        border: 1px solid #1fcf6d;
      }
      .vp .badge.bad {
        background: rgba(255, 77, 79, 0.12);
        color: #ff4d4f;
        border: 1px solid #ff4d4f;
      }

      .vp .actions {
        display: flex;
        gap: 8px;
        flex-wrap: nowrap; /* jedna linia */
        align-items: center;
      }
      .vp .actions .btn { padding: 8px 10px; white-space: nowrap; }
      .vp details {
        background: var(--soft);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
      }

      /* Selected item panel */
      .vp .selected-panel {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
        display: none;
      }
      .vp .selected-panel.active {
        display: block;
      }
      .vp .selected-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }

      /* Modal styles removed */

      /* Focus & a11y */
      .vp [tabindex]:focus {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      /* Error box */
      .vp .error {
        background: #2b1111;
        color: #ffd7d7;
        border: 1px solid #7a2b2b;
        border-radius: 10px;
        padding: 10px;
        display: none;
      }
      .vp .error[aria-hidden="false"] {
        display: block;
      }

      /* Fancy checkbox (stackable) */
      .vp .chk {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: var(--soft);
        cursor: pointer;
        user-select: none;
      }
      .vp .chk input {
        appearance: none;
        width: 16px;
        height: 16px;
        border: 1px solid #41527a;
        border-radius: 4px;
        display: inline-block;
        background: #0c1322;
        position: relative;
      }
      .vp .chk input:checked {
        background: #0d2418;
        border-color: #2a9d6f;
      }
      .vp .chk input:checked::after {
        content: "";
        position: absolute;
        inset: 2px;
        background: #2dd07a;
        border-radius: 2px;
      }
      .vp .chk span {
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <div id="van-pack" class="vp" data-lang="pl">
      <noscript
        ><div
          style="
            color: #fff;
            background: #c00;
            padding: 10px;
            border-radius: 8px;
          "
        >
          Ta aplikacja wymaga JavaScript.
        </div></noscript
      >
    </div>

    <!-- Three.js (CDN) -->
    <script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.161.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Three.js postprocessing (for sketch/outline mode) -->
    <script src="https://unpkg.com/three@0.161.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.161.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.161.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.161.0/examples/js/postprocessing/OutlinePass.js"></script>
    <script src="https://unpkg.com/three@0.161.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.161.0/examples/js/shaders/FXAAShader.js"></script>

    <script>
      (() => {
        try {
      // ===================== CONFIG & I18N =====================
      // WCAG-aware contrast helper for labels (global)
      function applyLabelContrast(el, bgColor){
        if (!el) return;
        const c = String(bgColor || '').trim();
        function parseColor(s){
          if (!s) return [0,0,0];
          let m = s.match(/^rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
          if (m) return [parseInt(m[1],10), parseInt(m[2],10), parseInt(m[3],10)];
          m = s.match(/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i);
          if (m) { const h=(+m[1])%360, s=(+m[2])/100, l=(+m[3])/100; const h2=(t)=>{const a=(n)=>n<0?n+1:n>1?n-1:n; const p=l*(1-s); const q=l<.5?l*(1+s):l+s-l*s; const f=(t)=>{t=a(t); if(t<1/6)return p+(q-p)*6*t; if(t<1/2)return q; if(t<2/3)return p+(q-p)*(2/3-t)*6; return p}; return [Math.round(f(h/360+1/3)*255),Math.round(f(h/360)*255),Math.round(f(h/360-1/3)*255)];}; return h2(h);} 
          m = s.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
          if (m){ let x=m[1]; if(x.length===3) x=x.split('').map(ch=>ch+ch).join(''); const n=parseInt(x,16); return [(n>>16)&255,(n>>8)&255,n&255]; }
          return [0,0,0];
        }
        const [r,g,b] = parseColor(c);
        const toLin = (u)=>{ const x=u/255; return x<=0.03928? x/12.92 : Math.pow((x+0.055)/1.055,2.4); };
        const L = 0.2126*toLin(r) + 0.7152*toLin(g) + 0.0722*toLin(b);
        const lightBg = L > 0.55; // tuned threshold
        // Approximate saturation (0..1) for adaptive halo
        function rgbToHsl(R,G,B){
          const rr=R/255, gg=G/255, bb=B/255;
          const max=Math.max(rr,gg,bb), min=Math.min(rr,gg,bb);
          let h=0,s=0,l=(max+min)/2;
          if (max!==min){
            const d=max-min;
            s = l>0.5 ? d/(2-max-min) : d/(max+min);
            switch(max){
              case rr: h=(gg-bb)/d + (gg<bb?6:0); break;
              case gg: h=(bb-rr)/d + 2; break;
              default: h=(rr-gg)/d + 4; break;
            }
            h/=6;
          }
          return {h,s,l};
        }
        const hsl = rgbToHsl(r,g,b);
        // Toggle class for CSS-driven variant and set inline fallback for robustness
        el.classList.toggle('label--contrast', lightBg);
        if (lightBg) {
          el.style.background = 'rgba(255,255,255,0.92)';
          el.style.color = '#121212';
        } else {
          el.style.background = 'rgba(0,0,0,0.72)';
          el.style.color = '#fff';
        }
        // Adaptive halo: for high-chroma backgrounds, strengthen text shadow for crisper edges
        try {
          const baseShadow = '0 1px 2px rgba(0,0,0,0.35)';
          const strongShadow = '0 1.5px 3px rgba(0,0,0,0.5)';
          // If saturation is high and luminance is mid, boost
          if (hsl.s >= 0.55 && L > 0.25 && L < 0.85) {
            el.style.textShadow = strongShadow;
          } else {
            el.style.textShadow = baseShadow;
          }
        } catch(_) {}
      }
          const VEHICLES = [
            // Busy  EP
            {
              id: "bus_5ep",
              group: "Bus 3,5 t",
              name_pl: "Bus 3,6x1,6x1,8 m",
              inner_cm: { L: 360, W: 160, H: 180 },
              payload_kg: 1350,
              europallets: 5,
              grid_cm: 5,
            },
            {
              id: "bus_8ep",
              group: "Bus 3,5 t",
              name_pl: "Bus 4,2x2,2x2,6 m",
              inner_cm: { L: 420, W: 220, H: 260 },
              payload_kg: 1100,
              europallets: 8,
              grid_cm: 5,
            },
            {
              id: "solo_10ep_4_2m",
              group: "Bus 3,5 t",
              name_pl: "Bus 4,2×2,2×2,6 m",
              inner_cm: { L: 420, W: 220, H: 240 },
              payload_kg: 1000,
              europallets: 10,
              grid_cm: 5,
            },
            {
              id: "solo_10ep_4_2m",
              group: "Bus 3,5 t",
              name_pl: "Bus 4,2×2,25×2,6 m",
              inner_cm: { L: 420, W: 220, H: 240 },
              payload_kg: 1000,
              europallets: 10,
              grid_cm: 5,
            },
            {
              id: "solo_10ep_4_8m",
              group: "Bus 3,5 t",
              name_pl: "Bus 4,8×2,2×2,6 m",
              inner_cm: { L: 480, W: 220, H: 260 },
              payload_kg: 1000,
              europallets: 10,
              grid_cm: 5,
            },

            // Solówki — realne wymiary
            {
              id: "solo_6m_low",
              group: "Solówka",
              name_pl: "Solówka 6,0×2,45×2,2 m",
              inner_cm: { L: 600, W: 245, H: 220 },
              payload_kg: 2500,
              europallets: 14,
              grid_cm: 5,
            },
            {
              id: "solo_7_2m",
              group: "Solówka",
              name_pl: "Solówka 7,2×2,45×2,5 m",
              inner_cm: { L: 720, W: 245, H: 250 },
              payload_kg: 5000,
              europallets: 18,
              grid_cm: 5,
            },
            {
              id: "solo_8_2m",
              group: "Solówka",
              name_pl: "Solówka 8,2×2,45×2,7 m",
              inner_cm: { L: 820, W: 245, H: 270 },
              payload_kg: 9000,
              europallets: 20,
              grid_cm: 5,
            },
            {
              id: "solo_8_9m_high",
              group: "Solówka",
              name_pl: "Solówka 8,9×2,48×3,0 m",
              inner_cm: { L: 890, W: 248, H: 300 },
              payload_kg: 12000,
              europallets: 22,
              grid_cm: 5,
            },

            // Naczepy — realne wymiary
            {
              id: "trailer_13_6",
              group: "Naczepa 13,6 m",
              name_pl: "Naczepa 13,6×2,45×2,65 m",
              inner_cm: { L: 1360, W: 245, H: 265 },
              payload_kg: 24000,
              europallets: 33,
              grid_cm: 5,
            },
            {
              id: "trailer_13_6_h3",
              group: "TIR firanka/sztywka",
              name_pl: "TIR 13,6×2,45×2,8 m",
              inner_cm: { L: 1360, W: 245, H: 280 },
              payload_kg: 24000,
              europallets: 33,
              grid_cm: 5,
            },
            {
              id: "trailer_mega",
              group: "Naczepa Mega",
              name_pl: "Mega 13,6×2,48×3,0 m",
              inner_cm: { L: 1360, W: 248, H: 300 },
              payload_kg: 24000,
              europallets: 33,
              grid_cm: 5,
            },
            {
              id: "trailer_chlodnia",
              group: "Naczepa chłodnia",
              name_pl: "Chłodnia 13,3×2,45×2,6 m",
              inner_cm: { L: 1330, W: 245, H: 260 },
              payload_kg: 22000,
              europallets: 33,
              grid_cm: 5,
            },
          ];

          const I18N = {
            pl: {
              dims_label: "D×S×W",
              weight: "Waga (kg)",
              fits: "Mieści się",
              variant: "Wariant",
              quick_presets: "Szybkie presety",
              custom_item: "Własny element",
              selected_item: "Wybrany element",
              loading_rules: "Zasady prawidłowego załadunku (skrót)",
              try_another: "Ułóż inaczej",
              quote_60s: "Wycena transportu w 60 s",
              
              rotate_right: "90° w prawo",
              clearance_lw: "Zapas D/S: {L} cm / {W} cm",
              welcome_banner: "Witaj! Cieszymy się, że zdecydowałeś się wypróbować VanFit. Obecnie korzystasz z wersji darmowej.",
              title_vanfit: "VanFit",
              heading: "Ułóż ładunek. Sprawdzamy D/S/W i wagę – bez objętościowego czarowania.",
              sub: "Planowanie wymiarowe + reguły piętrowania. LDM tylko jako wskaźnik.",
              vehicle: "Pojazd",
              lwh: "D×S×W",
              payload: "Ładowność",
              pallets: "EUR palet",
              eur_pallets: "EUR palet",
              ldm: "LDM (szac.)",
              volume_used: "Zajętość (m³)",
              weight_used: "Waga (kg)",
              fits_yes: "Mieści się",
              fits_no: "Nie mieści się",
              exceeds_payload: "Przekroczono ładowność o {kg} kg",
              quote: "Wycena transportu w 60 s",
              leftover: "Zapas D/S: {L} cm / {W} cm",
              undo: "Cofnij",
              redo: "Ponów",
              
              rotateR: "90° w prawo",
              autopack: "Ułóż automatycznie",
              altpack: "Ułóż inaczej",
              ab_test: "A/B",
              stackAll: "Spiętruj wszystko",
              prev: "Poprzedni",
              axle_no_data: "Brak danych o osiach",
              warn_front_over: "Przeciążona oś przednia: {pct}%",
              warn_rear_over: "Przeciążona oś tylna: {pct}%",
              warn_too_tall: "Za wysokie elementy vs wnętrze",
              warn_non_stack: "Pozycje niepiętrowalne",
              warn_payload_over: "Sugeruję większy pojazd (przekroczono ładowność).",
              warn_not_placed: "Nie zmieściło się: {count} szt. (poza ładownią)",
              custom_placeholder: "np. 120x80x180x350 x2, 60x40x40x10 x10",
              next: "Następny",
              variants: "Wariant",
              view_3d: "Widok 3D",
              view_top: "Góra",
              view_side: "Bok",
              view_rear: "Tył",
              view_rear_left: "3/4 tył‑lewy",
              view_perspective: "Perspektywa",
              overview: "Przegląd",
              section: "Przekrój",
              layer: "Warstwa",
              all: "Wszystkie",
              top2d: "Top 2D",
              show_all: "Pokaż całość",
              show_loaded: "Pokaż załadowaną część",
              deleteSel: "Usuń zaznaczone",
              export_pdf: "Eksport do PDF",
              keywords: "Słowa kluczowe: pal/ep/eur, szt./colli…",
              bulk_title: "Wklej opis ładunku (rozpoznamy liczby i wymiary)",
              bulk_btn: "Analizuj i dodaj",
              analyze_add_btn: "Analizuj i dodaj",
              bulk_hint: "np. 5 pal 120×80×150 350 kg; 10 kartonów 60×40×40 20 kg",
              presets: "Szybkie presety",
              items: "Elementy",
              custom: "Własny element",
              format_hint: "Format: D×S×W×kg opcjonalnie ×ilość; wiele pozycji oddziel przecinkami.",
              selected: "Wybrany element",
              help_title: "Zasady prawidłowego załadunku (skrót)",
              qty: "Ilość",
              add: "Dodaj",
              reset: "Reset",
              save: "Zapisz",
              share: "Udostępnij",
              custom_vehicle: "Własny pojazd",
              stacking_plus: "Piętrowanie +",
              stacking_minus: "Piętrowanie –",
              sketch_mode: "Rysunek",
              sketch_mode_title: "Styl rysunkowy 3D",
              
              grid: "Siatka",
              reset_view: "Reset widoku",
              zoom: "Zoom",
              stackable: "stapelbar",
              stackable_label: "stapelbar",
              axis_total: "Gesamt",
              axis_front: "Vorderachse",
              axis_rear: "Hinterachse",
              industrial_pallet: "Industriepalette",
              stackable: "piętrowalne",
              stackable_label: "piętrowalne",
              add_btn: "+ Dodaj",
              axis_total: "Całkowita",
              axis_front: "Przód",
              axis_rear: "Tył",
              industrial_pallet: "Paleta przemysłowa",
              front_rear_total: "Całkowita • Przód • Tył",
              length_cm: "Długość (cm)",
              width_cm: "Szerokość (cm)",
              height_cm: "Wysokość (cm)",
              payload_kg: "Ładowność (kg)",
              enter_cm_hint: "Wprowadź w cm, np. 420 × 220 × 240",
              // existing modal keys
              modal_title: "Szybka wycena (60 s)",
              route_from: "Skąd",
              route_to: "Dokąd",
              load: "Załadunek",
              unload: "Rozładunek",
              date: "Data",
              from: "od (godz)",
              to: "do (godz)",
              notes: "Uwagi",
              send: "Wyślij",
              cancel: "Anuluj",
              warn_big: "Wymiary przekraczają wymiary przestrzeni ładunkowej.",
              stackable: "stackable",
              theme: "Motyw",
              add_vehicle: "Własny pojazd",
              create_vehicle: "Utwórz i wybierz",
              tools_aria: "Narzędzia",
              choose_language_aria: "Wybierz język",
              toggle_theme_title: "Przełącz motyw",
              panels_title: "Panele",
              status_ready: "Gotowe",
              open_close_title: "Otwórz/Zamknij",
              selected_actions_aria: "Akcje wybranego elementu",
              section_pos_title: "Pozycja przekroju",
              saved_to_browser: "Zapisano w przeglądarce.",
              link_copied: "Link skopiowany do schowka.",
              confirm_change_vehicle: "Zmiana pojazdu zresetuje ułożone elementy. Kontynuować?",
              confirm_clear_all: "Wyczyścić wszystkie elementy?",
              error_init_prefix: "Błąd inicjalizacji: ",
              no_items: "Nie wykryto żadnych pozycji",
              more_btn: "Więcej",
              pcs_abbr: "szt.",
              kg_per_pc: "kg/szt",
            },
            en: {
              dims_label: "L×W×H",
              weight: "Weight (kg)",
              fits: "Fits",
              variant: "Variant",
              quick_presets: "Quick presets",
              custom_item: "Custom item",
              selected_item: "Selected item",
              loading_rules: "Proper loading rules (summary)",
              try_another: "Try another",
              quote_60s: "Transport quote in 60 s",
              axle_no_data: "No axle data",
              warn_front_over: "Front axle overloaded: {pct}%",
              warn_rear_over: "Rear axle overloaded: {pct}%",
              warn_too_tall: "Items too tall for interior",
              warn_non_stack: "Non-stackable items present",
              warn_payload_over: "Consider larger vehicle (payload exceeded).",
              warn_not_placed: "{count} pcs not placed (out of bay)",
              custom_placeholder: "e.g. 120x80x180x350 x2, 60x40x40x10 x10",
              
              rotate_right: "Rotate 90° right",
              clearance_lw: "Clearance L/W: {L} cm / {W} cm",
              create_vehicle: "Create & select",
              length_cm: "Length (cm)",
              width_cm: "Width (cm)",
              height_cm: "Height (cm)",
              payload_kg: "Payload (kg)",
              enter_cm_hint: "Enter in cm, e.g. 420 × 220 × 240",
              welcome_banner: "Welcome! We’re glad you decided to try VanFit. You’re currently using the free version.",
              title_vanfit: "VanFit",
              heading: "Arrange the load. We check L×W×H and weight—no volume magic.",
              sub: "Dimension-based planning + stacking rules. LDM as an indicator only.",
              vehicle: "Vehicle",
              lwh: "L×W×H",
              payload: "Payload",
              pallets: "EUR pallets",
              eur_pallets: "EUR pallets",
              ldm: "LDM (est.)",
              volume_used: "Occupied volume (m³)",
              weight_used: "Weight (kg)",
              fits_yes: "Fits",
              exceeds_payload: "Exceeded payload by {kg} kg",
              quote: "Transport quote in 60 s",
              leftover: "Clearance L/W: {L} cm / {W} cm",
              undo: "Undo",
              redo: "Redo",
              
              rotateR: "Rotate 90° right",
              tools_aria: "Tools",
              choose_language_aria: "Choose language",
              toggle_theme_title: "Toggle theme",
              panels_title: "Panels",
              status_ready: "Ready",
              open_close_title: "Open/Close",
              selected_actions_aria: "Selected item actions",
              section_pos_title: "Section position",
              saved_to_browser: "Saved to browser.",
              link_copied: "Link copied to clipboard.",
              confirm_change_vehicle: "Changing vehicle will reset items. Continue?",
              confirm_clear_all: "Clear all items?",
              error_init_prefix: "Initialization error: ",
              no_items: "No items detected",
              more_btn: "More",
              pcs_abbr: "pcs",
              kg_per_pc: "kg/pc",
              pallet: "pallet",
              pallet_half: "half-pallet",
              pallet_quarter: "quarter-pallet",
              check_flag: "review",
              total_note: "(total)",
              autopack: "Auto-pack",
              altpack: "Try another",
              ab_test: "A/B",
              stackAll: "Stack all",
              prev: "Previous",
              next: "Next",
              variants: "Variant",
              view_3d: "3D view",
              view_top: "Top",
              view_side: "Side",
              view_rear: "Rear",
              view_rear_left: "3/4 rear‑left",
              view_perspective: "Perspective",
              overview: "Overview",
              section: "Cross-section",
              layer: "Layer",
              all: "All",
              top2d: "Top 2D",
              show_all: "Show all",
              show_loaded: "Show loaded part",
              deleteSel: "Delete selected",
              export_pdf: "Export to PDF",
              keywords: "Keywords: pal/ep/eur, pcs/colli…",
              vehicle_cat_bus35: "Van 3.5 t",
              vehicle_cat_rigid: "Rigid truck",
              vehicle_cat_trailer_136: "Semi-trailer 13.6 m",
              vehicle_cat_tautliner_box: "Curtainsider / box trailer",
              vehicle_cat_mega: "Mega trailer",
              vehicle_cat_reefer: "Refrigerated trailer",
              bulk_title: "Paste cargo description (we’ll detect numbers and dimensions)",
              bulk_btn: "Analyze & add",
              bulk_hint: "e.g. 5 pallets 120×80×150 350 kg; 10 boxes 60×40×40 20 kg total",
              presets: "Quick presets",
              items: "Items",
              custom: "Custom item",
              format_hint: "Format: L×W×H×kg optional ×qty; multiple items separated by commas.",
              selected: "Selected item",
              help_title: "Proper loading rules (summary)",
              qty: "Quantity",
              add: "Add",
              add_btn: "+ Add",
              axis_total: "Total",
              axis_front: "Front",
              axis_rear: "Rear",
              reset: "Reset",
              save: "Save",
              share: "Share",
              custom_vehicle: "Custom vehicle",
              stacking_plus: "Stacking +",
              stacking_minus: "Stacking –",
              sketch_mode: "Sketch",
              sketch_mode_title: "3D sketch/outline style",
              
              grid: "Grid",
              reset_view: "Reset view",
              zoom: "Zoom",
              stackable: "stapelbar",
              stackable_label: "stapelbar",
              axis_total: "Gesamt",
              axis_front: "Vorderachse",
              axis_rear: "Hinterachse",
              industrial_pallet: "Industriepalette",
              front_rear_total: "Total • Front • Rear",
            },
            de: {
              dims_label: "L×B×H",
              weight: "Gewicht (kg)",
              fits: "Passt",
              variant: "Variante",
              quick_presets: "Schnellvorlagen",
              custom_item: "Eigenes Element",
              selected_item: "Ausgewähltes Element",
              loading_rules: "Regeln für das korrekte Verladen (Kurzfassung)",
              try_another: "Variante wechseln",
              axle_no_data: "Keine Achsdaten",
              warn_front_over: "Vorderachse überlastet: {pct}%",
              warn_rear_over: "Hinterachse überlastet: {pct}%",
              warn_too_tall: "Zu hohe Teile für den Innenraum",
              warn_non_stack: "Nicht stapelbare Teile vorhanden",
              warn_payload_over: "Größeres Fahrzeug empfohlen (Nutzlast überschritten).",
              warn_not_placed: "Nicht platziert: {count} Stk. (außerhalb der Ladefläche)",
              custom_placeholder: "z. B. 120x80x180x350 x2, 60x40x40x10 x10",
              tools_aria: "Werkzeuge",
              choose_language_aria: "Sprache wählen",
              toggle_theme_title: "Theme umschalten",
              panels_title: "Panels",
              status_ready: "Bereit",
              open_close_title: "Öffnen/Schließen",
              selected_actions_aria: "Aktionen für ausgewähltes Element",
              section_pos_title: "Schnitt-Position",
              saved_to_browser: "Im Browser gespeichert.",
              link_copied: "Link in die Zwischenablage kopiert.",
              confirm_change_vehicle: "Fahrzeugwechsel setzt Elemente zurück. Fortfahren?",
              confirm_clear_all: "Alle Elemente löschen?",
              error_init_prefix: "Initialisierungsfehler: ",
              no_items: "Keine Elemente erkannt",
              more_btn: "Mehr",
              pcs_abbr: "Stk.",
              kg_per_pc: "kg/Stk",
              pallet: "Palette",
              pallet_half: "Halbpalette",
              pallet_quarter: "Viertelpalette",
              check_flag: "prüfen",
              total_note: "(gesamt)",
              quote_60s: "Transportangebot in 60 s",
              
              rotate_right: "90° nach rechts drehen",
              clearance_lw: "L/B-Reserve: {L} cm / {W} cm",
              welcome_banner: "Willkommen! Schön, dass du dich entschieden hast, VanFit auszuprobieren. Du nutzt derzeit die kostenlose Version.",
              title_vanfit: "VanFit",
              heading: "Ladung anordnen. Wir prüfen L×B×H und Gewicht – keine Volumen-Tricks.",
              sub: "Maßbasiertes Planen + Stapelregeln. LDM nur als Richtwert.",
              vehicle: "Fahrzeug",
              lwh: "L×B×H",
              payload: "Nutzlast",
              pallets: "EUR-Paletten",
              ldm: "LDM (geschätzt)",
              volume_used: "Belegtes Volumen (m³)",
              weight_used: "Gewicht (kg)",
              fits_yes: "Passt",
              exceeds_payload: "Nutzlast um {kg} kg überschritten",
              quote: "Transportangebot in 60 s",
              leftover: "L/B-Reserve: {L} cm / {W} cm",
              undo: "Rückgängig",
              redo: "Wiederholen",
              
              rotateR: "90° nach rechts drehen",
              autopack: "Auto-Packen",
              altpack: "Variante wechseln",
              ab_test: "A/B",
              stackAll: "Alles stapeln",
              prev: "Zurück",
              next: "Weiter",
              variants: "Variante",
              view_3d: "3D-Ansicht",
              view_top: "Oben",
              view_side: "Seite",
              view_rear: "Hinten",
              view_rear_left: "3/4 hinten‑links",
              view_perspective: "Perspektive",
              overview: "Übersicht",
              section: "Schnitt",
              layer: "Schicht",
              all: "Alle",
              top2d: "Top-Down 2D",
              show_all: "Alles anzeigen",
              show_loaded: "Nur beladener Teil",
              deleteSel: "Auswahl löschen",
              export_pdf: "Export als PDF",
              keywords: "Schlüsselwörter: pal/ep/eur, Stk./Colli…",
              vehicle_cat_bus35: "Transporter 3,5 t",
              vehicle_cat_rigid: "Solofahrzeug",
              vehicle_cat_trailer_136: "Sattelauflieger 13,6 m",
              vehicle_cat_tautliner_box: "Planen-/Kofferauflieger",
              vehicle_cat_mega: "Mega-Trailer",
              vehicle_cat_reefer: "Kühlauflieger",
              bulk_title: "Füge die Ladungsbeschreibung ein (Zahlen & Maße werden erkannt)",
              bulk_btn: "Analysieren & hinzufügen",
              analyze_add_btn: "Analysieren & hinzufügen",
              bulk_hint: "z. B.: 5 Paletten 120×80×150 350 kg; 10 Kartons 60×40×40 20 kg gesamt",
              presets: "Schnellvorlagen",
              items: "Elemente",
              custom: "Eigenes Element",
              format_hint: "Format: L×B×H×kg optional ×Menge; mehrere Positionen durch Kommas trennen.",
              selected: "Ausgewähltes Element",
              help_title: "Regeln für das korrekte Verladen (Kurzfassung)",
              qty: "Menge",
              add: "Hinzufügen",
              add_btn: "+ Hinzufügen",
              reset: "Zurücksetzen",
              save: "Speichern",
              share: "Teilen",
              custom_vehicle: "Eigenes Fahrzeug",
              stacking_plus: "Stapeln +",
              stacking_minus: "Stapeln −",
              sketch_mode: "Skizze",
              sketch_mode_title: "3D‑Skizzenstil",
              
              grid: "Raster",
              reset_view: "Ansicht zurücksetzen",
              zoom: "Zoom",
              stackable: "stapelbar",
              stackable_label: "stapelbar",
              axis_total: "Gesamt",
              axis_front: "Vorderachse",
              axis_rear: "Hinterachse",
              industrial_pallet: "Industriepalette",
            },
            fr: {
              dims_label: "L×l×H",
              weight: "Poids (kg)",
              fits: "Ça passe",
              variant: "Variante",
              quick_presets: "Préréglages rapides",
              custom_item: "Élément personnalisé",
              selected_item: "Élément sélectionné",
              loading_rules: "Règles de chargement correctes (résumé)",
              try_another: "Essayer autrement",
              axle_no_data: "Données d’essieux manquantes",
              warn_front_over: "Essieu avant surchargé : {pct}%",
              warn_rear_over: "Essieu arrière surchargé : {pct}%",
              warn_too_tall: "Éléments trop hauts pour l’espace",
              warn_non_stack: "Éléments non empilables présents",
              warn_payload_over: "Véhicule plus grand recommandé (charge utile dépassée).",
              warn_not_placed: "Non placés : {count} pcs (hors zone)",
              custom_placeholder: "ex. : 120x80x180x350 x2, 60x40x40x10 x10",
              tools_aria: "Outils",
              choose_language_aria: "Choisir la langue",
              toggle_theme_title: "Basculer le thème",
              panels_title: "Panneaux",
              status_ready: "Prêt",
              open_close_title: "Ouvrir/Fermer",
              selected_actions_aria: "Actions de l’élément sélectionné",
              section_pos_title: "Position de la coupe",
              saved_to_browser: "Enregistré dans le navigateur.",
              link_copied: "Lien copié dans le presse‑papiers.",
              confirm_change_vehicle: "Changer de véhicule réinitialise les éléments. Continuer ?",
              confirm_clear_all: "Effacer tous les éléments ?",
              error_init_prefix: "Erreur d’initialisation : ",
              no_items: "Aucun élément détecté",
              more_btn: "Plus",
              pcs_abbr: "pcs",
              kg_per_pc: "kg/pc",
              pallet: "palette",
              pallet_half: "demi‑palette",
              pallet_quarter: "quart de palette",
              check_flag: "à vérifier",
              total_note: "(total)",
              quote_60s: "Devis transport en 60 s",
              
              rotate_right: "Tourner 90° à droite",
              clearance_lw: "Marge long./larg. : {L} cm / {W} cm",
              welcome_banner: "Bienvenue ! Nous sommes ravis que vous ayez décidé d’essayer VanFit. Vous utilisez actuellement la version gratuite.",
              title_vanfit: "VanFit",
              heading: "Organisez la charge. Nous vérifions L×l×H et le poids—sans « magie » de volume.",
              sub: "Planification par dimensions + règles d’empilage. LDM à titre indicatif.",
              vehicle: "Véhicule",
              lwh: "L×l×H",
              payload: "Charge utile",
              pallets: "Palettes EUR",
              ldm: "LDM (estim.)",
              volume_used: "Volume occupé (m³)",
              weight_used: "Poids (kg)",
              fits_yes: "Ça passe",
              exceeds_payload: "Charge utile dépassée de {kg} kg",
              quote: "Devis transport en 60 s",
              leftover: "Marge long./larg. : {L} cm / {W} cm",
              undo: "Annuler",
              redo: "Rétablir",
              
              rotateR: "Tourner 90° à droite",
              autopack: "Agencer automatiquement",
              altpack: "Essayer autrement",
              ab_test: "A/B",
              stackAll: "Empiler tout",
              prev: "Précédent",
              next: "Suivant",
              variants: "Variante",
              view_3d: "Vue 3D",
              view_top: "Dessus",
              view_side: "Côté",
              view_rear: "Arrière",
              view_rear_left: "3/4 arrière‑gauche",
              view_perspective: "Perspective",
              overview: "Aperçu",
              section: "Coupe",
              layer: "Couche",
              all: "Toutes",
              top2d: "Vue 2D dessus",
              show_all: "Tout afficher",
              show_loaded: "Afficher la partie chargée",
              deleteSel: "Supprimer la sélection",
              export_pdf: "Exporter en PDF",
              keywords: "Mots-clés : pal/ep/eur, pcs/colis…",
              vehicle_cat_bus35: "Fourgon 3,5 t",
              vehicle_cat_rigid: "Porteur",
              vehicle_cat_trailer_136: "Semi-remorque 13,6 m",
              vehicle_cat_tautliner_box: "Rideaux coulissants / fourgon",
              vehicle_cat_mega: "Remorque Mega",
              vehicle_cat_reefer: "Semi-remorque frigorifique",
              bulk_title: "Collez la description du chargement (nous détectons nombres et dimensions)",
              bulk_btn: "Analyser et ajouter",
              analyze_add_btn: "Analyser et ajouter",
              bulk_hint: "ex. : 5 palettes 120×80×150 350 kg ; 10 cartons 60×40×40 20 kg au total",
              presets: "Préréglages rapides",
              items: "Éléments",
              custom: "Élément personnalisé",
              format_hint: "Format : L×l×H×kg puis ×quantité (optionnel) ; plusieurs éléments séparés par des virgules.",
              selected: "Élément sélectionné",
              help_title: "Règles de chargement correctes (résumé)",
              qty: "Quantité",
              add: "Ajouter",
              add_btn: "+ Ajouter",
              reset: "Réinitialiser",
              save: "Enregistrer",
              share: "Partager",
              custom_vehicle: "Véhicule personnalisé",
              stacking_plus: "Empilement +",
              stacking_minus: "Empilement −",
              sketch_mode: "Esquisse",
              sketch_mode_title: "Style esquisse 3D",
              
              grid: "Grille",
              reset_view: "Réinitialiser la vue",
              zoom: "Zoom",
              stackable: "stapelbar",
              stackable_label: "stapelbar",
              axis_total: "Gesamt",
              axis_front: "Vorderachse",
              axis_rear: "Hinterachse",
              industrial_pallet: "Industriepalette",
              stackable: "empilable",
              stackable_label: "empilable",
              axis_total: "Total",
              axis_front: "Avant",
              axis_rear: "Arrière",
              industrial_pallet: "Palette industrielle",
            },
            it: {
              dims_label: "L×L×H",
              weight: "Peso (kg)",
              fits: "Ci sta",
              variant: "Variante",
              quick_presets: "Preset rapidi",
              custom_item: "Elemento personalizzato",
              selected_item: "Elemento selezionato",
              loading_rules: "Regole corrette di carico (sintesi)",
              try_another: "Prova diverso",
              axle_no_data: "Dati assi mancanti",
              warn_front_over: "Assale anteriore sovraccarico: {pct}%",
              warn_rear_over: "Assale posteriore sovraccarico: {pct}%",
              warn_too_tall: "Elementi troppo alti per l’interno",
              warn_non_stack: "Elementi non impilabili presenti",
              warn_payload_over: "Consigliato veicolo più grande (portata superata).",
              warn_not_placed: "Non posizionati: {count} pz (fuori vano)",
              custom_placeholder: "es.: 120x80x180x350 x2, 60x40x40x10 x10",
              quote_60s: "Preventivo trasporto in 60 s",
              
              rotate_right: "Ruota 90° a destra",
              clearance_lw: "Margine lung./larg.: {L} cm / {W} cm",
              welcome_banner: "Benvenuto! Siamo felici che tu abbia deciso di provare VanFit. Al momento utilizzi la versione gratuita.",
              title_vanfit: "VanFit",
              heading: "Disponi il carico. Controlliamo L×L×H e peso—niente trucchi sul volume.",
              sub: "Pianificazione per dimensioni + regole di impilamento. LDM solo indicativo.",
              vehicle: "Veicolo",
              lwh: "L×L×H",
              payload: "Portata",
              pallets: "Pallet EUR",
              ldm: "LDM (stima)",
              volume_used: "Volume occupato (m³)",
              weight_used: "Peso (kg)",
              fits_yes: "Ci sta",
              exceeds_payload: "Portata superata di {kg} kg",
              quote: "Preventivo trasporto in 60 s",
              leftover: "Margine L/L: {L} cm / {W} cm",
              undo: "Annulla",
              redo: "Ripeti",
              
              rotateR: "Ruota 90° a destra",
              autopack: "Auto-impila",
              altpack: "Prova diverso",
              ab_test: "A/B",
              stackAll: "Impila tutto",
              prev: "Precedente",
              next: "Avanti",
              variants: "Variante",
              view_3d: "Vista 3D",
              view_top: "Alto",
              view_side: "Lato",
              view_rear: "Retro",
              view_rear_left: "3/4 posteriore‑sinistra",
              view_perspective: "Prospettiva",
              overview: "Panoramica",
              section: "Sezione",
              layer: "Strato",
              all: "Tutte",
              top2d: "Top 2D",
              show_all: "Mostra tutto",
              show_loaded: "Mostra la parte caricata",
              deleteSel: "Elimina selezione",
              export_pdf: "Esporta in PDF",
              keywords: "Parole chiave: pal/ep/eur, pz./colli…",
              vehicle_cat_bus35: "Furgone 3,5 t",
              vehicle_cat_rigid: "Motrice (rigido)",
              vehicle_cat_trailer_136: "Semirimorchio 13,6 m",
              vehicle_cat_tautliner_box: "Tautliner / box",
              vehicle_cat_mega: "Trailer Mega",
              vehicle_cat_reefer: "Semirimorchio frigo",
              bulk_title: "Incolla la descrizione del carico (rileveremo numeri e dimensioni)",
              bulk_btn: "Analizza e aggiungi",
              analyze_add_btn: "Analizza e aggiungi",
              bulk_hint: "es.: 5 pallet 120×80×150 350 kg; 10 scatole 60×40×40 20 kg totali",
              presets: "Preset rapidi",
              items: "Elementi",
              custom: "Elemento personalizzato",
              format_hint: "Formato: L×L×H×kg opzionale ×q.tà; più elementi separati da virgole.",
              selected: "Elemento selezionato",
              help_title: "Regole corrette di carico (sintesi)",
              qty: "Quantità",
              add: "Aggiungi",
              add_btn: "+ Aggiungi",
              reset: "Reimposta",
              save: "Salva",
              share: "Condividi",
              custom_vehicle: "Veicolo personalizzato",
              stacking_plus: "Impilamento +",
              stacking_minus: "Impilamento –",
              sketch_mode: "Schizzo",
              sketch_mode_title: "Stile schizzo 3D",
              
              grid: "Griglia",
              reset_view: "Reimposta vista",
              zoom: "Zoom",
              stackable: "stapelbar",
              stackable_label: "stapelbar",
              axis_total: "Gesamt",
              axis_front: "Vorderachse",
              axis_rear: "Hinterachse",
              industrial_pallet: "Industriepalette",
              stackable: "impilabile",
              stackable_label: "impilabile",
              axis_total: "Totale",
              axis_front: "Anteriore",
              axis_rear: "Posteriore",
              industrial_pallet: "Pallet industriale",
            },
            ru: {
              dims_label: "Д×Ш×В",
              weight: "Вес (кг)",
              fits: "Помещается",
              variant: "Вариант",
              quick_presets: "Быстрые пресеты",
              custom_item: "Пользовательский элемент",
              selected_item: "Выбранный элемент",
              loading_rules: "Правила правильной загрузки (кратко)",
              try_another: "Другой вариант",
              quote_60s: "Расчёт стоимости перевозки за 60 с",
              
              rotate_right: "Повернуть на 90° вправо",
              clearance_lw: "Запас Д/Ш: {L} см / {W} см",
              welcome_banner: "Добро пожаловать! Мы рады, что вы решили попробовать VanFit. Сейчас вы используете бесплатную версию.",
              title_vanfit: "VanFit",
              heading: "Уложите груз. Проверяем Д×Ш×В и вес — без «объёмных чудес».",
              sub: "Планирование по габаритам + правила штабелирования. LDM — лишь ориентир.",
              vehicle: "Транспорт",
              lwh: "Д×Ш×В",
              payload: "Грузоподъёмность",
              pallets: "Поддоны EUR",
              ldm: "Погонные метры (оцен.)",
              volume_used: "Занятый объём (м³)",
              weight_used: "Вес (кг)",
              fits_yes: "Помещается",
              exceeds_payload: "Превышена грузоподъёмность на {kg} кг",
              quote: "Расчёт стоимости перевозки за 60 с",
              quote_60s: "Расчёт стоимости за 60 с",
              leftover: "Запас Д/Ш: {L} см / {W} см",
              undo: "Отменить",
              redo: "Повторить",
              
              rotateR: "Повернуть на 90° вправо",
              autopack: "Авто-укладка",
              altpack: "Другой вариант",
              ab_test: "A/B",
              stackAll: "Уложить в несколько ярусов",
              prev: "Назад",
              next: "Далее",
              variants: "Вариант",
              view_3d: "3D-вид",
              view_top: "Сверху",
              view_side: "Сбоку",
              view_rear: "Сзади",
              view_rear_left: "3/4 сзади‑слева",
              view_perspective: "Перспектива",
              overview: "Обзор",
              section: "Сечение",
              layer: "Слой",
              all: "Все",
              top2d: "Вид сверху 2D",
              show_all: "Показать всё",
              show_loaded: "Показать загруженную часть",
              deleteSel: "Удалить выбранное",
              export_pdf: "Экспорт в PDF",
              keywords: "Ключевые слова: pal/ep/eur, шт./колли…",
              vehicle_cat_bus35: "Бус 3,5 т",
              vehicle_cat_rigid: "Соло-грузовик",
              vehicle_cat_trailer_136: "Полуприцеп 13,6 м",
              vehicle_cat_tautliner_box: "Шторный / фургон-прицеп",
              vehicle_cat_mega: "Мега-прицеп",
              vehicle_cat_reefer: "Рефрижераторный полуприцеп",
              bulk_title: "Вставьте описание груза (распознаем числа и габариты)",
              bulk_btn: "Проанализировать и добавить",
              analyze_add_btn: "Проанализировать и добавить",
              bulk_hint: "например: 5 пал 120×80×150 350 кг; 10 коробок 60×40×40 20 кг всего",
              presets: "Быстрые пресеты",
              items: "Элементы",
              custom: "Пользовательский элемент",
              format_hint: "Формат: Д×Ш×В×кг, при необходимости ×кол-во; несколько позиций через запятую.",
              selected: "Выбранный элемент",
              help_title: "Правила правильной погрузки (кратко)",
              qty: "Количество",
              add: "Добавить",
              add_btn: "+ Добавить",
              reset: "Сброс",
              save: "Сохранить",
              share: "Поделиться",
              custom_vehicle: "Свой автомобиль",
              stacking_plus: "Штабелирование +",
              stacking_minus: "Штабелирование –",
              sketch_mode: "Эскиз",
              sketch_mode_title: "Эскизный стиль 3D",
              
              grid: "Сетка",
              reset_view: "Сброс вида",
              zoom: "Масштаб",
              stackable: "штабельований",
              stackable_label: "штабельований",
              axis_total: "Разом",
              axis_front: "Перед",
              axis_rear: "Зад",
              industrial_pallet: "Промислова палета",
              stackable: "штабелируемый",
              stackable_label: "штабелируемый",
              axis_total: "Итого",
              axis_front: "Перед",
              axis_rear: "Зад",
              industrial_pallet: "Промышленный поддон",
            },
            uk: {
              dims_label: "Д×Ш×В",
              weight: "Вага (кг)",
              fits: "Вміщується",
              variant: "Варіант",
              quick_presets: "Швидкі пресети",
              custom_item: "Користувацький елемент",
              selected_item: "Обраний елемент",
              loading_rules: "Правила правильного завантаження (коротко)",
              try_another: "Інший варіант",
              axle_no_data: "Немає даних по осях",
              warn_front_over: "Перевантажена передня вісь: {pct}%",
              warn_rear_over: "Перевантажена задня вісь: {pct}%",
              warn_too_tall: "Надто високі елементи для кузова",
              warn_non_stack: "Є не штабельовані позиції",
              warn_payload_over: "Рекомендується більший транспорт (перевищено вантажопідйомність).",
              warn_not_placed: "Не розміщено: {count} шт. (поза відсіком)",
              custom_placeholder: "напр.: 120x80x180x350 x2, 60x40x40x10 x10",
              quote_60s: "Розрахунок вартості за 60 с",
              
              rotate_right: "Повернути на 90° вправо",
              clearance_lw: "Запас Д/Ш: {L} см / {W} см",
              welcome_banner: "Вітаємо! Ми раді, що ви вирішили спробувати VanFit. Зараз ви користуєтеся безкоштовною версією.",
              title_vanfit: "VanFit",
              heading: "Укладіть вантаж. Перевіряємо Д×Ш×В і вагу — без «об’ємних фокусів».",
              sub: "Планування за розмірами + правила штабелювання. LDM — лише орієнтир.",
              vehicle: "Транспорт",
              lwh: "Д×Ш×В",
              payload: "Вантажопідйомність",
              pallets: "Піддони EUR",
              ldm: "Погонні метри (орієнт.)",
              volume_used: "Зайнятий об’єм (м³)",
              weight_used: "Вага (кг)",
              fits_yes: "Вміщується",
              exceeds_payload: "Перевищено вантажопідйомність на {kg} кг",
              quote: "Розрахунок вартості перевезення за 60 с",
              leftover: "Запас Д/Ш: {L} см / {W} см",
              undo: "Скасувати",
              redo: "Повторити",
              
              rotateR: "Повернути на 90° вправо",
              autopack: "Авто-укладання",
              altpack: "Інший варіант",
              ab_test: "A/B",
              stackAll: "Штабелювати все",
              prev: "Назад",
              next: "Далі",
              variants: "Варіант",
              view_3d: "3D-вигляд",
              view_top: "Зверху",
              view_side: "Збоку",
              view_rear: "Ззаду",
              view_rear_left: "3/4 ззаду‑ліворуч",
              view_perspective: "Перспектива",
              overview: "Огляд",
              section: "Переріз",
              layer: "Шар",
              all: "Усі",
              top2d: "Вид згори 2D",
              show_all: "Показати все",
              show_loaded: "Показати завантажену частину",
              deleteSel: "Видалити вибране",
              export_pdf: "Експорт у PDF",
              keywords: "Ключові слова: pal/ep/eur, шт./colli…",
              vehicle_cat_bus35: "Бус 3,5 т",
              vehicle_cat_rigid: "Соло-вантажівка",
              vehicle_cat_trailer_136: "Напівпричіп 13,6 м",
              vehicle_cat_tautliner_box: "Шторний / фургон-причіп",
              vehicle_cat_mega: "Мега-причіп",
              vehicle_cat_reefer: "Рефрижераторний напівпричіп",
              bulk_title: "Вставте опис вантажу (розпізнаємо числа й розміри)",
              bulk_btn: "Проаналізувати та додати",
              analyze_add_btn: "Проаналізувати та додати",
              bulk_hint: "напр.: 5 палет 120×80×150 350 кг; 10 коробок 60×40×40 20 кг разом",
              presets: "Швидкі пресети",
              items: "Елементи",
              custom: "Користувацький елемент",
              format_hint: "Формат: Д×Ш×В×кг, за потреби ×к-сть; кілька позицій через кому.",
              selected: "Обраний елемент",
              help_title: "Правила правильного завантаження (коротко)",
              qty: "Кількість",
              add: "Додати",
              add_btn: "+ Додати",
              reset: "Скинути",
              save: "Зберегти",
              share: "Поділитися",
              custom_vehicle: "Власний транспорт",
              stacking_plus: "Штабелювання +",
              stacking_minus: "Штабелювання –",
              sketch_mode: "Ескіз",
              sketch_mode_title: "Ескізний стиль 3D",
              
              grid: "Сітка",
              reset_view: "Скинути вигляд",
              zoom: "Масштаб",
              stackable: "штабельований",
              stackable_label: "штабельований",
              axis_total: "Разом",
              axis_front: "Перед",
              axis_rear: "Зад",
              industrial_pallet: "Промислова палета",
            },
          };

          const PRESETS = [
            {
              id: "eur_pallet",
              label: "EP",
              dims: { L: 120, W: 80, H: 150 },
              weight: 350,
              stackable: true,
            },
            {
              id: "Pal_Przemyslowa",
              label: "Pal Przemyslowa",
              dims: { L: 120, W: 100, H: 150 },
              weight: 350,
              stackable: true,
            },
          ];

          // ===================== STATE =====================
          const mount = document.getElementById("van-pack");
          let lang = (localStorage.getItem('vp_lang') || 'pl');
          try { document.documentElement.setAttribute('lang', lang); } catch(_) {}
          try { mount.setAttribute('data-lang', lang); } catch(_) {}
          // Theme init — AUTO (system) with optional MANUAL override
          const prefersLight = (window.matchMedia && matchMedia('(prefers-color-scheme: light)')) || null;
          const prefersDark  = (window.matchMedia && matchMedia('(prefers-color-scheme: dark)')) || null;
          const THEME_KEY = 'vp_theme_mode'; // 'auto' | 'light' | 'dark'
          function getSystemTheme(){
            try {
              if (prefersDark && typeof prefersDark.matches === 'boolean' && prefersDark.matches) return 'dark';
              if (prefersLight && typeof prefersLight.matches === 'boolean' && prefersLight.matches) return 'light';
            } catch(_) {}
            // Fallback: assume dark (nasza domyślna paleta)
            return 'dark';
          }
          let themeMode = (localStorage.getItem(THEME_KEY) || 'auto');
          let theme = themeMode === 'auto' ? getSystemTheme() : themeMode;
          mount.setAttribute("data-theme", theme);
          // React to system theme changes only in AUTO mode
          try {
            const onMql = () => {
              if ((localStorage.getItem(THEME_KEY) || 'auto') !== 'auto') return;
              const th = getSystemTheme();
              setTheme(th);
              try { renderAll(); try { overlayLabels.updateAll(); } catch(_){} } catch(_){}
            };
            // Reaguj zarówno na light, jak i dark (niektóre silniki sygnalizują jeden kanał pewniej)
            const add = (mql) => {
              if (!mql) return;
              if (typeof mql.addEventListener === 'function') mql.addEventListener('change', onMql);
              else if (typeof mql.addListener === 'function') mql.addListener(onMql);
            };
            add(prefersLight); add(prefersDark);
            // Safety net: when wracamy do karty, zsynchronizuj w AUTO
            document.addEventListener('visibilitychange', () => {
              if (document.visibilityState !== 'visible') return;
              if ((localStorage.getItem(THEME_KEY) || 'auto') !== 'auto') return;
              onMql();
            });
            // Synchronizacja między kartami (zmiana trybu w innej karcie)
            window.addEventListener('storage', (e) => {
              if (e.key !== THEME_KEY) return;
              const mode = e.newValue || 'auto';
              if (mode === 'auto') setTheme(getSystemTheme()); else setTheme(mode);
              try { renderAll(); try { overlayLabels.updateAll(); } catch(_){} } catch(_){}
            });
          } catch(_) {}

          const state = {
            vehicleIndex: 0,
            items: [], // {id,type,L,W,H,weight,stackable,stackCount,x,y,rot}
            selectedId: null,
            history: [],
            future: [],
            suggestions: [],
            clipboard: null,
            variants: { plans: [], index: 0 },
            viewMode: "2d",
            compareOn: false,
          };

          // -------- Minimalny store/dispatcher (MVP porządkowania stanu) --------
          // Ujednolica mutacje i odświeżanie, ułatwi kolejne kroki (A/B, przekrój, overlay osi).
          const Store = (() => {
            const listeners = [];
            return {
              get() {
                return state;
              },
              set(patch = {}) {
                Object.assign(state, patch);
                renderAll();
                listeners.forEach((fn) => {
                  try {
                    fn(state);
                  } catch (_) {}
                });
              },
              subscribe(fn) {
                listeners.push(fn);
                return () => {
                  const i = listeners.indexOf(fn);
                  if (i > -1) listeners.splice(i, 1);
                };
              },
              mutate(label, fn) {
                try {
                  pushHistory();
                  fn(state);
                  renderAll();
                } catch (e) {
                  console.error("Store.mutate fail:", label, e);
                }
              },
            };
          })();

          function t(key, vars = {}) {
            const str =
              key.split(".").reduce((o, k) => o && o[k], I18N[lang]) || key;
            return str.replace(
              /\{(\w+)\}/g,
              (_, k) => vars[k] ?? "{" + k + "}"
            );
          }
          function vehicle() {
            return VEHICLES[state.vehicleIndex];
          }

          // ===================== DOM BUILD =====================
          mount.innerHTML = `
        <div class="vp-wrap" role="region" aria-label="Van Pack">
          <header id="toolbar" role="toolbar" aria-label="${t('tools_aria')}">
            <button id="zoomOut">−</button>
            <button id="zoomIn">+</button>
            <button id="toggleGrid" class="secondary">${t("grid")}</button>
            <button id="resetView" class="secondary">${t("reset_view")}</button>
            <button id="toggleSheet" class="secondary" title="${t('panels_title')}">${t('panels_title')} ▴▾</button>
            <span id="status" aria-live="polite">${t('status_ready')}</span>
            <!-- Language Switcher -->
            <div class="hdr-lang">
              <button class="hdr-btn hdr-lang-btn" aria-label="${t('choose_language_aria')}" aria-haspopup="menu" aria-expanded="false" id="lang-trigger">
                <span class="hdr-flag">🇵🇱</span><span class="hdr-lang-code">PL</span>
                <svg class="hdr-ico" viewBox="0 0 24 24" aria-hidden="true"><path d="M7 10l5 5 5-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
              </button>
              <div class="hdr-popover hdr-lang-pop" role="menu" aria-labelledby="lang-trigger" id="lang-popover" hidden>
                <ul class="hdr-lang-list" role="none">
                  <li role="none"><button role="menuitemradio" aria-checked="false" data-lang="pl"><span>🇵🇱</span><b>PL</b><em>Polski</em></button></li>
                  <li role="none"><button role="menuitemradio" aria-checked="false" data-lang="ru"><span>🇷🇺</span><b>RU</b><em>Русский</em></button></li>
                  <li role="none"><button role="menuitemradio" aria-checked="false" data-lang="uk"><span>🇺🇦</span><b>UA</b><em>Українська</em></button></li>
                  <li role="none"><button role="menuitemradio" aria-checked="false" data-lang="it"><span>🇮🇹</span><b>IT</b><em>Italiano</em></button></li>
                  <li role="none"><button role="menuitemradio" aria-checked="false" data-lang="fr"><span>🇫🇷</span><b>FR</b><em>Français</em></button></li>
                  <li role="none"><button role="menuitemradio" aria-checked="false" data-lang="de"><span>🇩🇪</span><b>DE</b><em>Deutsch</em></button></li>
                  <li role="none"><button role="menuitemradio" aria-checked="false" data-lang="en"><span>🇬🇧</span><b>EN</b><em>English</em></button></li>
                </ul>
              </div>
            </div>
            <div class="theme" aria-label="${t("theme")}" style="margin-left:8px;">
              <div class="toggle" id="themeToggle" role="button" aria-pressed="${
                theme !== "dark"
              }" tabindex="0" title="${t('toggle_theme_title')}">
                <div class="knob" id="themeKnob">${
                  theme === "dark" ? "☾" : (theme === "sepia" ? "📖" : "☀")
                }</div>
              </div>
            </div>
            <input type="checkbox" id="gridToggle" checked style="display:none" />
          </header>
          

          <!-- Welcome banner -->
          <div class="welcome-banner" id="welcomeBanner">
            <button class="close-btn" onclick="this.parentElement.style.display='none'">×</button>
            <div style="color: #065f46; font-size: 14px; line-height: 1.5;">${t("welcome_banner")}</div>
          </div>

          <div class="topbar">
            <div>
              <div class="brand">
                <span class="brand-name">${t("title_vanfit")}</span>
              </div>
              <div class="title">${t("heading")}</div>
              <div class="muted" style="color:var(--muted); font-size:.95rem">${t(
                "sub"
              )}</div>
            </div>
          </div>

          <div class="row" id="vehRow">
            <span id="addVehChipInline" class="chip click" style="background:transparent;border:1px dashed var(--line);"><span class="plus-green">➕</span> ${t("custom_vehicle")}</span>
            <label for="vehSel">${t("vehicle")}</label>
            <select id="vehSel"></select>
            <div class="chip" id="vehDims"></div>
            <div class="chip" id="vehPayload"></div>
            <div class="chip" id="vehPallets"></div>
            <div class="chip" id="vehLDM"></div>
          </div>
          <div id="vehDD" class="veh-dd" aria-label="${t("vehicle")}" role="menu" hidden></div>
          <div id="custDD" class="veh-dd" aria-label="${t("custom_vehicle")}" role="dialog" hidden></div>


          <!-- Własny pojazd – rozwijany panel + akcje w jednej linii -->
          <section class="expander" id="vehExpander" data-open="false">
            <header class="expander-head" role="button" tabindex="0" aria-expanded="false" title="${t('open_close_title')}">
              <div class="head-left" style="display:flex;align-items:center;gap:10px">
                <div class="head-actions" aria-label="${t('selected_actions_aria')}" style="display:flex;gap:8px">
                  <button class="btn secondary" data-act="stack-+">${t("stacking_plus")}</button>
                  <button class="btn secondary" data-act="stack--">${t("stacking_minus")}</button>
                </div>
              </div>
              <div class="spacer"></div>
              <span class="caret" aria-hidden="true"></span>
            </header>
            <!-- Body removed: inline vehicle inputs and create button no longer shown -->
          </section>
          

          <div class="grid">
            <div class="stage-card">
              <div class="stage-wrap">
                <svg class="board" tabindex="0" aria-label="Board"></svg>
                <!-- Overlay viewport: floor (canvas), overlay (svg), labels (div) -->
                <section id="viewport" tabindex="0" aria-hidden="true">
                  <canvas id="floor"></canvas>
                  <svg id="overlay" aria-hidden="true"></svg>
                  <div id="labels" aria-hidden="true"></div>
                </section>
                <!-- Three.js viewport (hidden until 3D mode) -->
                <section id="view3d" aria-label="${t("view_3d")}" tabindex="0" hidden></section>
                <canvas class="board3d" id="board3d" aria-label="Board 3D"></canvas>
                <div class="hud-layer" id="hudLayer"></div>
                <svg class="boardB" aria-label="Board B"></svg>
              </div>
              <div id="errBox" class="error" aria-hidden="true"></div>

              

              <!-- UNDERBAR just under cargo area -->
              <div class="underbar">
                <!-- Metrics on the left -->
                <div class="metrics-bar" style="flex:1;display:flex;flex-wrap:wrap;gap:10px;align-items:center">
                  <div class="card">
                    <div style="display:flex;justify-content:space-between"><span>${t(
                      "volume_used"
                    )}</span><span id="volText"></span></div>
                    <progress id="volBar" value="0" max="100"></progress>
                  </div>
                  <div class="card">
                    <div style="display:flex;justify-content:space-between"><span>${t(
                      "weight_used"
                    )}</span><span id="kgText"></span></div>
                    <progress id="kgBar" value="0" max="100"></progress>
                  </div>
                  <span class="badge ok" id="fitBadge">${t("fits")}</span>
                  <span class="badge" id="leftBadge"></span>
                  <span class="tiny" id="axleInfo" style="display:block;margin-top:4px"></span>
                  <div id="warnList" style="display:flex;gap:6px;flex-wrap:wrap;margin-top:4px"></div>
                </div>
                <!-- Actions on the right -->
                <div class="actions-bar" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:flex-end">
                  <button class="btn secondary" data-act="undo">⟲ ${t(
                    "undo"
                  )}</button>
                  <button class="btn secondary" data-act="redo">⟳ ${t(
                    "redo"
                  )}</button>
                  <button class="btn secondary" data-act="rotR">${
                    t("rotateR") || "↷ 90°"
                  }</button>
                  <button class="btn secondary" data-act="autopack">🤖 ${t(
                    "autopack"
                  )}</button>
                  <button class="btn secondary" data-act="altpack">🎲 ${t("try_another")}</button>
                  <button class="btn secondary" data-act="compare">🆚 ${t("ab_test") || 'A/B'}</button>
                  <button class="btn secondary" data-act="stackAll">🧱 ${t(
                    "stackAll"
                  )}</button>
                  <button class="btn secondary" data-act="prevVar">⬅ ${t(
                    "prev"
                  )}</button>
                  <span id="varLabel" class="chip" style="align-self:center">${t("variant")} 0/0</span>
                  <button class="btn secondary" data-act="nextVar">${t("next")} ➡</button>
                  <button class="btn secondary" id="view3D">🎥 ${t("view_3d")}</button>
                  <button class="btn secondary" id="sketch3D" title="${t('sketch_mode_title')}">✏️ ${t('sketch_mode')}</button>
                  <!-- 3D camera presets -->
                  <button class="btn secondary" data-act="camTop">${t("view_top")}</button>
                  <button class="btn secondary" data-act="camSide">${t("view_side")}</button>
                  <button class="btn secondary" data-act="camRear">${t("view_rear")}</button>
                  <button class="btn secondary" data-act="camRearLeft">${t("view_rear_left") || '3/4 rear-left'}</button>
                  <button class="btn secondary" data-act="camPersp">${t("view_perspective")}</button>
                  <!-- 3D modes -->
                  <button class="btn secondary" data-act="camOverview">${t("overview")}</button>
                  <button class="btn secondary" data-act="sectionToggle">${t("section")}</button>
                  <input type="range" id="sectionSlider" min="0" max="100" value="50" title="${t('section_pos_title')}" style="width:140px;display:none">
                  <button class="btn secondary" data-act="layer1" title="${t("layer")} 1">${t("layer")} 1</button>
                  <button class="btn secondary" data-act="layer2" title="${t("layer")} 2">${t("layer")} 2</button>
                  <button class="btn secondary" data-act="layer3" title="${t("layer")} 3">${t("layer")} 3</button>
                  <button class="btn secondary" data-act="layerAll" title="${t("all")}">${t("all")}</button>
                  <button class="btn secondary" data-act="top2d" title="${t("top2d")}">${t("top2d")}</button>
                  <button class="btn secondary" data-act="camAll" title="${t("show_all")}">${t("show_all")}</button>
                  <button class="btn secondary" data-act="camLoaded" title="${t("show_loaded")}">${t("show_loaded")}</button>
                  <button class="btn secondary tiny" data-act="stack-+" title="${t("stacking_plus")}">＋</button>
                  <button class="btn secondary tiny" data-act="stack--" title="${t("stacking_minus")}">−</button>
                  <button class="btn ghost" data-act="delete" title="${t("deleteSel")}">${t("deleteSel")}</button>
                </div>
              </div>
            </div>

            <aside class="side">
              <h4>${t("bulk_title")}</h4>
              <div class="bulk">
                <textarea id="bulkText" rows="4" placeholder="${t(
                  "bulk_hint"
                )}"></textarea>
                <div class="row" style="margin-top:8px">
                  <button class="btn" id="bulkAdd">${t("bulk_btn")}</button>
                  <span class="note">${t("keywords")}</span>
                </div>
                <div id="bulkOut" class="out" aria-live="polite"></div>
              </div>

              <h4>${t("quick_presets")}</h4>
              <div class="preset-list"></div>

              <h4>${t("custom_item")}</h4>
              <div class="custom-line">
                <input id="cOne" type="text" placeholder="np. 120x80x180x350 x2, 60x40x40x10 x10" />
                <label class="chk" style="margin:0"><input type="checkbox" id="cStack" checked><span>${t("stackable")}</span></label>
                <button class="btn" id="cAddOne">${t('add_btn') || ('➕ ' + t('add'))}</button>
              </div>
              <div class="custom-hint">${t("format_hint")}</div>

              <div class="selected-panel" id="selPanel">
                <h4>${t("selected_item")}</h4>
                <!-- Przyciski zostały przeniesione nad sekcję "Własny pojazd" -->
              </div>

              <!-- Moved metrics and status into bottom bar -->

              <details>
                <summary>${t("loading_rules")}</summary>
                <ul style="margin:8px 0 0 18px; color:var(--muted)">
                  <li>Ciężkie sztuki bliżej środka (40–60% długości) i osi szerokości.</li>
                  <li>Unikaj przekroczeń szerokości i wysokości – to twarde ograniczenia.</li>
                  <li>Piętrowanie tylko gdy stabilne i nośność dolnej warstwy nie jest przekroczona.</li>
                  <li>Wysokie/wąskie elementy – nie przy samej burcie; dociśnij je innymi lub pasami.</li>
                  <li>LDM traktuj jako wskaźnik długości zajętej względem szerokości naczepy.</li>
                </ul>
              </details>

              <div class="actions">
                <button class="btn secondary" data-act="reset">${t(
                  "reset"
                )}</button>
                <button class="btn secondary" data-act="save">💾 ${t(
                  "save"
                )}</button>
                <button class="btn secondary" data-act="share">🔗 ${t(
                  "share"
                )}</button>
                <button class="btn" id="pdfExport">🖨️ ${t("export_pdf")}</button>
              </div>
            </aside>
          </div>
        </div>

        
        <div id="toast" role="status" aria-live="polite" aria-atomic="true"></div>
      `;

      // Theme toggle (AUTO + MANUAL)
      const themeToggle = mount.querySelector("#themeToggle");
      const themeKnob = mount.querySelector("#themeKnob");
      // Button hover/press JS: add press class for crisper feel on pointerdown
      (function enhanceButtons(){
        try {
          const btns = mount.querySelectorAll('.btn, #toolbar button, .hdr-btn');
          btns.forEach(btn => {
            btn.addEventListener('pointerdown', () => btn.classList.add('is-pressing'));
            ['pointerup','pointerleave','pointercancel','blur'].forEach(ev => btn.addEventListener(ev, ()=> btn.classList.remove('is-pressing')));
          });
        } catch(_) {}
      })();
          function setTheme(th) {
            mount.setAttribute("data-theme", th);
            try {
              themeKnob.textContent = (th === 'dark') ? '☾' : (th === 'sepia' ? '📖' : '☀');
            } catch(_){}
            try { themeToggle?.setAttribute('aria-pressed', String(th !== 'dark')); } catch(_){}
          }
          // Enable MANUAL toggle: click = jasny/ciemny (zapis), Shift+klik = AUTO
          try {
            themeToggle?.removeAttribute('aria-disabled');
            themeToggle?.style?.removeProperty('pointer-events');
            const baseTitle = t('toggle_theme_title') || 'Przełącz motyw';
            function updateToggleTitle(){
              const mode = (localStorage.getItem(THEME_KEY) || 'auto');
              const cur = mount.getAttribute('data-theme') || 'dark';
              const tip = ' (klik: jasny/sepia/ciemny; Shift+klik: auto)';
              themeToggle?.setAttribute('title', baseTitle + (mode==='auto' ? ' — AUTO' : ' — MANUAL') + ` [${cur}]` + tip);
            }
            updateToggleTitle();
            themeToggle?.addEventListener('click', (e) => {
              if (e.shiftKey) {
                localStorage.setItem(THEME_KEY, 'auto');
                setTheme(prefersLight.matches ? 'light' : 'dark');
                updateToggleTitle();
                return;
              }
              // Manual cycle: light -> sepia -> dark -> light
              const now = mount.getAttribute('data-theme') || 'dark';
              const next = (now === 'light') ? 'sepia' : (now === 'sepia' ? 'dark' : 'light');
              localStorage.setItem(THEME_KEY, next);
              setTheme(next);
              updateToggleTitle();
            });
            themeToggle?.addEventListener('keydown', (e) => {
              if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); themeToggle?.click(); }
              if (e.key.toLowerCase?.() === 'a') { // A -> AUTO
                e.preventDefault();
                localStorage.setItem(THEME_KEY, 'auto');
                setTheme(prefersLight.matches ? 'light' : 'dark');
                updateToggleTitle();
              }
            });
          } catch(_) {}

          // Language switcher wiring
  (function(){
            const btn = mount.querySelector('#lang-trigger');
            const pop = mount.querySelector('#lang-popover');
            const FLAGS = { pl:'🇵🇱', ru:'🇷🇺', uk:'🇺🇦', it:'🇮🇹', fr:'🇫🇷', de:'🇩🇪', en:'🇬🇧' };
            const CODEMAP = { uk: 'UA' };
            function updateButton(){
              try {
                btn.querySelector('.hdr-flag').textContent = FLAGS[lang] || '🏳️';
                btn.querySelector('.hdr-lang-code').textContent = (CODEMAP[lang] || lang || 'pl').toUpperCase();
                pop?.querySelectorAll('[role="menuitemradio"]').forEach(el=>{
                  const on = el.getAttribute('data-lang') === lang;
                  el.setAttribute('aria-checked', String(on));
                });
              } catch(_) {}
            }
            function setLang(code){
              if (!code) return;
              lang = code;
              localStorage.setItem('vp_lang', lang);
              try { document.documentElement.setAttribute('lang', lang); } catch(_) {}
              try { mount.setAttribute('data-lang', lang); } catch(_) {}
              updateButton();
              // Update texts that were created once
              try { const tl = mount.querySelector('.title'); if (tl) tl.textContent = t('heading'); } catch(_) {}
              try { const sb = mount.querySelector('.muted'); if (sb) sb.textContent = t('sub'); } catch(_) {}
              try { const wb = mount.querySelector('#welcomeBanner div'); if (wb) wb.textContent = t('welcome_banner'); } catch(_) {}
              // Toolbar button labels
              try { const tg = mount.querySelector('#toggleGrid'); if (tg) tg.textContent = t('grid'); } catch(_) {}
              try { const rv = mount.querySelector('#resetView'); if (rv) rv.textContent = t('reset_view'); } catch(_) {}
              // Status label
              try { const st = mount.querySelector('#status'); if (st) st.textContent = t('status_ready') || st.textContent; } catch(_) {}
              // Vehicle row labels
              try { const br = mount.querySelector('.brand-name'); if (br) br.textContent = t('title_vanfit'); } catch(_) {}
              try { const vehLbl = mount.querySelector('label[for="vehSel"]'); if (vehLbl) vehLbl.textContent = t('vehicle'); } catch(_) {}
            try { const chip = mount.querySelector('#addVehChipInline'); if (chip) chip.innerHTML = '<span class="plus-green">➕</span> ' + t('custom_vehicle'); } catch(_) {}
              // Side panel headers + bulk controls
              try {
                const sideH = mount.querySelectorAll('aside.side > h4');
                if (sideH[0]) sideH[0].textContent = t('bulk_title');
                if (sideH[1]) sideH[1].textContent = t('quick_presets');
                if (sideH[2]) sideH[2].textContent = t('custom_item');
                const selH = mount.querySelector('#selPanel h4'); if (selH) selH.textContent = t('selected_item');
                const sum = mount.querySelector('aside.side details > summary'); if (sum) sum.textContent = t('loading_rules');
                const bulkBtn = mount.querySelector('#bulkAdd'); if (bulkBtn) bulkBtn.textContent = t('bulk_btn');
                const bulkNote = mount.querySelector('.bulk .note'); if (bulkNote) bulkNote.textContent = t('keywords');
                const bulkTA = mount.querySelector('#bulkText'); if (bulkTA) bulkTA.setAttribute('placeholder', t('bulk_hint'));
                const cStackLbl = mount.querySelector('#cStack')?.closest('label')?.querySelector('span'); if (cStackLbl) cStackLbl.textContent = t('stackable');
              } catch(_) {}
              // Actions bar (buttons)
              try {
                const setBtn = (sel, label, prefix='')=>{ const el = mount.querySelector(sel); if (el) el.textContent = prefix + t(label); };
                setBtn("[data-act=\"undo\"]", 'undo', '⟲ ');
                setBtn("[data-act=\"redo\"]", 'redo', '⟳ ');
                const rotR = mount.querySelector('[data-act=\"rotR\"]'); if (rotR) rotR.textContent = t('rotateR') || t('rotate_right') || rotR.textContent;
                setBtn("[data-act=\"autopack\"]", 'autopack', '🤖 ');
                setBtn("[data-act=\"altpack\"]", 'try_another', '🎲 ');
                const cmp = mount.querySelector('[data-act=\"compare\"]'); if (cmp) cmp.textContent = '🆚 ' + (t('ab_test')||'A/B');
                setBtn("[data-act=\"stackAll\"]", 'stackAll', '🧱 ');
                setBtn("[data-act=\"prevVar\"]", 'prev', '⬅ ');
                const vl = mount.querySelector('#varLabel'); if (vl) { const m = vl.textContent.match(/(\d+\/\d+)/); const nn = m? m[1] : '0/0'; vl.textContent = `${t('variant')} ${nn}`; }
                setBtn("[data-act=\"nextVar\"]", 'next');
                const v3 = mount.querySelector('#view3D'); if (v3) v3.textContent = '🎥 ' + t('view_3d');
                const sk = mount.querySelector('#sketch3D'); if (sk) { sk.textContent = '✏️ ' + t('sketch_mode'); sk.setAttribute('title', t('sketch_mode_title')); }
                const rl = mount.querySelector('[data-act=\"camRearLeft\"]'); if (rl) rl.textContent = t('view_rear_left') || '3/4 rear-left';
                const m = [ ['camTop','view_top'], ['camSide','view_side'], ['camRear','view_rear'], ['camPersp','view_perspective'], ['camOverview','overview'], ['sectionToggle','section'] ];
                m.forEach(([act,key])=>{ const el = mount.querySelector(`[data-act=\"${act}\"]`); if (el) el.textContent = t(key); });
                const l1 = mount.querySelector('[data-act=\"layer1\"]'); if (l1) l1.textContent = `${t('layer')} 1`;
                const l2 = mount.querySelector('[data-act=\"layer2\"]'); if (l2) l2.textContent = `${t('layer')} 2`;
                const l3 = mount.querySelector('[data-act=\"layer3\"]'); if (l3) l3.textContent = `${t('layer')} 3`;
                const la = mount.querySelector('[data-act=\"layerAll\"]'); if (la) la.textContent = t('all');
                const top2d = mount.querySelector('[data-act=\"top2d\"]'); if (top2d) { top2d.textContent = t('top2d'); top2d.setAttribute('title', t('top2d')); }
                setBtn('[data-act=\"camAll\"]','show_all');
                setBtn('[data-act=\"camLoaded\"]','show_loaded');
                const delSel = mount.querySelector('[data-act=\"delete\"]'); if (delSel) delSel.textContent = t('deleteSel');
                const pdf = mount.querySelector('#pdfExport'); if (pdf) pdf.textContent = '🖨️ ' + t('export_pdf');
              } catch(_) {}
              // Metrics labels (volume/weight)
              try {
                const vtx = mount.querySelector('#volText'); if (vtx && vtx.parentElement?.firstElementChild) vtx.parentElement.firstElementChild.textContent = t('volume_used');
                const kgt = mount.querySelector('#kgText'); if (kgt && kgt.parentElement?.firstElementChild) kgt.parentElement.firstElementChild.textContent = t('weight_used');
              } catch(_) {}
              // Inline vehicle form labels
              try {
                const lbKg = mount.querySelector('label[for="vKg"]'); if (lbKg) lbKg.textContent = t('payload');
                const lbEP = mount.querySelector('label[for="vEP"]'); if (lbEP) lbEP.textContent = (t('eur_pallets')||'EP');
                const lbGrid = mount.querySelector('label[for="vGrid"]'); if (lbGrid) lbGrid.textContent = t('grid') + ' (cm)';
              } catch(_) {}
              // Rebuild presets to localize any item text
              try { renderPresets(); } catch(_) {}
              // Refresh static attributes/texts
              try {
                const tb = mount.querySelector('#toolbar'); if (tb) tb.setAttribute('aria-label', t('tools_aria'));
                const lt = mount.querySelector('#lang-trigger'); if (lt) lt.setAttribute('aria-label', t('choose_language_aria'));
                const th = mount.querySelector('#themeToggle'); if (th) { const mode = (localStorage.getItem('vp_theme_mode')||'auto'); const cur = mount.getAttribute('data-theme')||'dark'; th.setAttribute('title', (t('toggle_theme_title')||'Przełącz motyw') + (mode==='auto'?' — AUTO':' — MANUAL') + ` [${cur}]` + ' (klik: jasny/sepia/ciemny; Shift+klik: auto)'); }
                const sh = mount.querySelector('#toggleSheet'); if (sh) { sh.setAttribute('title', t('panels_title')); sh.firstChild && (sh.firstChild.nodeType===3) ? (sh.firstChild.nodeValue = t('panels_title') + ' ▴▾') : (sh.textContent = t('panels_title') + ' ▴▾'); }
                const hd = mount.querySelector('.expander-head'); if (hd) hd.setAttribute('title', t('open_close_title'));
                const ha = mount.querySelector('.head-actions'); if (ha) ha.setAttribute('aria-label', t('selected_actions_aria'));
                const ss = mount.querySelector('#sectionSlider'); if (ss) ss.setAttribute('title', t('section_pos_title'));
              } catch(_) {}
              try { renderAll(); overlayLabels.updateAll(); updateStatus(); } catch(_) {}
            }
            function openPop(){ if (pop && pop.hasAttribute('hidden')) { pop.removeAttribute('hidden'); btn?.setAttribute('aria-expanded','true'); } }
            function closePop(){ if (pop && !pop.hasAttribute('hidden')) { pop.setAttribute('hidden',''); btn?.setAttribute('aria-expanded','false'); } }
            btn?.addEventListener('click', (e)=>{
              e.stopPropagation();
              if (pop.hasAttribute('hidden')) openPop(); else closePop();
            });
            // Hover to open on non-mobile
            try {
              if (getDevice() !== 'mobile') {
                let hoverTimer = null;
                const scheduleClose = ()=>{ clearTimeout(hoverTimer); hoverTimer = setTimeout(()=> closePop(), 160); };
                const cancelClose   = ()=>{ clearTimeout(hoverTimer); };
                btn?.addEventListener('mouseenter', ()=>{ cancelClose(); openPop(); });
                pop?.addEventListener('mouseenter', ()=> cancelClose());
                btn?.addEventListener('mouseleave', ()=> scheduleClose());
                pop?.addEventListener('mouseleave', ()=> scheduleClose());
              }
            } catch(_) {}
            pop?.querySelectorAll('[data-lang]')?.forEach(el=> el.addEventListener('click', ()=>{
              setLang(el.getAttribute('data-lang'));
              closePop();
            }));
            document.addEventListener('pointerdown', (ev)=>{
              if (!pop || pop.hasAttribute('hidden')) return;
              const t = ev.target; if (!btn.contains(t) && !pop.contains(t)) { closePop(); }
            });
            updateButton();
          })();

          // Cache DOM
          const board = mount.querySelector("svg.board");
          const board3d = mount.querySelector("#board3d");
          const hudLayer = mount.querySelector("#hudLayer");
          const boardB = mount.querySelector("svg.boardB");
          const stageWrap = mount.querySelector(".stage-wrap");
          const section = mount.querySelector("svg.section");
          const secLabel = mount.querySelector("#secLabel");
          const vehSel = mount.querySelector("#vehSel");
          const specsDims = mount.querySelector("#vehDims");
          const specsPayload = mount.querySelector("#vehPayload");
          const specsPallets = mount.querySelector("#vehPallets");
          const specsLDM = mount.querySelector("#vehLDM");
          const presetList = mount.querySelector(".preset-list");
          const volBar = mount.querySelector("#volBar");
          const kgBar = mount.querySelector("#kgBar");
          const volText = mount.querySelector("#volText");
          const kgText = mount.querySelector("#kgText");
          const fitBadge = mount.querySelector("#fitBadge");
          const leftBadge = mount.querySelector("#leftBadge");
          const selPanel = mount.querySelector("#selPanel");
          const errBox = mount.querySelector("#errBox");
          const varLabel = mount.querySelector("#varLabel");
          const view3DBtn = mount.querySelector("#view3D");
          const view3d = mount.querySelector("#view3d");
          const sectionSlider = mount.querySelector('#sectionSlider');
          const toggleSheetBtn = mount.querySelector('#toggleSheet');
          const pdfBtn = mount.querySelector('#pdfExport');

          // Bulk parser elements
          const bulkText = mount.querySelector("#bulkText");
          const bulkAdd = mount.querySelector("#bulkAdd");
          const bulkOut = mount.querySelector("#bulkOut");

          // Add vehicle form element (inline create button removed)

          // ===================== UTIL =====================
          function getDevice(){
            const w = Math.max(0, window.innerWidth || document.documentElement.clientWidth || 0);
            if (w < 768) return 'mobile';
            if (w < 1024) return 'tablet';
            return 'desktop';
          }
          function tuneRendererForDevice(dev){
            if (!threeCtx || !threeCtx.renderer) return;
            const dpr = window.devicePixelRatio || 1;
            if (dev === 'desktop') {
              threeCtx.renderer.setPixelRatio(Math.min(2, dpr));
              threeCtx.renderer.localClippingEnabled = !!threeCtx.state.sectionEnabled;
            } else if (dev === 'tablet') {
              threeCtx.renderer.setPixelRatio(1);
              threeCtx.renderer.localClippingEnabled = false;
            } else { // mobile
              threeCtx.renderer.setPixelRatio(1);
              threeCtx.renderer.localClippingEnabled = false;
            }
          }
          function applyDevice(){
            const dev = getDevice();
            mount.setAttribute('data-device', dev);
            if (dev === 'mobile') {
              if (state.viewMode !== '2d') {
                state.viewMode = '2d';
                if (view3DBtn) view3DBtn.textContent = '🎥 ' + t('view_3d');
              }
            }
            try { if (threeCtx && threeCtx.init) tuneRendererForDevice(dev); } catch(_) {}
          }
          const uid = () => "it" + Math.random().toString(36).slice(2, 8);
          const deepClone = (obj) => JSON.parse(JSON.stringify(obj));
          function dispatchSelectionChange(){
            try { mount.dispatchEvent(new Event('selectionchange')); } catch(_) {}
          }

          function cm3ToM3(c) {
            return c / 1_000_000;
          }
          function volItem(it) {
            return cm3ToM3(it.L * it.W * it.H) * it.stackCount;
          }
          function weightItem(it) {
            return (it.weight || 0) * it.stackCount;
          }
          function dims2D(it) {
            const rotated = it.rot % 2 !== 0;
            return rotated ? { l: it.W, w: it.L } : { l: it.L, w: it.W };
          }
          
          // ===================== World<->Screen + Render Pipeline (floor canvas) =====================
          // Base configuration: 4 px per cm, zoom in [0.3, 6], pan in CSS px
          const VIEW = {
            basePxPerCm: 4,
            zoom: 1,
            minZoom: 0.3,
            maxZoom: 6,
            pan: { x: 0, y: 0 },
          };
          // Track whether user changed view (so we don't override on resize)
          let VIEW_TOUCHED = false;
          const vpFloor = () => mount.querySelector('#floor');

          function getPxPerCm() {
            return Math.max(0.0001, VIEW.basePxPerCm * VIEW.zoom);
          }
          // World (cm) to screen (CSS px)
          function worldToScreen(pt) {
            const s = getPxPerCm();
            return { sx: VIEW.pan.x + (pt.x || 0) * s, sy: VIEW.pan.y + (pt.y || 0) * s };
          }
          // Screen (CSS px) to world (cm)
          function screenToWorld(pt) {
            const s = getPxPerCm();
            return { x: ((pt.sx || 0) - VIEW.pan.x) / s, y: ((pt.sy || 0) - VIEW.pan.y) / s };
          }
          function resizeCanvasIfNeeded(dpr) {
            const cv = vpFloor();
            if (!cv) return { w: 0, h: 0 };
            const rect = cv.getBoundingClientRect();
            const needW = Math.max(1, Math.round(rect.width * dpr));
            const needH = Math.max(1, Math.round(rect.height * dpr));
            if (cv.width !== needW || cv.height !== needH) {
              cv.width = needW;
              cv.height = needH;
            }
            return { w: rect.width, h: rect.height };
          }
          function setWorldTransform(ctx, pxPerCm, pan) {
            const dpr = window.devicePixelRatio || 1;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.translate(pan.x, pan.y);
            ctx.scale(pxPerCm, pxPerCm);
          }
          // Placeholder drawing stages
          function computeGridSteps(pxPerCm) {
            if (pxPerCm >= 12) return { minor: 1, major: 10 };
            if (pxPerCm >= 6) return { minor: 2, major: 10 };
            return { minor: 5, major: 10 };
          }
          function drawGrid(ctx, veh2d, steps) {
            if (!steps) return;
            ctx.save();
            const s = getPxPerCm();
            const cv = vpFloor();
            const rect = cv ? cv.getBoundingClientRect() : { width: 0, height: 0 };
            // Visible world rect in cm (account for pan and zoom)
            const viewL = Math.max(0.0001, rect.width / Math.max(0.0001, s));
            const viewW = Math.max(0.0001, rect.height / Math.max(0.0001, s));
            const left = -VIEW.pan.x / Math.max(0.0001, s);
            const top  = -VIEW.pan.y / Math.max(0.0001, s);
            const step = Math.max(1, steps.minor);
            const major = Math.max(step, steps.major);
            const lw = 1 / Math.max(0.0001, s);
            const css = getComputedStyle(document.documentElement);
            const colMinor = (css.getPropertyValue('--gridMinor') || 'rgba(0,0,0,.08)').trim();
            const colMajor = (css.getPropertyValue('--gridMajor') || 'rgba(0,0,0,.16)').trim();
            const endX = left + viewL;
            const endY = top + viewW;
            // minor lines covering the whole visible canvas area
            ctx.strokeStyle = colMinor;
            ctx.lineWidth = lw;
            let startX = Math.floor(left / step) * step;
            for (let x = startX; x <= endX; x += step) {
              ctx.beginPath(); ctx.moveTo(x, top); ctx.lineTo(x, endY); ctx.stroke();
            }
            let startY = Math.floor(top / step) * step;
            for (let y = startY; y <= endY; y += step) {
              ctx.beginPath(); ctx.moveTo(left, y); ctx.lineTo(endX, y); ctx.stroke();
            }
            // major lines
            ctx.strokeStyle = colMajor;
            ctx.lineWidth = Math.max(lw, 1.5 * lw);
            const kx = Math.max(1, Math.round(major / step));
            startX = Math.floor(left / major) * major;
            for (let x = startX; x <= endX; x += major) {
              ctx.beginPath(); ctx.moveTo(x, top); ctx.lineTo(x, endY); ctx.stroke();
            }
            const ky = kx;
            startY = Math.floor(top / major) * major;
            for (let y = startY; y <= endY; y += major) {
              ctx.beginPath(); ctx.moveTo(left, y); ctx.lineTo(endX, y); ctx.stroke();
            }
            ctx.restore();
          }
          function drawVehicleRect(ctx, veh2d) {
            if (!veh2d) return;
            ctx.save();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#FF7A00';
            ctx.lineWidth = 2 / getPxPerCm();
            const L = Math.max(0, Number((veh2d && (veh2d.L ?? veh2d.W)) || 0));
            const W = Math.max(0, Number((veh2d && (veh2d.W ?? veh2d.H)) || 0));
            ctx.strokeRect(0, 0, L, W);
            ctx.restore();
          }
          function dims2D2(it){
            const r = (Number(it.rot)||0) % 2 !== 0;
            const w = Math.max(0, Number(it.w)||0);
            const h = Math.max(0, Number(it.h)||0);
            return r ? { w: h, h: w } : { w, h };
          }
          function drawItems(ctx, items) {
            ctx.save();
            ctx.lineWidth = 1.5 / getPxPerCm();
            ctx.strokeStyle = 'rgba(0,0,0,.35)';
            for (const it of (items || [])) {
              const d = dims2D2(it);
              const x = Math.max(0, Number(it.x)||0);
              const y = Math.max(0, Number(it.y)||0);
              const isSel = String(VP2D.selectedId||'') === String(it.id||'');
              ctx.fillStyle = 'rgba(127,160,255,0.18)';
              ctx.strokeStyle = isSel ? (getComputedStyle(document.documentElement).getPropertyValue('--accent')||'#FF7A00') : 'rgba(90,120,200,0.9)';
              ctx.lineWidth = isSel ? (3.0 / getPxPerCm()) : (1.5 / getPxPerCm());
              ctx.fillRect(x, y, d.w, d.h);
              ctx.strokeRect(x, y, d.w, d.h);
            }
            ctx.restore();
          }
          function hitTest(sx, sy){
            const p = screenToWorld({ sx, sy });
            for (let i = VP2D.items.length - 1; i >= 0; i--) {
              const it = VP2D.items[i];
              const d = dims2D2(it);
              const x = Number(it.x)||0, y = Number(it.y)||0;
              if (p.x >= x && p.x <= x + d.w && p.y >= y && p.y <= y + d.h) {
                return it;
              }
            }
            return null;
          }
          function layoutLabels2D(){
            const labels = mount.querySelector('#labels');
            const svg = mount.querySelector('#overlay');
            if (!labels || !svg) return;
            // Keep labels container visible
            const ids = new Set();
            for (const it of VP2D.items){
              const id = String(it.id||'');
              ids.add(id);
              let el = labels.querySelector(`.label[data-id="${CSS.escape(id)}"]`);
              const d = dims2D2(it);
              const text = `${Math.round(d.w)}×${Math.round(d.h)} cm, ${it.type||'—'}`;
              if (!el){
                el = document.createElement('div');
                el.className = 'label';
                el.dataset.id = id;
                labels.appendChild(el);
              }
              el.textContent = text;
              // Apply contrast based on item color
              try { applyLabelContrast(el, getItemColor(it)); } catch(_) {}
              // center label on item center via translate(-50%,-50%)
              const c = worldToScreen({ x: (Number(it.x)||0) + d.w/2, y: (Number(it.y)||0) + d.h/2 });
              el.style.left = `${Math.round(c.sx)}px`;
              el.style.top  = `${Math.round(c.sy)}px`;
              el.style.transform = 'translate(-50%, -50%)';
              const isSel = String(VP2D.selectedId||'') === id;
              el.classList.toggle('is-selected', !!isSel);
            }
            // remove stale
            Array.from(labels.querySelectorAll('.label')).forEach(n => {
              const id = n.getAttribute('data-id')||'';
              if (!ids.has(id)) n.remove();
            });
          }
          // Simple 2D state model for canvas mode
          const VP2D = {
            vehicle: { W: 178, H: 370 },
            items: [],
            selectedId: null,
            view: { zoom: 1, pan: { x: 0, y: 0 } },
          };
          const LS2D_KEY = 'vanfit:2d:v1';
          function saveState2D(){
            try {
              VP2D.view.zoom = VIEW.zoom;
              VP2D.view.pan = { x: VIEW.pan.x, y: VIEW.pan.y };
              localStorage.setItem(LS2D_KEY, JSON.stringify(VP2D));
            } catch(_){}
          }
          function loadState2D(){
            try {
              const raw = localStorage.getItem(LS2D_KEY);
              if (!raw) return false;
              const obj = JSON.parse(raw);
              if (obj && typeof obj === 'object') {
                if (obj.vehicle && typeof obj.vehicle.W === 'number' && typeof obj.vehicle.H === 'number') VP2D.vehicle = { W: obj.vehicle.W, H: obj.vehicle.H };
                if (Array.isArray(obj.items)) VP2D.items = obj.items.filter(Boolean).map(it=>({ id: String(it.id||uid()), x:+it.x||0, y:+it.y||0, w:+it.w||0, h:+it.h||0, rot:+it.rot||0, type: it.type||'paleta', weight: +it.weight||0 }));
                VP2D.selectedId = obj.selectedId ?? null;
                if (obj.view && typeof obj.view.zoom === 'number' && obj.view.pan) {
                  VP2D.view = { zoom: obj.view.zoom, pan: { x: +obj.view.pan.x||0, y: +obj.view.pan.y||0 } };
                  VIEW.zoom = Math.max(VIEW.minZoom, Math.min(VIEW.maxZoom, VP2D.view.zoom));
                  VIEW.pan = { x: VP2D.view.pan.x, y: VP2D.view.pan.y };
                }
                return true;
              }
            } catch(_){}
            return false;
          }
          function updateStatus(){
            const el = mount.querySelector('#status');
            if (!el) return;
            const pct = Math.round((VIEW.zoom||1) * 100);
            el.textContent = `${t('zoom')} ${pct}% • ${VP2D.items.length}`;
          }
          function isGridOn() {
            const cb = mount.querySelector('#gridToggle');
            return cb ? !!cb.checked : true;
          }
          function updateRulers() {
            const svg = mount.querySelector('#overlay');
            if (!svg) return;
            if (!isGridOn()) { svg.querySelector('#rulerX')?.remove(); svg.querySelector('#rulerY')?.remove(); return; }
            let gx = svg.querySelector('#rulerX');
            let gy = svg.querySelector('#rulerY');
            if (!gx) { gx = document.createElementNS('http://www.w3.org/2000/svg','g'); gx.setAttribute('id','rulerX'); svg.insertBefore(gx, svg.firstChild); }
            if (!gy) { gy = document.createElementNS('http://www.w3.org/2000/svg','g'); gy.setAttribute('id','rulerY'); svg.insertBefore(gy, svg.firstChild); }
            const w = Math.max(1, svg.clientWidth || 0);
            const h = Math.max(1, svg.clientHeight || 0);
            const band = 28;
            const theme = mount.getAttribute('data-theme') || 'dark';
            const fill = theme !== 'dark' ? 'rgba(255,255,255,0.75)' : 'rgba(0,0,0,0.25)';
            gx.innerHTML = '';
            gy.innerHTML = '';
            const rx = document.createElementNS('http://www.w3.org/2000/svg','rect');
            rx.setAttribute('x','0'); rx.setAttribute('y','0'); rx.setAttribute('width', String(w)); rx.setAttribute('height', String(band)); rx.setAttribute('fill', fill);
            gx.appendChild(rx);
            const ry = document.createElementNS('http://www.w3.org/2000/svg','rect');
            ry.setAttribute('x','0'); ry.setAttribute('y','0'); ry.setAttribute('width', String(band)); ry.setAttribute('height', String(h)); ry.setAttribute('fill', fill);
            gy.appendChild(ry);

            // Draw ticks and labels using world->screen scale
            try {
              const v = vehicle();
              const sc0 = overlayLabels.worldToScreen(0,0);
              const sc1 = overlayLabels.worldToScreen(1,0);
              const pxPerCmX = Math.max(0.0001, (sc1.x - sc0.x));
              const pxPerCmY = Math.max(0.0001, (overlayLabels.worldToScreen(0,1).y - sc0.y));
              // Minor step based on zoom; labels every 10 cm
              let minor = 1;
              if (pxPerCmX < 2.5) minor = 10; else if (pxPerCmX < 5) minor = 5; else if (pxPerCmX < 10) minor = 2;
              const major = 10; // label step (cm)

              // X ruler (top): vertical ticks
              for (let cm = 0; cm <= v.inner_cm.L; cm += minor) {
                const p = overlayLabels.worldToScreen(cm, 0);
                const x = Math.round(p.x);
                const isMajor = (cm % major) === 0;
                const len = isMajor ? band - 6 : Math.max(6, Math.floor(band * 0.45));
                const t = document.createElementNS('http://www.w3.org/2000/svg','line');
                t.setAttribute('x1', String(x)); t.setAttribute('y1', '0');
                t.setAttribute('x2', String(x)); t.setAttribute('y2', String(len));
                t.setAttribute('class','rulerTick');
                gx.appendChild(t);
                if (isMajor) {
                  const tx = document.createElementNS('http://www.w3.org/2000/svg','text');
                  tx.setAttribute('x', String(x + 2)); tx.setAttribute('y', String(band - 6));
                  tx.setAttribute('class','rulerText');
                  tx.textContent = String(cm);
                  gx.appendChild(tx);
                }
              }

              // Y ruler (left): horizontal ticks
              for (let cm = 0; cm <= v.inner_cm.W; cm += minor) {
                const p = overlayLabels.worldToScreen(0, cm);
                const y = Math.round(p.y);
                const isMajor = (cm % major) === 0;
                const len = isMajor ? band - 6 : Math.max(6, Math.floor(band * 0.45));
                const t = document.createElementNS('http://www.w3.org/2000/svg','line');
                t.setAttribute('x1', '0'); t.setAttribute('y1', String(y));
                t.setAttribute('x2', String(len)); t.setAttribute('y2', String(y));
                t.setAttribute('class','rulerTick');
                gy.appendChild(t);
                if (isMajor) {
                  const ty = document.createElementNS('http://www.w3.org/2000/svg','text');
                  ty.setAttribute('x', String(6)); ty.setAttribute('y', String(y + 3));
                  ty.setAttribute('class','rulerText');
                  ty.textContent = String(cm);
                  gy.appendChild(ty);
                }
              }
            } catch(_) {}
          }
          function render() {
            const cv = vpFloor();
            if (!cv) return;
            const ctx = cv.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = resizeCanvasIfNeeded(dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, rect.w, rect.h);
            const pxPerCm = getPxPerCm();
            setWorldTransform(ctx, pxPerCm, VIEW.pan);
            const steps = computeGridSteps(pxPerCm);
            // Use current vehicle dimensions (L×W) for the canvas grid/rect
            const vsel = vehicle();
            const dims2d = vsel ? { L: vsel.inner_cm.L, W: vsel.inner_cm.W } : VP2D.vehicle;
            if (isGridOn()) drawGrid(ctx, dims2d, steps);
            drawVehicleRect(ctx, dims2d);
            drawItems(ctx, VP2D.items);
            // Ensure overlay viewport is visible for labels/rulers
            try { const vp = mount.querySelector('#viewport'); if (vp) { vp.style.display='block'; vp.setAttribute('aria-hidden','false'); } } catch(_){ }
            updateRulers();
            layoutLabels2D();
            updateStatus();
          }

          // Fit canvas grid to the full cargo width (initial position)
          function fitCanvasToVehicleWidth(force = false){
            try {
              if (!force && VIEW_TOUCHED) return; // don't override user's view
              const cv = vpFloor(); if (!cv) return;
              const rect = cv.getBoundingClientRect();
              const v = vehicle();
              const desiredPxPerCm = Math.max(0.0001, rect.width / Math.max(1, v.inner_cm.L));
              const newZoom = desiredPxPerCm / Math.max(0.0001, VIEW.basePxPerCm);
              VIEW.zoom = Math.max(VIEW.minZoom, Math.min(VIEW.maxZoom, newZoom));
              // Align world origin to top-left of canvas
              VIEW.pan.x = 0;
              VIEW.pan.y = 0;
              VP2D.view.zoom = VIEW.zoom;
              VP2D.view.pan = { x: VIEW.pan.x, y: VIEW.pan.y };
              render();
              try { updateRulers(); } catch(_) {}
              try { layoutLabels2D(); } catch(_) {}
              try { overlayLabels.updateAll(); } catch(_) {}
            } catch(_) {}
          }

          // ===================== Zoom/Pan Interactions (canvas viewport) =====================
          // Zoom keeping the world point under the pointer fixed
          function zoomAt(pointer, factor) {
            try {
              if (!stageWrap || !isFinite(factor) || factor === 1) return;
              VIEW_TOUCHED = true;
              const rect = stageWrap.getBoundingClientRect();
              const sx = (pointer.clientX != null ? pointer.clientX : pointer.x) - rect.left;
              const sy = (pointer.clientY != null ? pointer.clientY : pointer.y) - rect.top;
              // world point before zoom
              const worldPt = screenToWorld({ sx, sy });
              const prev = VIEW.zoom || 1;
              const next = Math.max(VIEW.minZoom, Math.min(VIEW.maxZoom, prev * factor));
              if (next === prev) return;
              VIEW.zoom = next;
              const s = getPxPerCm();
              VIEW.pan.x = sx - worldPt.x * s;
              VIEW.pan.y = sy - worldPt.y * s;
              // Keep VP2D view in sync for persistence
              VP2D.view.zoom = VIEW.zoom;
              VP2D.view.pan = { x: VIEW.pan.x, y: VIEW.pan.y };
              // Update visuals
              try { render(); } catch(_) {}
              try { updateRulers(); } catch(_) {}
              try { layoutLabels2D(); } catch(_) {}
              try { overlayLabels.updateAll(); } catch(_) {}
            } catch(_) {}
          }

          (function initPanZoom(){
            if (!stageWrap) return;
            // Wheel + ctrl for smooth zoom
            try {
              stageWrap.addEventListener('wheel', (e) => {
                if (!e.ctrlKey) return; // only when ctrl pressed (pinch-zoom on many systems)
                e.preventDefault();
                const k = -0.0025; // sensitivity
                const factor = Math.exp(k * e.deltaY);
                zoomAt(e, factor);
              }, { passive: false });
            } catch(_) {}

            // Double-click zoom in at pointer
            try {
              stageWrap.addEventListener('dblclick', (e) => {
                e.preventDefault();
                zoomAt(e, 1.5);
              });
            } catch(_) {}

            // Panning: MMB or Space+LMB
            let spaceDown = false;
            function isTypingTarget(t){ return !!t && (t.isContentEditable || /^(INPUT|TEXTAREA|SELECT)$/.test(t.tagName)); }
            window.addEventListener('keydown', (e) => {
              if (e.code === 'Space' && !isTypingTarget(e.target)) {
                spaceDown = true;
                // Indicate pannable state
                if (!panDrag) stageWrap.style.cursor = 'grab';
                // prevent page scroll on space
                e.preventDefault();
              }
            });
            window.addEventListener('keyup', (e) => {
              if (e.code === 'Space') {
                spaceDown = false;
                if (!panDrag) stageWrap.style.cursor = '';
              }
            });

            let panDrag = null; // { id, start:{x,y}, pan0:{x,y} }
            function beginPan(e){
              VIEW_TOUCHED = true;
              panDrag = { id: e.pointerId, start: { x: e.clientX, y: e.clientY }, pan0: { x: VIEW.pan.x, y: VIEW.pan.y } };
              try { e.target.setPointerCapture(e.pointerId); } catch(_) {}
              stageWrap.style.cursor = 'grabbing';
            }
            function movePan(e){
              if (!panDrag || e.pointerId !== panDrag.id) return;
              const dx = e.clientX - panDrag.start.x;
              const dy = e.clientY - panDrag.start.y;
              VIEW.pan.x = panDrag.pan0.x + dx;
              VIEW.pan.y = panDrag.pan0.y + dy;
              VP2D.view.pan = { x: VIEW.pan.x, y: VIEW.pan.y };
              try { render(); } catch(_) {}
              try { updateRulers(); } catch(_) {}
              try { layoutLabels2D(); } catch(_) {}
              try { overlayLabels.updateAll(); } catch(_) {}
            }
            function endPan(e){
              if (!panDrag || e.pointerId !== panDrag.id) return;
              panDrag = null;
              stageWrap.style.cursor = spaceDown ? 'grab' : '';
              // push to history for undo granularity
              try { pushHistory(); } catch(_) {}
            }

            // Capture early to avoid interfering with item dragging
            stageWrap.addEventListener('pointerdown', (e) => {
              if (e.button === 1 || (spaceDown && e.button === 0)) {
                e.preventDefault();
                e.stopPropagation();
                beginPan(e);
              }
            }, { capture: true });
            stageWrap.addEventListener('pointermove', (e) => movePan(e), { capture: true });
            stageWrap.addEventListener('pointerup', (e) => endPan(e), { capture: true });
            stageWrap.addEventListener('pointercancel', (e) => endPan(e), { capture: true });

            // External cancel (e.g., ESC from viewport)
            try {
              document.addEventListener('vp-cancel-pan', () => {
                panDrag = null;
                stageWrap.style.cursor = spaceDown ? 'grab' : '';
              });
            } catch(_) {}

            // Toolbar buttons (zoom in/out/reset) — optional helpers
            try {
              const btnIn = mount.querySelector('#zoomIn');
              const btnOut = mount.querySelector('#zoomOut');
              const btnReset = mount.querySelector('#resetView');
              const centerPointer = () => {
                const r = stageWrap.getBoundingClientRect();
                return { clientX: r.left + r.width/2, clientY: r.top + r.height/2 };
              };
              btnIn?.addEventListener('click', () => zoomAt(centerPointer(), 1.2));
              btnOut?.addEventListener('click', () => zoomAt(centerPointer(), 1/1.2));
              btnReset?.addEventListener('click', () => {
                VIEW.zoom = 1; VIEW.pan = { x: 0, y: 0 }; VP2D.view = { zoom: 1, pan: { x: 0, y: 0 } };
                try { render(); } catch(_) {}
                try { updateRulers(); } catch(_) {}
                try { layoutLabels2D(); } catch(_) {}
                try { overlayLabels.updateAll(); } catch(_) {}
              });
            } catch(_) {}
          })();

          // ===================== Overlay Labels (IIFE) =====================
          // Provides: buildLabel(item), layoutLabels(), updateAll(), worldToScreen(x,y), test helpers
          const overlayLabels = (() => {
            let viewport = mount.querySelector('#viewport');
            let floor = mount.querySelector('#floor');
            let overlay = mount.querySelector('#overlay');
            let labels = mount.querySelector('#labels');
            let tip = null; // tooltip element for aria-describedby
            // Track the currently hovered item ID for auto-show labels
            let hotId = '';
            // Caches and helpers for label layout
            const labelSizeCache = new Map(); // Map<id, {w,h}>
            const placed = new Map(); // Map<id, {left,top,w,h}>
            let ro = null; // ResizeObserver for label content changes

            // Helper: parse CSS color to RGB array [r,g,b]
            function parseColor(c){
              if (!c) return [0,0,0];
              c = String(c).trim();
              // rgb/rgba
              let m = c.match(/^rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
              if (m) return [parseInt(m[1],10), parseInt(m[2],10), parseInt(m[3],10)];
              // hsl
              m = c.match(/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i);
              if (m) {
                const h = (+m[1]) % 360, s = (+m[2])/100, l = (+m[3])/100;
                function h2rgb(p,q,t){ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3-t)*6; return p; }
                let r,g,b; if (s === 0) { r=g=b=l; } else { const q = l < 0.5 ? l*(1+s) : l+s-l*s; const p = 2*l-q; r=h2rgb(p,q,(h/360)+1/3); g=h2rgb(p,q,(h/360)); b=h2rgb(p,q,(h/360)-1/3);} 
                return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
              }
              // hex #rgb or #rrggbb
              m = c.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
              if (m){
                let x = m[1];
                if (x.length===3) x = x.split('').map(ch=>ch+ch).join('');
                const n = parseInt(x,16);
                return [(n>>16)&255, (n>>8)&255, n&255];
              }
              return [0,0,0];
            }

            // Compute relative luminance (WCAG) and set contrasting styles
            // Backwards-compatible wrapper to the global applyLabelContrast
            function applyContrast(el, bgColor){
              try { applyLabelContrast(el, bgColor); } catch(_) {}
            }

            function ensureDOM() {
              if (!viewport) {
                viewport = document.createElement('div');
                viewport.id = 'viewport';
                viewport.setAttribute('aria-hidden','true');
                stageWrap.appendChild(viewport);
              }
              if (!floor) {
                floor = document.createElement('canvas');
                floor.id = 'floor';
                viewport.appendChild(floor);
              }
              if (!overlay) {
                overlay = document.createElementNS('http://www.w3.org/2000/svg','svg');
                overlay.id = 'overlay';
                viewport.appendChild(overlay);
              }
              if (!labels) {
                labels = document.createElement('div');
                labels.id = 'labels';
                viewport.appendChild(labels);
              }
              if (!tip) {
                tip = document.createElement('div');
                tip.id = 'labelTip';
                tip.setAttribute('role','tooltip');
                tip.setAttribute('aria-hidden','true');
                tip.style.position = 'absolute';
                tip.style.font = '600 12px/1.2 system-ui, -apple-system, Segoe UI,Roboto,Inter,Arial,sans-serif';
                tip.style.padding = '6px 8px';
                tip.style.borderRadius = '6px';
                tip.style.pointerEvents = 'none';
                tip.style.background = 'rgba(0,0,0,.8)';
                tip.style.color = '#fff';
                tip.style.display = 'none';
                viewport.appendChild(tip);
              }
            }

            function worldToScreen(x, y) {
              const v = vehicle();
              const rect = stageWrap.getBoundingClientRect();
              const sx = (rect.width || 1) / Math.max(1, v.inner_cm.L);
              const sy = (rect.height || 1) / Math.max(1, v.inner_cm.W);
              // stageWrap and #viewport share the same origin (absolute inset:0)
              return { x: x * sx, y: y * sy, sx, sy };
            }

            function ensureObserver(){
              if (!ro) {
                try {
                  ro = new ResizeObserver((entries) => {
                    for (const entry of entries) {
                      const el = entry.target;
                      const id = el.getAttribute('data-id');
                      if (!id) continue;
                      labelSizeCache.delete(id);
                      // Re-pick position just for this item
                      const it = (state.items || []).find(x => String(x.id) === String(id));
                      if (it) {
                        try { pickPosition(it); } catch(_) {}
                      }
                    }
                  });
                } catch (_) {
                  ro = null;
                }
              }
            }

            function measureLabel(el){
              ensureDOM();
              if (!el) return { w: 0, h: 0 };
              const id = el.getAttribute('data-id') || '';
              const cached = labelSizeCache.get(id);
              if (cached) return cached;
              // Temporarily ensure visibility for measurement
              const prev = el.style.visibility;
              el.style.visibility = prev || '' ? prev : 'hidden';
              const r = el.getBoundingClientRect();
              const res = { w: Math.max(1, Math.round(r.width)), h: Math.max(1, Math.round(r.height)) };
              labelSizeCache.set(id, res);
              try { ensureObserver(); ro && ro.observe(el); } catch(_){}
              if (!prev) el.style.visibility = '';
              return res;
            }

            function rectArea(a){ return Math.max(0, a.w) * Math.max(0, a.h); }
            function intersectArea(a,b){
              const x1 = Math.max(a.left, b.left);
              const y1 = Math.max(a.top, b.top);
              const x2 = Math.min(a.left + a.w, b.left + b.w);
              const y2 = Math.min(a.top + a.h, b.top + b.h);
              const w = x2 - x1; const h = y2 - y1;
              return (w > 0 && h > 0) ? (w * h) : 0;
            }

            function getOtherBoxesRects(excludeId){
              const v = vehicle();
              const scale = worldToScreen(0,0);
              const out = [];
              for (const it of (state.items || [])){
                if (!it || String(it.id) === String(excludeId)) continue;
                if (it.overflow) continue; // only inside cargo area for scoring
                const { l, w } = dims2D(it);
                const left = it.x * scale.sx;
                const top  = it.y * scale.sy;
                out.push({ left, top, w: Math.max(1, l * scale.sx), h: Math.max(1, w * scale.sy) });
              }
              return out;
            }

            function getPlacedLabelRects(excludeId){
              const out = [];
              for (const [id, r] of placed.entries()){
                if (String(id) === String(excludeId)) continue;
                out.push({ left: r.left, top: r.top, w: r.w, h: r.h });
              }
              return out;
            }

            // Pick best label anchor/rect (inside or outside) with scoring for overlaps and viewport overflow
            function pickLabelAnchor(item){
              ensureDOM();
              const { w, h } = measureLabel(buildLabel(item));
              const scale = worldToScreen(0,0);
              const d = dims2D(item);
              // Overflow items: place in top-left fallback to avoid offscreen
              if (item.overflow) {
                return { anchor: 'nw', rect: { left: 4, top: 4, w, h }, leader: null };
              }
              const left = (item.x||0) * scale.sx;
              const top  = (item.y||0) * scale.sy;
              const bw = Math.max(1, (d.l||0) * scale.sx);
              const bh = Math.max(1, (d.w||0) * scale.sy);
              const cx = left + bw/2, cy = top + bh/2;
              const pad = 2;
              const otherLabels = getPlacedLabelRects(item.id);
              const otherBoxes  = getOtherBoxesRects(item.id);
              const stage = stageWrap.getBoundingClientRect();
              const stageRect = { left: 0, top: 0, w: Math.max(1, stage.width|0), h: Math.max(1, stage.height|0) };
              function offscreenArea(r){
                const x1 = Math.max(stageRect.left, r.left);
                const y1 = Math.max(stageRect.top,  r.top);
                const x2 = Math.min(stageRect.left + stageRect.w, r.left + r.w);
                const y2 = Math.min(stageRect.top  + stageRect.h, r.top  + r.h);
                const interW = Math.max(0, x2 - x1), interH = Math.max(0, y2 - y1);
                const interA = interW * interH;
                const a = Math.max(0, r.w) * Math.max(0, r.h);
                return Math.max(0, a - interA);
              }
              // Build candidates
              const isPrint = document.documentElement.classList.contains('print');
              const mode = isPrint ? 'outside' : ((item.label && item.label.mode) || 'auto');
              const inside = [
                { a: 'center', x: left + (bw - w)/2, y: top + (bh - h)/2 },
                { a: 'nw',     x: left + pad,           y: top + pad },
                { a: 'ne',     x: left + bw - w - pad, y: top + pad },
                { a: 'sw',     x: left + pad,           y: top + bh - h - pad },
                { a: 'se',     x: left + bw - w - pad, y: top + bh - h - pad },
              ];
              const outPad = Math.max(6, pad + 4);
              const outside = [
                { a: 'e-out',  x: left + bw + outPad, y: cy - h/2, leader: { x1: Math.round(left + bw), y1: Math.round(cy), lx: 'left', side:'e' } },
                { a: 'w-out',  x: left - w - outPad,  y: cy - h/2, leader: { x1: Math.round(left),     y1: Math.round(cy), lx: 'right', side:'w' } },
              ];
              // Clamp outside Y into stage vertically
              outside.forEach(r => { r.y = Math.max(2, Math.min(stageRect.h - h - 2, r.y)); });
              let candidates = inside.concat(outside);
              if (mode === 'inside') candidates = inside;
              else if (mode === 'outside') candidates = outside;
              let best = { score: Infinity, anchor: 'center', rect: null, leader: null };
              for (const c of candidates){
                const rect = { left: Math.round(c.x), top: Math.round(c.y), w, h };
                // penalties
                let overlapL = 0; for (const r of otherLabels) overlapL += intersectArea(rect, r);
                let overlapB = 0; for (const r of otherBoxes)  overlapB += intersectArea(rect, r);
                const lcx = rect.left + rect.w/2, lcy = rect.top + rect.h/2;
                const dist2 = (lcx - cx)*(lcx - cx) + (lcy - cy)*(lcy - cy);
                const offA = offscreenArea(rect);
                // weights: labels >> boxes >> offscreen >> distance
                const score = overlapL * 12 + overlapB * 3 + offA * 20 + dist2 * 0.02 + (c.a.endsWith('-out') ? 6 : 0);
                if (score < best.score) {
                  let leader = null;
                  if (c.a === 'e-out') {
                    leader = { x1: Math.round(left + bw), y1: Math.round(cy), x2: Math.round(rect.left), y2: Math.round(rect.top + rect.h/2) };
                  } else if (c.a === 'w-out') {
                    leader = { x1: Math.round(left), y1: Math.round(cy), x2: Math.round(rect.left + rect.w), y2: Math.round(rect.top + rect.h/2) };
                  }
                  best = { score, anchor: c.a, rect, leader };
                }
              }
              return best;
            }

            function pickPosition(item){
              ensureDOM();
              const el = buildLabel(item);
              const res = pickLabelAnchor(item);
              // Apply placement
              el.style.left = res.rect.left + 'px';
              el.style.top  = res.rect.top  + 'px';
              placed.set(String(item.id), res.rect);
              try { item.label = item.label || {}; item.label.anchor = res.anchor; } catch(_) {}
              if (res.leader) {
                try {
                  const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
                  ln.setAttribute('x1', res.leader.x1); ln.setAttribute('y1', res.leader.y1);
                  ln.setAttribute('x2', res.leader.x2); ln.setAttribute('y2', res.leader.y2);
                  ln.setAttribute('class','leaderline');
                  overlay.appendChild(ln);
                } catch(_) {}
              }
              return res.anchor;
            }

          function buildLabel(item) {
            ensureDOM();
            const id = String(item.id);
            let el = labels.querySelector(`.label[data-id="${CSS.escape(id)}"]`);
            if (!el) {
              el = document.createElement('div');
              el.className = 'label';
              el.dataset.id = id;
              labels.appendChild(el);
            }
            // Dimensions D×S×W: D/S from 2D oriented dims; W from height
            const d2 = dims2D(item);
            const D = d2.l ?? item.L ?? item.h ?? '—';
            const S = d2.w ?? item.W ?? item.w ?? '—';
            const W = item.H ?? item.height ?? '—';
            const kg = Math.max(0, item.weight || 0);
            const typ = item.type || '—';
            // Reset content and (re)build text + icons
            el.innerHTML = '';
            const body = document.createElement('span');
            body.className = 'body';
            body.setAttribute('tabindex', '0');
            body.setAttribute('aria-label', `${D}×${S}×${W}, ${kg} kg, ${typ}`);
            const top = document.createElement('span');
            top.className = 'lineA';
            top.textContent = `${D}×${S}×${W}`;
            const bot = document.createElement('span');
            bot.className = 'lineB';
            bot.textContent = `${kg} kg • ${typ}`;
            body.appendChild(top);
            body.appendChild(bot);
            el.appendChild(body);
            // Clear old icons, then append active ones
            el.querySelectorAll('svg.ico').forEach(n => n.remove());
            const flags = item.flags || {};
            function addIco(id){
              const sv = document.createElementNS('http://www.w3.org/2000/svg','svg');
              sv.setAttribute('class','ico');
              const use = document.createElementNS('http://www.w3.org/2000/svg','use');
              use.setAttribute('href', `#${id}`);
              sv.appendChild(use);
              el.appendChild(sv);
            }
            if (flags.noStack === true) addIco('i-nostack');
            if (flags.fragile === true) addIco('i-fragile');
            // Contrast vs the item background color
            try { applyLabelContrast(el, getItemColor(item)); } catch (_) {}
            // Hover/focus tooltip wiring (once per element)
            if (!body.dataset.tipwired) {
              const show = () => { try { openTooltip(id); } catch(_) {} };
              const hide = () => { try { closeTooltip(id); } catch(_) {} };
              body.addEventListener('mouseenter', show);
              body.addEventListener('mouseleave', hide);
              body.addEventListener('focus', show);
              body.addEventListener('blur', hide);
              body.dataset.tipwired = '1';
            }
            return el;
          }

            function layoutLabels() {
              ensureDOM();
              placed.clear();
              if (overlay) { try { overlay.innerHTML = ''; } catch(_){} }
              const ids = new Set();
              const items = (state.items || []).slice().filter(Boolean);
              // Larger boxes first
              items.sort((a,b) => {
                const da = dims2D(a), db = dims2D(b);
                return (db.l*db.w) - (da.l*da.w);
              });
              for (const it of items){
                ids.add(String(it.id));
                pickPosition(it);
              }
              // Remove labels for items that no longer exist
              Array.from(labels.querySelectorAll('.label')).forEach((n) => {
                if (!ids.has(n.getAttribute('data-id') || '')) n.remove();
              });
              // Highlight according to selection
              try { highlightSelected(); } catch(_) {}
            }

            function highlightSelected(){
              const sel = String(state.selectedId || '');
              Array.from(labels.querySelectorAll('.label')).forEach(el => {
                const id = el.getAttribute('data-id') || '';
                const isSel = id === sel;
                const isHot = id === (hotId || '');
                el.classList.toggle('is-selected', !!isSel);
                el.classList.toggle('is-hot', !!(isSel || isHot));
              });
            }

            function setHotId(id){
              hotId = String(id || '');
              // Toggle classes according to current hover and selection
              try { highlightSelected(); } catch(_) {}
            }

            function updateAll() {
              ensureDOM();
              try { layoutLabels(); } catch(_) {}
              viewport.style.display = 'block';
              viewport.setAttribute('aria-hidden', 'false');
              try { highlightSelected(); } catch(_) {}
              // Reapply hover state after relayout
              try { setHotId(hotId); } catch(_) {}
            }

            // Accessible tooltip API for tests and optional UI hooks
            function openTooltip(id){
              ensureDOM();
              const el = labels.querySelector(`.label[data-id="${CSS.escape(String(id))}"]`);
              if (!el) return false;
              const body = el.querySelector('.body');
              // Build richer content for tooltip: dims + weight + type + flags
              const it = (state.items || []).find(x => String(x.id) === String(id));
              let text = '';
              if (it) {
                const d2 = dims2D(it);
                const dims = `${d2.l ?? it.L ?? '—'}×${d2.w ?? it.W ?? '—'}×${it.H ?? '—'} cm`;
                const kg = `${Math.max(0, it.weight||0)} kg`;
                const typ = it.type || '—';
                const flags = it.flags || {};
                const icons = [ flags.noStack ? '⛔' : '', flags.fragile ? '🍷' : '' ].filter(Boolean).join(' ');
                text = `<div style="font-weight:700;margin-bottom:4px">${dims}</div>`+
                       `<div style="opacity:.95">${kg} • ${typ} ${icons?`<span style='margin-left:6px'>${icons}</span>`:''}</div>`;
              } else {
                text = body ? (body.textContent || '') : '';
              }
              el.setAttribute('aria-describedby','labelTip');
              tip.innerHTML = text;
              // position tooltip centered above the label
              const r = el.getBoundingClientRect();
              const vp = viewport.getBoundingClientRect();
              const x = Math.round(r.left - vp.left + r.width/2 - Math.min(240, Math.max(80, r.width)) / 2);
              const y = Math.max(2, Math.round(r.top - vp.top - 8 - 20));
              tip.style.left = x + 'px';
              tip.style.top  = y + 'px';
              tip.style.display = 'block';
              tip.setAttribute('aria-hidden','false');
              return true;
            }
            function closeTooltip(id){
              ensureDOM();
              const el = labels.querySelector(`.label[data-id="${CSS.escape(String(id))}"]`);
              if (el) el.removeAttribute('aria-describedby');
              if (tip){ tip.style.display = 'none'; tip.setAttribute('aria-hidden','true'); }
              return true;
            }

            // test helpers
            function test_applyContrast_on(color){
              const el = document.createElement('div');
              applyContrast(el, color);
              return { color: el.style.color, bg: el.style.background };
            }

            // public API
            return { buildLabel, layoutLabels, updateAll, worldToScreen, measureLabel, pickPosition, pickLabelAnchor, highlightSelected, openTooltip, closeTooltip, test_applyContrast_on, setHotId };
          })();

          // Expose globally for debugging if needed
          window.overlayLabels = overlayLabels;
          // Keep label highlight in sync with selection changes
          try { mount.addEventListener('selectionchange', () => { try { overlayLabels.highlightSelected(); } catch (_) {} try { threeUpdateGizmo(); } catch(_) {} }); } catch (_) {}
          window.addEventListener('resize', () => {
            try { overlayLabels.updateAll(); } catch (_) {}
            try { resizeVehSelectToContent(); } catch(_) {}
            try { fitCanvasToVehicleWidth(false); } catch(_) {}
          });
          function within(it, veh) {
            const { l, w } = dims2D(it);
            return (
              it.x >= 0 &&
              it.y >= 0 &&
              it.x + l <= veh.inner_cm.L &&
              it.y + w <= veh.inner_cm.W
            );
          }
          function overlap(a, b) {
            const A = dims2D(a),
              B = dims2D(b);
            return (
              a.x < b.x + B.l &&
              a.x + A.l > b.x &&
              a.y < b.y + B.w &&
              a.y + A.w > b.y
            );
          }
          function anyCollision(it, exceptId) {
            return state.items.some((x) => x.id !== exceptId && overlap(it, x));
          }
          function snap(v) {
            const g = vehicle().grid_cm;
            return Math.round(v / g) * g;
          }
          function meters(cm) {
            return cm / 100;
          }
          function ldmOf(it, veh) {
            const { l, w } = dims2D(it);
            return (
              meters(l) * (meters(w) / meters(veh.inner_cm.W)) * it.stackCount
            );
          }

          // Generate a distinct color for each item based on its position in the list and stack count.
          // This helps visually differentiate different cargo pieces and hints at stacking (lighter colors for higher stacks).
          function getItemColor(it) {
            // Stable color based on dimensions only (same D/S/W -> same color)
            const L = Math.max(it.L, it.W) | 0;
            const W = Math.min(it.L, it.W) | 0;
            const H = (it.H | 0) || 0;
            const key = `${L}x${W}x${H}`;
            let hash = 0;
            for (let i = 0; i < key.length; i++) {
              hash = (hash * 131 + key.charCodeAt(i)) % 360;
            }
            const hue = (hash + 360) % 360;
            const sat = 62;
            const light = mount.getAttribute("data-theme") === "dark" ? 40 : 45;
            return `hsl(${hue}, ${sat}%, ${light}%)`;
          }

          function pushHistory() {
            state.history.push(
              deepClone({
                items: state.items,
                vehicleIndex: state.vehicleIndex,
              })
            );
            if (state.history.length > 50) state.history.shift();
            state.future.length = 0;
          }
          function undo() {
            const last = state.history.pop();
            if (!last) return;
            state.future.push(
              deepClone({
                items: state.items,
                vehicleIndex: state.vehicleIndex,
              })
            );
            state.items = deepClone(last.items);
            state.vehicleIndex = last.vehicleIndex;
            state.selectedId = null;
            renderAll();
          }
          function redo() {
            const next = state.future.pop();
            if (!next) return;
            pushHistory();
            state.items = deepClone(next.items);
            state.vehicleIndex = next.vehicleIndex;
            state.selectedId = null;
            renderAll();
          }

          function saveLocal() {
            localStorage.setItem(
              "vanpack_state",
              JSON.stringify({
                v: state.vehicleIndex,
                items: state.items,
                lang,
              })
            );
            alert(t('saved_to_browser'));
          }
          function loadLocal() {
            try {
              const s = JSON.parse(localStorage.getItem("vanpack_state"));
              if (s) {
                state.vehicleIndex = s.v || 0;
                state.items = s.items || [];
                lang = s.lang || lang;
                // Theme follows system preference; ignore saved theme
              }
            } catch {}
          }
          function shareLink() {
            const data = btoa(
              unescape(
                encodeURIComponent(
                  JSON.stringify({
                    v: state.vehicleIndex,
                    items: state.items,
                    lang,
                    theme: mount.getAttribute("data-theme"),
                  })
                )
              )
            );
            const url = location.origin + location.pathname + "#vp=" + data;
            navigator.clipboard?.writeText(url);
            alert(t('link_copied'));
          }
          function loadFromHash() {
            const m = location.hash.match(/#vp=([^&]+)/);
            if (!m) return false;
            try {
              const obj = JSON.parse(decodeURIComponent(escape(atob(m[1]))));
              state.vehicleIndex = obj.v || 0;
              state.items = obj.items || [];
              lang = obj.lang || lang;
              // Theme follows system preference; ignore saved theme
              return true;
            } catch {
              return false;
            }
          }
          function toSvgPoint(evt) {
            const pt = board.createSVGPoint();
            pt.x = evt.clientX;
            pt.y = evt.clientY;
            const sp = pt.matrixTransform(board.getScreenCTM().inverse());
            return { x: sp.x, y: sp.y };
          }
          function showError(msg) {
            errBox.textContent = msg;
            errBox.setAttribute("aria-hidden", "false");
            setTimeout(() => errBox.setAttribute("aria-hidden", "true"), 4000);
          }

          // ===================== VEHICLE UI =====================
              // Localize Polish vehicle names to current language for display
              function localizeVehName(name){
                let s = String(name||'');
                const L = lang;
                const rep = (re, out)=> s = s.replace(re, out);
                switch (L) {
                  case 'en':
                    rep(/\bChłodnia\b/g,'Refrigerated trailer');
                    rep(/^Bus\b/,'Van');
                    rep(/\bSolówka\b/g,'Rigid truck');
                    rep(/^Naczepa 13,6/g,'Semi-trailer 13,6');
                    rep(/\bTIR\b/g,'Curtainsider / box trailer');
                    rep(/^Mega\b/g,'Mega trailer');
                    break;
                  case 'de':
                    rep(/\bChłodnia\b/g,'Kühlauflieger');
                    rep(/^Bus\b/,'Transporter');
                    rep(/\bSolówka\b/g,'Solofahrzeug');
                    rep(/^Naczepa 13,6/g,'Sattelauflieger 13,6');
                    rep(/\bTIR\b/g,'Planen-/Kofferauflieger');
                    rep(/^Mega\b/g,'Mega-Trailer');
                    break;
                  case 'fr':
                    rep(/\bChłodnia\b/g,'Semi-remorque frigorifique');
                    rep(/^Bus\b/,'Fourgon');
                    rep(/\bSolówka\b/g,'Porteur');
                    rep(/^Naczepa 13,6/g,'Semi-remorque 13,6');
                    rep(/\bTIR\b/g,'Rideaux coulissants / fourgon');
                    rep(/^Mega\b/g,'Remorque Mega');
                    break;
                  case 'it':
                    rep(/\bChłodnia\b/g,'Semirimorchio frigo');
                    rep(/^Bus\b/,'Furgone');
                    rep(/\bSolówka\b/g,'Motrice (rigido)');
                    rep(/^Naczepa 13,6/g,'Semirimorchio 13,6 m');
                    rep(/\bTIR\b/g,'Tautliner / box');
                    rep(/^Mega\b/g,'Trailer Mega');
                    break;
                  case 'ru':
                    rep(/\bChłodnia\b/g,'Рефрижераторный');
                    rep(/^Bus\b/,'Бус');
                    rep(/\bSolówka\b/g,'Соло-грузовик');
                    rep(/^Naczepa 13,6/g,'Полуприцеп 13,6');
                    rep(/\bTIR\b/g,'Шторный / фургон');
                    rep(/^Mega\b/g,'Мега-прицеп');
                    break;
                  case 'uk':
                    rep(/\bChłodnia\b/g,'Рефрижераторний');
                    rep(/^Bus\b/,'Бус');
                    rep(/\bSolówka\b/g,'Соло-вантажівка');
                    rep(/^Naczepa 13,6/g,'Напівпричіп 13,6');
                    rep(/\bTIR\b/g,'Шторний / фургон');
                    rep(/^Mega\b/g,'Мега-причіп');
                    break;
                  default: break;
                }
                return s;
              }
              function renderVehSelect() {
            const groups = [ ...new Set(VEHICLES.map((v) => v.group || "Pojazd")) ];
            vehSel.innerHTML = "";
              groups.forEach((g) => {
                const og = document.createElement("optgroup");
                // Reuse group label translator from dropdown builder if available
              try { og.label = (function(g){
                const lo = String(g||'').toLowerCase();
                if (lo.includes('bus')) return t('vehicle_cat_bus35');
                if (lo.includes('solów') || lo.includes('solow')) return t('vehicle_cat_rigid');
                if (lo.includes('13,6')) return t('vehicle_cat_trailer_136');
                if (lo.includes('firanka') || lo.includes('sztywka') || lo.includes('box')) return t('vehicle_cat_tautliner_box');
                if (lo.includes('mega')) return t('vehicle_cat_mega');
                if (lo.includes('chłod') || lo.includes('chlod')) return t('vehicle_cat_reefer');
                return g;
              })(g); } catch(_) { og.label = g; }
              VEHICLES.filter((v) => (v.group || "Pojazd") === g).forEach(
                (v) => {
                  const opt = document.createElement("option");
                  opt.value = String(VEHICLES.indexOf(v));
                  const name = localizeVehName(v.name_pl);
                  const ep = v.europallets ? `${v.europallets} ${t('eur_pallets') || 'EP'}` : '';
                  opt.textContent = name + (ep ? ` • ${ep}` : "");
                  og.appendChild(opt);
                }
              );
                vehSel.appendChild(og);
              });
            vehSel.value = String(state.vehicleIndex);
              vehSel.onchange = () => {
                if (
                  state.items.length &&
                  !confirm(t('confirm_change_vehicle'))
                ) {
                  vehSel.value = String(state.vehicleIndex);
                  return;
                }
                pushHistory();
                state.vehicleIndex = +vehSel.value;
                state.items = [];
                state.selectedId = null;
                state.variants = { plans: [], index: 0 };
                renderAll();
                // Reset view fit for new vehicle
                VIEW_TOUCHED = false;
                try { fitCanvasToVehicleWidth(true); } catch(_) {}
              };
            // Dopasuj szerokość selecta do treści
            try { resizeVehSelectToContent(); } catch(_) {}

            // Mega‑menu (dropdown) pod wierszem "Pojazd"
            try {
              const dd = mount.querySelector('#vehDD');
              function groupEmoji(g){
                g = String(g||'').toLowerCase();
                if (g.includes('bus')) return '🚌';
                if (g.includes('solów') || g.includes('solow')) return '🚚';
                if (g.includes('chłod') || g.includes('chlod')) return '❄️🚛';
                return '🚛';
              }
              function vehGroupLabel(g){
                const lo = String(g||'').toLowerCase();
                if (lo.includes('bus')) return t('vehicle_cat_bus35');
                if (lo.includes('solów') || lo.includes('solow')) return t('vehicle_cat_rigid');
                if (lo.includes('13,6')) return t('vehicle_cat_trailer_136');
                if (lo.includes('firanka') || lo.includes('sztywka') || lo.includes('box')) return t('vehicle_cat_tautliner_box');
                if (lo.includes('mega')) return t('vehicle_cat_mega');
                if (lo.includes('chłod') || lo.includes('chlod')) return t('vehicle_cat_reefer');
                return g;
              }
              function buildPickerHTML(){
                const byGroup = new Map();
                for (const v of VEHICLES){
                  const g = v.group || 'Pojazd';
                  if (!byGroup.has(g)) byGroup.set(g, []);
                  byGroup.get(g).push(v);
                }
                const cols = [];
                for (const [g, list] of byGroup.entries()){
                  const items = list.map(v => {
                    const idx = VEHICLES.indexOf(v);
                    const ep = v.europallets ? `${v.europallets} ${t('eur_pallets') || 'EP'}` : '';
                    const nm = localizeVehName(v.name_pl);
                    return `<div class=\"veh-opt\" data-vi=\"${idx}\"><span>${nm}</span><small>${ep}</small></div>`;
                  }).join('');
                  cols.push(`<div class="veh-col"><h5>${groupEmoji(g)} ${vehGroupLabel(g)}</h5>${items}</div>`);
              }
                return `<div class="veh-picker">${cols.join('')}</div>`;
              }
              function openVehDD(){
                if (!dd) return; dd.innerHTML = buildPickerHTML();
                const row = mount.querySelector('#vehRow');
                const wrap = mount.querySelector('.vp-wrap');
                if (!row || !wrap) return;
                const r = row.getBoundingClientRect();
                const w = wrap.getBoundingClientRect();
                dd.style.left = (r.left - w.left) + 'px';
                dd.style.top = (r.bottom - w.top + 6) + 'px';
                dd.style.minWidth = Math.max(360, r.width) + 'px';
                dd.style.display = 'block'; dd.hidden = false;
                dd.querySelectorAll('.veh-opt').forEach(el => {
                  el.addEventListener('click', () => {
                    const idx = +el.getAttribute('data-vi');
                    if (state.items.length && !confirm(t('confirm_change_vehicle'))) return;
                    pushHistory(); state.vehicleIndex = idx; state.items = []; state.selectedId = null; state.variants = { plans: [], index: 0 }; renderAll(); closeVehDD();
                  });
                });
                setTimeout(()=>{
                  const onDoc = (e)=>{ if (!dd.contains(e.target) && !row.contains(e.target)) { closeVehDD(); document.removeEventListener('pointerdown', onDoc); } };
                  document.addEventListener('pointerdown', onDoc);
                },0);
              }
              function closeVehDD(){ if (!dd) return; dd.style.display='none'; dd.hidden = true; }
              const vehLabel = mount.querySelector('label[for="vehSel"]');
              // Wyłącz natywne menu i otwieraj nasze (klik, wciśnięcie)
              ['click','mousedown','pointerdown'].forEach(type=> vehSel.addEventListener(type, (e)=>{ e.preventDefault(); openVehDD(); }));
              vehLabel?.addEventListener('click', (e)=>{ e.preventDefault(); openVehDD(); });
              // Otwórz/Zamknij na hoverze tylko wokół selecta (nie cały wiersz)
              let hoverTimer = null;
              const scheduleClose = ()=>{ clearTimeout(hoverTimer); hoverTimer = setTimeout(()=>{ closeVehDD(); }, 180); };
              const cancelClose = ()=>{ clearTimeout(hoverTimer); };
              vehSel?.addEventListener('mouseenter', ()=>{ cancelClose(); openVehDD(); });
              vehSel?.addEventListener('mouseleave', ()=>{ scheduleClose(); });
              dd?.addEventListener('mouseenter', ()=> cancelClose());
              dd?.addEventListener('mouseleave', ()=> scheduleClose());
            } catch(_) {}
          }

          // Autosizer dla selecta "Pojazd" – dopasowuje szerokość do wybranego tekstu
          function resizeVehSelectToContent(){
            const s = vehSel; if (!s) return;
            const opt = s.options[s.selectedIndex];
            const text = (opt && opt.textContent) ? opt.textContent : '';
            const meas = document.createElement('span');
            meas.style.position = 'absolute';
            meas.style.visibility = 'hidden';
            meas.style.whiteSpace = 'pre';
            const st = getComputedStyle(s);
            meas.style.font = `${st.fontWeight} ${st.fontSize} / ${st.lineHeight} ${st.fontFamily}`;
            meas.textContent = ' ' + text + ' ';
            mount.appendChild(meas);
            const w = Math.ceil(meas.getBoundingClientRect().width + 38); // padding + strzałka
            meas.remove();
            s.style.width = Math.min(Math.max(160, w), Math.round(window.innerWidth*0.7)) + 'px';
          }

          function createVehicleWith(L,W,H,Kg,EP,Grid){
            const id = "custom_" + Date.now();
            const name = `Custom ${L / 100}×${W / 100}×${H / 100} m`;
            Store.mutate("createVehicle", (s) => {
              VEHICLES.push({ id, group: "Custom", name_pl: name, inner_cm: { L, W, H }, payload_kg: Kg, europallets: EP, grid_cm: Grid });
              s.vehicleIndex = VEHICLES.length - 1; s.items = []; s.selectedId = null; s.variants = { plans: [], index: 0 };
            });
          }

          // Inline create button was removed; creation is handled via custom vehicle dialog.

          function renderSpecs() {
            const v = vehicle();
            const capVol =
              (v.inner_cm.L * v.inner_cm.W * v.inner_cm.H) / 1_000_000;
            specsDims.textContent = `${t("dims_label")}: ${v.inner_cm.L}×${
              v.inner_cm.W
            }×${v.inner_cm.H} cm`;
            specsPayload.textContent = `${t("payload")}: ${v.payload_kg} kg`;
            specsPallets.textContent = `${t("pallets")}: ${v.europallets}`;
            specsLDM.textContent = `${t("ldm")}: ~${(
              v.inner_cm.L / 100
            ).toFixed(1)} (max) • ${capVol.toFixed(1)} m³`;
          }

          // ===================== PRESETS =====================
          function renderPresets() {
            presetList.innerHTML = "";
            PRESETS.forEach((p) => {
              const row = document.createElement("div");
              row.className = "preset";
              const left = document.createElement("div");
              const title = p.id === 'Pal_Przemyslowa' ? (I18N[lang]?.industrial_pallet || p.label) : p.label;
              left.innerHTML = `<div style=\"font-weight:600\">${title}</div><small>${p.dims.L}×${p.dims.W}×${p.dims.H} • ${p.weight} kg</small>`;
            const right = document.createElement("div");
            right.className = "qty";
            right.innerHTML = `<label>${t('qty')}</label><input type="number" min="1" value="1"> <button class=\"btn secondary\">${t('add')}</button>`;
              right.querySelector("button").addEventListener("click", () => {
                const n = Math.max(1, +right.querySelector("input").value || 1);
                pushHistory();
                for (let i = 0; i < n; i++) {
                  addItemFromPreset(p, { autoPlace: true });
                }
                // Auto‑pack automatically when adding multiple items
                if (n > 1) {
                  autopackUltra(0, true);
                } else {
                  renderAll();
                }
              });
              row.appendChild(left);
              row.appendChild(right);
              presetList.appendChild(row);
            });
          }

          // ===================== SVG =====================
          function buildSVG() {
            const v = vehicle();
            // Extend viewBox to the right if we have overflow items to visualize outside cargo area
            const ovItems = (state.items || []).filter((it) => it && it.overflow);
            let pad = 0;
            if (ovItems.length) {
              // approximate needed columns based on total height
              const totalH = ovItems.reduce((s, it) => {
                const d = dims2D(it);
                return s + (d.w || 0) + 5;
              }, 0);
              const cols = Math.max(1, Math.ceil(totalH / Math.max(1, v.inner_cm.W)));
              const maxL = ovItems.reduce((m, it) => Math.max(m, dims2D(it).l || 0), 0);
              pad = cols * (maxL + 10) + 10; // some spacing
            }
            board.setAttribute("viewBox", `0 0 ${v.inner_cm.L + pad} ${v.inner_cm.W}`);
            board.innerHTML = "";
            hudLayer.innerHTML = "";
            // Global symbols/defs (icons etc.)
            const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
            // No‑stack icon: two boxes + strike-through
            const symNoStack = document.createElementNS('http://www.w3.org/2000/svg','symbol');
            symNoStack.setAttribute('id','i-nostack');
            symNoStack.setAttribute('viewBox','0 0 24 24');
            const nsR1 = document.createElementNS('http://www.w3.org/2000/svg','rect');
            nsR1.setAttribute('x','3'); nsR1.setAttribute('y','13'); nsR1.setAttribute('width','8'); nsR1.setAttribute('height','6'); nsR1.setAttribute('rx','1.2');
            const nsR2 = document.createElementNS('http://www.w3.org/2000/svg','rect');
            nsR2.setAttribute('x','13'); nsR2.setAttribute('y','5'); nsR2.setAttribute('width','8'); nsR2.setAttribute('height','6'); nsR2.setAttribute('rx','1.2');
            const nsSlash = document.createElementNS('http://www.w3.org/2000/svg','path');
            nsSlash.setAttribute('d','M4 20 L20 4'); nsSlash.setAttribute('fill','none'); nsSlash.setAttribute('stroke','currentColor'); nsSlash.setAttribute('stroke-width','2'); nsSlash.setAttribute('stroke-linecap','round');
            symNoStack.appendChild(nsR1); symNoStack.appendChild(nsR2); symNoStack.appendChild(nsSlash);
            defs.appendChild(symNoStack);
            // Fragile icon: wine glass + crack
            const symFragile = document.createElementNS('http://www.w3.org/2000/svg','symbol');
            symFragile.setAttribute('id','i-fragile');
            symFragile.setAttribute('viewBox','0 0 24 24');
            const frBowl = document.createElementNS('http://www.w3.org/2000/svg','path');
            frBowl.setAttribute('d','M6 3h12v4a6 6 0 0 1-6 6a6 6 0 0 1-6-6V3z');
            const frStem = document.createElementNS('http://www.w3.org/2000/svg','path');
            frStem.setAttribute('d','M12 13v5'); frStem.setAttribute('fill','none'); frStem.setAttribute('stroke','currentColor'); frStem.setAttribute('stroke-width','2'); frStem.setAttribute('stroke-linecap','round');
            const frBase = document.createElementNS('http://www.w3.org/2000/svg','rect');
            frBase.setAttribute('x','8'); frBase.setAttribute('y','20'); frBase.setAttribute('width','8'); frBase.setAttribute('height','2'); frBase.setAttribute('rx','1');
            const frCrack = document.createElementNS('http://www.w3.org/2000/svg','path');
            frCrack.setAttribute('d','M12 3l1.5 3l-2 2l2 1.5'); frCrack.setAttribute('fill','none'); frCrack.setAttribute('stroke','currentColor'); frCrack.setAttribute('stroke-width','1.8'); frCrack.setAttribute('stroke-linecap','round'); frCrack.setAttribute('stroke-linejoin','round');
            symFragile.appendChild(frBowl); symFragile.appendChild(frStem); symFragile.appendChild(frBase); symFragile.appendChild(frCrack);
            defs.appendChild(symFragile);
            board.appendChild(defs);
            const gGrid = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "g"
            );
            const step = v.grid_cm;
            for (let x = 0; x <= v.inner_cm.L; x += step) {
              const line = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line"
              );
              line.setAttribute("x1", x);
              line.setAttribute("y1", 0);
              line.setAttribute("x2", x);
              line.setAttribute("y2", v.inner_cm.W);
              line.setAttribute("class", "gridline");
              gGrid.appendChild(line);
            }
            for (let y = 0; y <= v.inner_cm.W; y += step) {
              const line = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line"
              );
              line.setAttribute("x1", 0);
              line.setAttribute("y1", y);
              line.setAttribute("x2", v.inner_cm.L);
              line.setAttribute("y2", y);
              line.setAttribute("class", "gridline");
              gGrid.appendChild(line);
            }
            board.appendChild(gGrid);
            const hull = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "rect"
            );
            hull.setAttribute("x", 0);
            hull.setAttribute("y", 0);
            hull.setAttribute("width", v.inner_cm.L);
            hull.setAttribute("height", v.inner_cm.W);
            hull.setAttribute("rx", 3);
            hull.setAttribute("class", "hull");
            board.appendChild(hull);
            // (wyłączono wewnętrzną linijkę — używamy zewnętrznej w overlay)
            // Section plane marker at middle of length
            const secx = v.inner_cm.L / 2;
            const sline = document.createElementNS("http://www.w3.org/2000/svg", "line");
            sline.setAttribute("x1", secx);
            sline.setAttribute("y1", 0);
            sline.setAttribute("x2", secx);
            sline.setAttribute("y2", v.inner_cm.W);
            sline.setAttribute("class", "sectionline");
            board.appendChild(sline);
            const gItems = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "g"
            );
            gItems.setAttribute("id", "gItems");
            board.appendChild(gItems);
          }

          // ===================== SIDE CUT RENDER (W×H at middle length) =====================
          function renderSection() {
            if (!section) return;
            const v = vehicle();
            const Xc = v.inner_cm.L / 2;
            if (secLabel) secLabel.textContent = `${t('section')} D=${Math.round(Xc)} cm`;
            section.setAttribute("viewBox", `0 0 ${v.inner_cm.W} ${v.inner_cm.H}`);
            section.innerHTML = "";

            // grid
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            const step = Math.max(10, v.grid_cm);
            for (let x = 0; x <= v.inner_cm.W; x += step) {
              const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
              ln.setAttribute("x1", x);
              ln.setAttribute("y1", 0);
              ln.setAttribute("x2", x);
              ln.setAttribute("y2", v.inner_cm.H);
              ln.setAttribute("class", "sec-gridline");
              g.appendChild(ln);
            }
            for (let y = 0; y <= v.inner_cm.H; y += step) {
              const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
              ln.setAttribute("x1", 0);
              ln.setAttribute("y1", y);
              ln.setAttribute("x2", v.inner_cm.W);
              ln.setAttribute("y2", y);
              ln.setAttribute("class", "sec-gridline");
              g.appendChild(ln);
            }
            section.appendChild(g);

            // hull box (0..W, 0..H)
            const hull2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            hull2.setAttribute("x", 0);
            hull2.setAttribute("y", 0);
            hull2.setAttribute("width", v.inner_cm.W);
            hull2.setAttribute("height", v.inner_cm.H);
            hull2.setAttribute("rx", 3);
            hull2.setAttribute("class", "hull");
            section.appendChild(hull2);

            // items that intersect plane Xc
            const items = (state.items || []).filter((it) => !it.overflow);
            for (const it of items) {
              const d = dims2D(it);
              const x1 = it.x;
              const x2 = it.x + d.l;
              if (!(Xc >= x1 && Xc <= x2)) continue;
              const widthSpan = d.w;
              const heightSpan = (it.H || 0) * (it.stackCount || 1);
              if (heightSpan <= 0) continue;
              const x = Math.max(0, it.y);
              const w = Math.min(widthSpan, v.inner_cm.W - x);
              const h = Math.min(heightSpan, v.inner_cm.H);
              const y = Math.max(0, v.inner_cm.H - h);

              const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
              r.setAttribute("x", x);
              r.setAttribute("y", y);
              r.setAttribute("width", w);
              r.setAttribute("height", h);
              r.setAttribute("rx", 1.5);
              r.setAttribute("data-id", it.id);
              const col = getItemColor(it);
              // darken stroke slightly
              let strokeCol = col;
              const m = /hsl\((\d+),\s*(\d+)%\,\s*(\d+)%\)/.exec(col);
              if (m) {
                const h0 = m[1], s0 = m[2];
                let lval = parseInt(m[3], 10) - 18;
                if (lval < 5) lval = 5;
                strokeCol = `hsl(${h0}, ${s0}%, ${lval}%)`;
              }
              r.style.fill = col;
              r.style.stroke = state.selectedId === it.id ? 'var(--accent)' : strokeCol;
              r.style.strokeWidth = state.selectedId === it.id ? '1.6' : '0.8';
              r.style.cursor = 'pointer';
              section.appendChild(r);
            }
          }

          // ===================== 3D RENDER (isometric preview) =====================
          function hslParts(hsl) {
            const m = /hsl\((\d+),\s*(\d+)%\,\s*(\d+)%\)/.exec(hsl);
            if (!m) return { h: 215, s: 60, l: 42 };
            return { h: +m[1], s: +m[2], l: +m[3] };
          }
          function hslAdjust(hsl, dl) {
            const p = hslParts(hsl);
            const l = Math.max(0, Math.min(100, p.l + dl));
            return `hsl(${p.h}, ${p.s}%, ${l}%)`;
          }
          function projectIso(x, y, z, scale, ox, oy) {
            const px = (x - y) * 0.8660254 * scale + ox;
            const py = ((x + y) * 0.5 - z) * scale + oy;
            return { x: px, y: py };
          }
          function compute3DScaleOrigin(v, cw, ch) {
            // Approximate extents for isometric projection
            const rangeX = 0.8660254 * (v.inner_cm.L + v.inner_cm.W);
            const rangeY = 0.5 * (v.inner_cm.L + v.inner_cm.W) + v.inner_cm.H;
            const scale = 0.9 * Math.min(cw / Math.max(1, rangeX), ch / Math.max(1, rangeY));
            const ox = cw * 0.5;
            const oy = ch * 0.6; // slightly lower to leave room for hull
            return { scale, ox, oy };
          }
          function render3D() {
            if (!board3d) return;
            const rect = board3d.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const cw = Math.max(200, rect.width | 0);
            const ch = Math.max(200, rect.height | 0);
            if (board3d.width !== (cw * dpr)) {
              board3d.width = cw * dpr;
              board3d.height = ch * dpr;
            }
            const ctx = board3d.getContext("2d");
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, cw, ch);

            const v = vehicle();
            const { scale, ox, oy } = compute3DScaleOrigin(v, cw, ch);

            // Grid (floor)
            const gridStep = Math.max(20, v.grid_cm * 2);
            ctx.lineWidth = 1;
            ctx.strokeStyle = mount.getAttribute("data-theme") === "dark" ? "#26334e" : "#e6ecfb";
            ctx.globalAlpha = 0.7;
            for (let x = 0; x <= v.inner_cm.L; x += gridStep) {
              const a = projectIso(x, 0, 0, scale, ox, oy);
              const b = projectIso(x, v.inner_cm.W, 0, scale, ox, oy);
              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(b.x, b.y);
              ctx.stroke();
            }
            for (let y = 0; y <= v.inner_cm.W; y += gridStep) {
              const a = projectIso(0, y, 0, scale, ox, oy);
              const b = projectIso(v.inner_cm.L, y, 0, scale, ox, oy);
              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(b.x, b.y);
              ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // Hull wireframe
            function line3(a, b, color, w = 1.4) {
              ctx.strokeStyle = color;
              ctx.lineWidth = w;
              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(b.x, b.y);
              ctx.stroke();
            }
            const hullPts = {
              A: projectIso(0, 0, 0, scale, ox, oy),
              B: projectIso(v.inner_cm.L, 0, 0, scale, ox, oy),
              C: projectIso(v.inner_cm.L, v.inner_cm.W, 0, scale, ox, oy),
              D: projectIso(0, v.inner_cm.W, 0, scale, ox, oy),
              Ap: projectIso(0, 0, v.inner_cm.H, scale, ox, oy),
              Bp: projectIso(v.inner_cm.L, 0, v.inner_cm.H, scale, ox, oy),
              Cp: projectIso(v.inner_cm.L, v.inner_cm.W, v.inner_cm.H, scale, ox, oy),
              Dp: projectIso(0, v.inner_cm.W, v.inner_cm.H, scale, ox, oy),
            };
            const hullLine = mount.getAttribute("data-theme") === "dark" ? "#3a4d77" : "#89a3ff";
            line3(hullPts.A, hullPts.B, hullLine);
            line3(hullPts.B, hullPts.C, hullLine);
            line3(hullPts.C, hullPts.D, hullLine);
            line3(hullPts.D, hullPts.A, hullLine);
            line3(hullPts.Ap, hullPts.Bp, hullLine);
            line3(hullPts.Bp, hullPts.Cp, hullLine);
            line3(hullPts.Cp, hullPts.Dp, hullLine);
            line3(hullPts.Dp, hullPts.Ap, hullLine);
            line3(hullPts.A, hullPts.Ap, hullLine, 1.2);
            line3(hullPts.B, hullPts.Bp, hullLine, 1.2);
            line3(hullPts.C, hullPts.Cp, hullLine, 1.2);
            line3(hullPts.D, hullPts.Dp, hullLine, 1.2);

            // Items as prisms
            const items = state.items.map((it) => ({ it, d: it.x + it.y + (it.H * it.stackCount) * 0.3 }));
            items.sort((a, b) => a.d - b.d); // back to front

            for (const { it } of items) {
              const { l, w } = dims2D(it);
              const h = it.H * (it.stackCount || 1);
              const base = [
                projectIso(it.x, it.y, 0, scale, ox, oy),
                projectIso(it.x + l, it.y, 0, scale, ox, oy),
                projectIso(it.x + l, it.y + w, 0, scale, ox, oy),
                projectIso(it.x, it.y + w, 0, scale, ox, oy),
              ];
              const top = [
                projectIso(it.x, it.y, h, scale, ox, oy),
                projectIso(it.x + l, it.y, h, scale, ox, oy),
                projectIso(it.x + l, it.y + w, h, scale, ox, oy),
                projectIso(it.x, it.y + w, h, scale, ox, oy),
              ];
              const baseCol = getItemColor(it);
              const sideCol = hslAdjust(baseCol, -10);
              const topCol = hslAdjust(baseCol, +8);

              // top face
              ctx.fillStyle = topCol;
              ctx.strokeStyle = hslAdjust(baseCol, -15);
              ctx.lineWidth = 1.2;
              ctx.beginPath();
              ctx.moveTo(top[0].x, top[0].y);
              for (let i = 1; i < 4; i++) ctx.lineTo(top[i].x, top[i].y);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();

              // side faces (right and left)
              function poly(points, fill, stroke) {
                ctx.fillStyle = fill;
                ctx.strokeStyle = stroke;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
              }
              poly([top[1], top[2], base[2], base[1]], sideCol, hslAdjust(baseCol, -20));
              poly([top[0], top[1], base[1], base[0]], hslAdjust(sideCol, -4), hslAdjust(baseCol, -20));

              // front edge accents
              ctx.strokeStyle = hslAdjust(baseCol, -25);
              ctx.lineWidth = 1.1;
              ctx.beginPath();
              ctx.moveTo(base[0].x, base[0].y);
              ctx.lineTo(base[1].x, base[1].y);
              ctx.moveTo(base[1].x, base[1].y);
              ctx.lineTo(base[2].x, base[2].y);
              ctx.stroke();

              // subtle grid on top face to hint stacking
              const step = Math.max(20, v.grid_cm * 2);
              ctx.strokeStyle = hslAdjust(topCol, -12);
              ctx.lineWidth = 0.8;
              const nx = Math.max(1, Math.round(l / step));
              for (let i = 1; i < nx; i++) {
                const t = i / nx;
                const p1 = projectIso(it.x + l * t, it.y, h, scale, ox, oy);
                const p2 = projectIso(it.x + l * t, it.y + w, h, scale, ox, oy);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
              }
            }
          }

          function renderItems() {
            const g = board.querySelector("#gItems");
            g.innerHTML = "";
            hudLayer.innerHTML = "";
            const rect = board.getBoundingClientRect();
            const v = vehicle();
            const sx = rect.width / v.inner_cm.L,
              sy = rect.height / v.inner_cm.W;
            const pxPerCm = Math.min(sx, sy);
            const isCompact = pxPerCm < 3; // requirement: when zoomed out
            // defs for clipping labels inside items
            let defs = board.querySelector('defs');
            if (!defs) { defs = document.createElementNS('http://www.w3.org/2000/svg','defs'); board.insertBefore(defs, board.firstChild); }
          // Layout for overflow area to the right of the hull
          let colX = v.inner_cm.L + 5;
          let colY = 0;
          let colW = 0;
          // Ensure glow filter for overflow
          if (!defs.querySelector('#redGlow')){
            const flt = document.createElementNS('http://www.w3.org/2000/svg','filter');
            flt.setAttribute('id','redGlow');
            flt.setAttribute('x','-50%'); flt.setAttribute('y','-50%'); flt.setAttribute('width','200%'); flt.setAttribute('height','200%');
            const ds = document.createElementNS('http://www.w3.org/2000/svg','feDropShadow');
            ds.setAttribute('dx','0'); ds.setAttribute('dy','0'); ds.setAttribute('stdDeviation','4');
            ds.setAttribute('flood-color','#ff4d4f'); ds.setAttribute('flood-opacity','0.65');
            flt.appendChild(ds);
            defs.appendChild(flt);
          }
          state.items.forEach((it) => {
              const { l, w } = dims2D(it);
              // Determine drawing coordinates, moving overflow items to columns on the right
              let drawX = it.x;
              let drawY = it.y;
              if (it.overflow) {
                if (colY + w > v.inner_cm.W) {
                  // new column
                  colX += colW + 10;
                  colY = 0;
                  colW = 0;
                }
                drawX = colX;
                drawY = colY;
                colY += w + 5;
                if (l > colW) colW = l;
              }
              // Invisible, oversized hit rectangle to make dragging easy
              const hitPad = 6; // cm (SVG units)
              const hit = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "rect"
              );
              hit.setAttribute("x", Math.max(0, drawX - hitPad));
              hit.setAttribute("y", Math.max(0, drawY - hitPad));
              hit.setAttribute("width", l + hitPad * 2);
              hit.setAttribute("height", w + hitPad * 2);
              hit.setAttribute("class", "dragHit");
              hit.setAttribute("data-id", it.id);
              g.appendChild(hit);

              const r = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "rect"
              );
              r.setAttribute("x", drawX);
              r.setAttribute("y", drawY);
              r.setAttribute("width", l);
              r.setAttribute("height", w);
              r.setAttribute("rx", 1.5);
              r.setAttribute(
                "class",
                "item" + (state.selectedId === it.id ? " selected" : "")
              );
              r.setAttribute("data-id", it.id);
              r.setAttribute("tabindex", "0");
              // Apply dynamic color based on item index and stack count
              const col = getItemColor(it);
              // derive a darker color for the stroke by reducing lightness
              let strokeCol = col;
              const m = /hsl\((\d+),\s*(\d+)%\,\s*(\d+)%\)/.exec(col);
              if (m) {
                const h = m[1];
                const s = m[2];
                let lval = parseInt(m[3], 10) - 20;
                if (lval < 5) lval = 5;
                strokeCol = `hsl(${h}, ${s}%, ${lval}%)`;
              }
              // Set via style rather than attribute to ensure it overrides theme CSS
              r.style.fill = col;
              r.style.stroke = strokeCol;
              // Append base rectangle early so label measurement (getBBox) sees DOM
              if (it.overflow) {
                r.style.filter = 'url(#redGlow)';
                // Make overflow more apparent
                r.style.stroke = '#ff4d4f';
                r.style.fillOpacity = '0.92';
              }
              g.appendChild(r);

              // Clip-path to keep indicators inside the rectangle
              const clipId = `cp_${it.id}`;
              const cp = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
              cp.setAttribute('id', clipId);
              const cpr = document.createElementNS('http://www.w3.org/2000/svg','rect');
              cpr.setAttribute('x', drawX); cpr.setAttribute('y', drawY);
              cpr.setAttribute('width', l); cpr.setAttribute('height', w);
              cp.appendChild(cpr);
              defs.appendChild(cp);

              // Choose contrasting label colors vs item fill
              let txtFill = '#f6f8ff', txtStroke = '#0b1020';
              if (m) {
                const light = parseInt(m[3], 10);
                if (light > 55) { // light item → darker text
                  txtFill = '#0b1020';
                  txtStroke = 'rgba(255,255,255,0.35)';
                }
              }
              // Centered, two-line label inside the pallet: first line D×S (compact) or D×S×W (normal), second line kg (×stack)
              const gLab = document.createElementNS('http://www.w3.org/2000/svg','g');
              gLab.setAttribute('clip-path', `url(#${clipId})`);
              gLab.setAttribute('pointer-events', 'none');
              const cx = drawX + l / 2;
              const cy = drawY + w / 2;
              const d2 = dims2D(it);
              const fullDims = `${d2.l}×${d2.w}×${it.H}`;
              const compactDims = `${d2.l}×${d2.w}×${it.H}`;
              const gText = document.createElementNS('http://www.w3.org/2000/svg','g');
              // main dims
              const labelDims = document.createElementNS('http://www.w3.org/2000/svg','text');
              labelDims.setAttribute('x', cx);
              labelDims.setAttribute('y', cy - 2);
              labelDims.setAttribute('text-anchor','middle');
              labelDims.setAttribute('dominant-baseline','middle');
              labelDims.setAttribute('class','label dimA');
              labelDims.style.fill = txtFill; labelDims.style.stroke = txtStroke;
              labelDims.textContent = isCompact ? compactDims : fullDims;
              gText.appendChild(labelDims);
              // secondary line: weight (+ stack count), hidden in compact via class/CSS
              const labelKg = document.createElementNS('http://www.w3.org/2000/svg','text');
              labelKg.setAttribute('x', cx);
              labelKg.setAttribute('y', cy + 12);
              labelKg.setAttribute('text-anchor','middle');
              labelKg.setAttribute('dominant-baseline','middle');
              labelKg.setAttribute('class','label dimB');
              labelKg.style.fill = txtFill; labelKg.style.stroke = txtStroke;
              const kgTxt = `${Math.max(0, it.weight||0)} kg${it.stackCount>1?` ×${it.stackCount}`:''}`;
              labelKg.textContent = kgTxt;
              gText.appendChild(labelKg);
              // Tooltip: always full
              const tip = `${fullDims}, ${Math.max(0, it.weight||0)} kg, ${it.type||'—'}`;
              gLab.setAttribute('title', tip);
              // Fit the two-line label into the rect (keep inside, scale down if needed)
              try {
                gLab.appendChild(gText);
                // Nie chowamy drugiej linii – dopasowujemy skalą
                gLab.classList.remove('compact');
                g.appendChild(gLab);
                const bbox = gText.getBBox();
                const pad = 4; // cm units
                const maxW = Math.max(1, l - pad);
                const maxH = Math.max(1, w - pad);
                const s = Math.min(1, Math.max(0.2, Math.min(maxW / Math.max(1, bbox.width), maxH / Math.max(1, bbox.height))));
                if (s < 1) {
                  const t = `translate(${cx},${cy}) scale(${s}) translate(${-cx},${-cy})`;
                  gText.setAttribute('transform', t);
                }
              } catch(_) {
                gLab.appendChild(gText);
                if (isCompact) gLab.classList.add('compact'); else gLab.classList.remove('compact');
                g.appendChild(gLab);
              }

              // Optional small icons inside the item rect (top‑right), clipped to item
              const flags = it.flags || {};
              if (flags.noStack || flags.fragile) {
                const iconSize = 4; // in cm (SVG units)
                let ix = drawX + l - iconSize - 1.5;
                const iy = drawY + 1.8;
                if (flags.noStack) {
                  const u1 = document.createElementNS('http://www.w3.org/2000/svg','use');
                  u1.setAttribute('href','#i-nostack');
                  u1.setAttribute('x', ix);
                  u1.setAttribute('y', iy);
                  u1.setAttribute('width', iconSize);
                  u1.setAttribute('height', iconSize);
                  u1.setAttribute('fill', txtFill);
                  gLab.appendChild(u1);
                  ix -= iconSize + 1;
                }
                if (flags.fragile) {
                  const u2 = document.createElementNS('http://www.w3.org/2000/svg','use');
                  u2.setAttribute('href','#i-fragile');
                  u2.setAttribute('x', ix);
                  u2.setAttribute('y', iy);
                  u2.setAttribute('width', iconSize);
                  u2.setAttribute('height', iconSize);
                  u2.setAttribute('fill', txtFill);
                  gLab.appendChild(u2);
                }
              }

              const bx = drawX + l - 3.5,
                by = drawY + 3.5;
              const rbHit = document.createElementNS("http://www.w3.org/2000/svg","circle");
              rbHit.setAttribute("cx", bx);
              rbHit.setAttribute("cy", by);
              rbHit.setAttribute("r", 12); // większy, niewidzialny obszar obrotu
              rbHit.setAttribute("class", "rotHit");
              rbHit.setAttribute("data-rot", it.id);
              // tylko hit-area, bez widocznych ikon
              g.appendChild(rbHit);
            });
            selPanel.classList.toggle("active", !!state.selectedId);
          }

          function recalc() {
            const v = vehicle();
            let vol = 0,
              kg = 0,
              ldm = 0;
            state.items.forEach((it) => {
              vol += volItem(it);
              kg += weightItem(it);
              ldm += ldmOf(it, v);
            });
            const capVol =
              (v.inner_cm.L * v.inner_cm.W * v.inner_cm.H) / 1_000_000;
            volBar.max = 100;
            volBar.value = Math.min(100, (vol / capVol) * 100);
            kgBar.max = 100;
            kgBar.value = Math.min(100, (kg / v.payload_kg) * 100);
            volText.textContent = `${vol.toFixed(2)} / ${capVol.toFixed(1)} m³`;
            kgText.textContent = `${Math.round(kg)} / ${
              v.payload_kg
            } kg • LDM ~ ${ldm.toFixed(2)}`;

            const overload = kg - v.payload_kg;
            fitBadge.className = "badge " + (overload > 0 ? "bad" : "ok");
            fitBadge.textContent =
              overload > 0
                ? t('exceeds_payload', { kg: Math.abs(Math.round(overload)) })
                : t("fits");

            let maxX = 0,
              usedWidth = 0;
            const rows = buildShelvesSnapshot();
            rows.forEach((row) => {
              maxX = Math.max(maxX, row.x);
              usedWidth += row.h;
            });
            leftBadge.textContent = t("clearance_lw", {
              L: Math.max(0, v.inner_cm.L - Math.round(maxX)),
              W: Math.max(0, v.inner_cm.W - Math.round(usedWidth)),
            });

            // Update axle load info + warnings/suggestion after recalculation
            warnAndSuggest();
          }

          // Compute distribution across axles with optional vehicle.ax {front,rear,fmax,rmax}
          // Returns detailed metrics and updates the UI summary line.
          function computeAxleLoads(items, veh) {
            const infoEl = mount.querySelector("#axleInfo");
            const ax = veh.ax || {};
            const L = veh.inner_cm?.L || 0;
            const frontPos = Number(ax.front ?? 0); // cm from origin (front)
            const rearPos = Number(ax.rear ?? L);   // cm from origin (rear axle position)
            const fmax = Number(ax.fmax ?? veh.front_axle_kg ?? 0) || 0;
            const rmax = Number(ax.rmax ?? veh.rear_axle_kg ?? 0) || 0;

            // Total weight considering stacking
            let totalKg = 0, cxSum = 0;
            for (const it of items) {
              const kg = weightItem(it); // already multiplies by stackCount
              const { l } = dims2D(it);
              const cx = (Number(it.x) || 0) + l / 2; // cm from front
              totalKg += kg;
              cxSum += kg * cx;
            }
            // Center of mass along length
            const Cx = totalKg ? cxSum / totalKg : (L || 0) / 2;
            const span = Math.max(1, (rearPos - frontPos));
            // Simple beam reaction forces (front and rear supports)
            let Rf = totalKg * (rearPos - Cx) / span; // front reaction
            let Rr = totalKg - Rf;                    // rear reaction
            // Guard against tiny negatives from rounding
            Rf = Math.max(0, Rf);
            Rr = Math.max(0, Rr);

            const res = {
              front_kg: Math.round(Rf),
              rear_kg: Math.round(Rr),
              front_pct: fmax ? Math.round((Rf / fmax) * 100) : 0,
              rear_pct: rmax ? Math.round((Rr / rmax) * 100) : 0,
              totalKg: Math.round(totalKg),
              cx_cm: Math.round(Cx),
            };

            if (infoEl) {
              if (!totalKg) {
                infoEl.textContent = t('axle_no_data');
              } else {
                const pctF = fmax ? ` (${res.front_pct}%${res.front_pct>100?"!":""})` : "";
                const pctR = rmax ? ` (${res.rear_pct}%${res.rear_pct>100?"!":""})` : "";
                try {
                  const totL = (I18N[lang] && I18N[lang].axis_total) || (t('front_rear_total').split('•')[0]||'Total').trim() || 'Total';
                  const fL = (I18N[lang] && I18N[lang].axis_front) || (t('front_rear_total').split('•')[1]||'Front').trim() || 'Front';
                  const rL = (I18N[lang] && I18N[lang].axis_rear) || (t('front_rear_total').split('•')[2]||'Rear').trim() || 'Rear';
                  infoEl.textContent = `${totL}: ${res.totalKg} kg • ${fL}: ${res.front_kg} kg${pctF} • ${rL}: ${res.rear_kg} kg${pctR}`;
                } catch(_) {
                  infoEl.textContent = `Total: ${res.totalKg} kg • Front: ${res.front_kg} kg${pctF} • Rear: ${res.rear_kg} kg${pctR}`;
                }
              }
            }
            return res;
          }

          // Build warnings + simple vehicle suggestion based on axle and payload
          function warnAndSuggest() {
            const v = vehicle();
            const ax = computeAxleLoads(state.items || [], v);
            const warnings = [];
            if (ax.front_pct > 100) warnings.push(t('warn_front_over', { pct: ax.front_pct }));
            if (ax.rear_pct > 100) warnings.push(t('warn_rear_over', { pct: ax.rear_pct }));
            if ((state.items || []).some((it) => (it.H || 0) > v.inner_cm.H)) warnings.push(t('warn_too_tall'));
            if ((state.items || []).some((it) => it.stackable === false)) warnings.push(t('warn_non_stack'));
            const totalKg = (state.items || []).reduce((s, it) => s + weightItem(it), 0);
            if (totalKg > v.payload_kg) warnings.push(t('warn_payload_over'));
            const notPlaced = (state.items || []).filter((it) => it && it.overflow).length;
            if (notPlaced > 0) warnings.push(t('warn_not_placed', { count: notPlaced }));

            state.warnings = warnings;
            const warnEl = mount.querySelector('#warnList');
            if (warnEl) {
              warnEl.innerHTML = '';
              if (!warnings.length) {
                warnEl.style.display = 'none';
              } else {
                warnEl.style.display = 'flex';
                for (const w of warnings) {
                  const b = document.createElement('span');
                  b.className = 'badge bad';
                  b.textContent = w;
                  warnEl.appendChild(b);
                }
              }
            }
            return ax;
          }

          function buildShelvesSnapshot() {
            const v = vehicle();
            const items = state.items.map((it) => ({ ...it, ...dims2D(it) }));
            items.sort((a, b) => b.w - a.w);
            const shelves = [];
            let y = 0;
            items.forEach((it) => {
              let placed = false;
              for (const sh of shelves) {
                if (
                  it.w <= v.inner_cm.W - sh.y &&
                  sh.x + it.l <= v.inner_cm.L
                ) {
                  sh.x += it.l;
                  sh.h = Math.max(sh.h, it.w);
                  placed = true;
                  break;
                }
              }
              if (!placed) {
                if (y + it.w <= v.inner_cm.W) {
                  shelves.push({ x: it.l, h: it.w, y });
                  y += it.w;
                }
              }
            });
            return shelves;
          }

  function renderAll() {
    // Enforce simple overflow-by-dimensions rule before rendering
    try { enforceOverflowRules(); } catch(_) {}
    renderVehSelect();
            renderSpecs();
            if (state.viewMode === "3d") {
              // show 3D canvas, hide 2D SVG + HUD
              board.style.display = "none";
              hudLayer.style.display = "none";
              // prefer new Three.js view
              if (view3d) { view3d.hidden = false; view3d.style.display = 'block'; }
              if (board3d) { board3d.style.display = 'none'; }
              stageWrap?.classList.remove('compare');
              if (boardB) boardB.style.display = 'none';
              try { 
                threeInit(); 
                // Ensure camera mode
                if (threeCtx.state.top2d) threeSetCamera('ortho'); else threeSetCamera('persp');
                threeUpdateVehicle(); 
                threeUpdateItems();
                // Update section slider visibility
                if (sectionSlider) sectionSlider.style.display = threeCtx.state.sectionEnabled ? 'inline-block' : 'none';
              } catch(_) {}
              // Hide overlay in 3D mode
              try {
                const vp = mount.querySelector('#viewport');
                if (vp) { vp.style.display = 'none'; vp.setAttribute('aria-hidden','true'); }
              } catch(_) {}
            } else {
              board3d.style.display = "none";
              hudLayer.style.display = "block";
              board.style.display = "block";
              if (view3d) { view3d.hidden = true; view3d.style.display = 'none'; }
              try { hide3DTooltip(); } catch(_) {}
              buildSVG();
              renderItems();
              // Overlay labels: always keep in sync after main render
              try { overlayLabels.updateAll(); } catch (_) {}
              // Keep 3D scene data in sync even when not visible
              try { if (threeCtx && threeCtx.init) threeUpdateItems(); } catch(_) {}
              if (state.compareOn && state.variants?.plans?.length) {
                stageWrap?.classList.add('compare');
                if (boardB) boardB.style.display = 'block';
                renderCompareB();
              } else {
                stageWrap?.classList.remove('compare');
                if (boardB) boardB.style.display = 'none';
              }
              // Always hide section slider outside 3D
              if (sectionSlider) sectionSlider.style.display = 'none';
            }
            renderAxleOverlay();
            try { updateRulers(); } catch(_) {}
            renderSection();
            recalc();
            bindItemEvents();
            updateVariantLabel();
            // Update overlay labels at end of render
            try { overlayLabels.updateAll(); } catch(_){}
          }

          // Feature flags
          const AXLE_OVERLAY_ON = false; // hide dashed CoG/guide lines unless explicitly enabled

          function renderAxleOverlay() {
            if (!board) return;
            if (!AXLE_OVERLAY_ON) {
              try { board.querySelector('#gAxle')?.remove(); board.querySelector('#gGuides')?.remove(); } catch(_) {}
              return;
            }
            const v = vehicle();
            const old = board.querySelector('#gAxle');
            if (old) old.remove();
            if (!state.items.length) return;
            const ax = computeAxleLoads(state.items, v);
            if (!ax || !isFinite(ax.cx_cm)) return;
            const g = document.createElementNS('http://www.w3.org/2000/svg','g');
            g.setAttribute('id','gAxle');
            // CoG line
            const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
            ln.setAttribute('x1', ax.cx_cm);
            ln.setAttribute('y1', 0);
            ln.setAttribute('x2', ax.cx_cm);
            ln.setAttribute('y2', v.inner_cm.W);
            ln.setAttribute('class','axline');
            g.appendChild(ln);
            // CoG marker (middle width)
            const mk = document.createElementNS('http://www.w3.org/2000/svg','circle');
            mk.setAttribute('cx', ax.cx_cm);
            mk.setAttribute('cy', Math.max(6, Math.min(v.inner_cm.W-6, v.inner_cm.W/2)));
            mk.setAttribute('r', 2.6);
            mk.setAttribute('class','axmark');
            g.appendChild(mk);
            // Bars for front/rear loads (relative to max if available, else to total)
            const hb = 4; // height of bar
            const pad = 1;
            const fRatio = (ax.front_pct && ax.front_pct>0) ? Math.min(1, ax.front_pct/100) : (ax.front_kg/(ax.front_kg+ax.rear_kg||1));
            const rRatio = (ax.rear_pct && ax.rear_pct>0) ? Math.min(1, ax.rear_pct/100) : (ax.rear_kg/(ax.front_kg+ax.rear_kg||1));
            const fRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
            fRect.setAttribute('x', pad);
            fRect.setAttribute('y', pad);
            fRect.setAttribute('width', Math.max(2, (v.inner_cm.L/2 - 2*pad) * fRatio));
            fRect.setAttribute('height', hb);
            fRect.setAttribute('class','axbar');
            g.appendChild(fRect);
            const rRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
            const rightX = v.inner_cm.L/2 + pad;
            rRect.setAttribute('x', rightX);
            rRect.setAttribute('y', pad);
            rRect.setAttribute('width', Math.max(2, (v.inner_cm.L/2 - 2*pad) * rRatio));
            rRect.setAttribute('height', hb);
            rRect.setAttribute('class','axbar');
            g.appendChild(rRect);
            // Texts
            const tf = document.createElementNS('http://www.w3.org/2000/svg','text');
            tf.setAttribute('x', pad+2);
            tf.setAttribute('y', hb + pad + 3);
            tf.setAttribute('class','axtext');
            tf.textContent = `F ${ax.front_kg} kg${ax.front_pct?` (${ax.front_pct}%)`:''}`;
            g.appendChild(tf);
            const tr = document.createElementNS('http://www.w3.org/2000/svg','text');
            tr.setAttribute('x', rightX + 2);
            tr.setAttribute('y', hb + pad + 3);
            tr.setAttribute('class','axtext');
            tr.textContent = `R ${ax.rear_kg} kg${ax.rear_pct?` (${ax.rear_pct}%)`:''}`;
            g.appendChild(tr);
            board.appendChild(g);

            // Also draw a full-height guide line at the loaded length (max X of placed items)
            try {
              const g2old = board.querySelector('#gGuides');
              if (g2old) g2old.remove();
              const g2 = document.createElementNS('http://www.w3.org/2000/svg','g');
              g2.setAttribute('id','gGuides');
              const maxX = (state.items||[]).reduce((m,it)=>{
                if (!it || it.overflow) return m;
                const d = dims2D(it);
                return Math.max(m, (it.x||0) + (d.l||0));
              }, 0);
              if (maxX > 0) {
                const ln2 = document.createElementNS('http://www.w3.org/2000/svg','line');
                ln2.setAttribute('x1', String(maxX));
                ln2.setAttribute('y1', '0');
                ln2.setAttribute('x2', String(maxX));
                ln2.setAttribute('y2', String(v.inner_cm.W));
                ln2.setAttribute('class','sectionline');
                g2.appendChild(ln2);
              }
              board.appendChild(g2);
            } catch(_) {}
          }

          function renderCompareB() {
            if (!boardB) return;
            const v = vehicle();
            // Pick next variant as B (wrap if needed)
            let idxB = (state.variants?.index ?? 0) + 1;
            const n = state.variants?.plans?.length || 0;
            if (!n) return;
            idxB = idxB % n;
            const itemsB = deepClone(state.variants.plans[idxB] || state.items || []);

            // Compute overflow padding similar to buildSVG()
            const ovItems = (itemsB || []).filter((it) => it && it.overflow);
            let pad = 0;
            if (ovItems.length) {
              const totalH = ovItems.reduce((s, it) => {
                const d = dims2D(it);
                return s + (d.w || 0) + 5;
              }, 0);
              const cols = Math.max(1, Math.ceil(totalH / Math.max(1, v.inner_cm.W)));
              const maxL = ovItems.reduce((m, it) => Math.max(m, dims2D(it).l || 0), 0);
              pad = cols * (maxL + 10) + 10;
            }
            boardB.setAttribute('viewBox', `0 0 ${v.inner_cm.L + pad} ${v.inner_cm.W}`);
            boardB.innerHTML = '';
            // grid
            const gGrid = document.createElementNS('http://www.w3.org/2000/svg','g');
            const step = v.grid_cm;
            for (let x = 0; x <= v.inner_cm.L; x += step) {
              const line = document.createElementNS('http://www.w3.org/2000/svg','line');
              line.setAttribute('x1', x); line.setAttribute('y1', 0);
              line.setAttribute('x2', x); line.setAttribute('y2', v.inner_cm.W);
              line.setAttribute('class','gridline');
              gGrid.appendChild(line);
            }
            for (let y = 0; y <= v.inner_cm.W; y += step) {
              const line = document.createElementNS('http://www.w3.org/2000/svg','line');
              line.setAttribute('x1', 0); line.setAttribute('y1', y);
              line.setAttribute('x2', v.inner_cm.L); line.setAttribute('y2', y);
              line.setAttribute('class','gridline');
              gGrid.appendChild(line);
            }
            boardB.appendChild(gGrid);
            // hull
            const hull = document.createElementNS('http://www.w3.org/2000/svg','rect');
            hull.setAttribute('x',0); hull.setAttribute('y',0);
            hull.setAttribute('width', v.inner_cm.L);
            hull.setAttribute('height', v.inner_cm.W);
            hull.setAttribute('rx',3);
            hull.setAttribute('class','hull');
            boardB.appendChild(hull);

            // items (static preview)
            let colX = v.inner_cm.L + 5, colY = 0, colW = 0;
            for (const it of itemsB) {
              const { l, w } = dims2D(it);
              let drawX = it.x, drawY = it.y;
              if (it.overflow) {
                if (colY + w > v.inner_cm.W) { colX += colW + 10; colY = 0; colW = 0; }
                drawX = colX; drawY = colY; colY += w + 5; if (l > colW) colW = l;
              }
              const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
              r.setAttribute('x', drawX); r.setAttribute('y', drawY);
              r.setAttribute('width', l); r.setAttribute('height', w);
              r.setAttribute('rx', 1.5); r.setAttribute('class','item');
              const col = getItemColor(it);
              let strokeCol = col; const m = /hsl\((\d+),\s*(\d+)%\,\s*(\d+)%\)/.exec(col);
              if (m) { const h=m[1], s=m[2]; let lv=parseInt(m[3],10)-20; if (lv<5) lv=5; strokeCol=`hsl(${h}, ${s}%, ${lv}%)`; }
              r.style.fill = col; r.style.stroke = strokeCol;
              boardB.appendChild(r);
            }
          }

          // ===================== ITEMS API =====================
          function addItemFromPreset(p, opts = {}) {
            const it = {
              id: uid(),
              type: p.id,
              ...p.dims,
              weight: p.weight,
              stackable: p.stackable !== false,
              stackCount: 1,
              x: 0,
              y: 0,
              rot: 0,
              flags: (p.stackable === false) ? { noStack: true } : { }
            };
            if (opts.autoPlace) placeNewItem(it);
            state.items.push(it);
            state.selectedId = it.id;
            dispatchSelectionChange();
          }

          function addCustomLine() {
            const raw = (mount.querySelector('#cOne')?.value || '').trim();
            const stackable = !!mount.querySelector('#cStack')?.checked;
            if (!raw) { showError('Podaj D×S×W×kg (opcjonalnie ×ilość)'); return; }
            // Split by commas/semicolon/newline
            const segs = raw.split(/[;,\n]+/).map(s => s.trim()).filter(Boolean);
            const RX = /^\s*(\d+(?:[.,]\d+)?)\s*[x×*]\s*(\d+(?:[.,]\d+)?)\s*[x×*]\s*(\d+(?:[.,]\d+)?)\s*[x×*]\s*(\d+(?:[.,]\d+)?)(?:\s*[x×*]\s*(\d+))?\s*$/i;
            let added = 0;
            pushHistory();
            for (const s of segs) {
              const m = s.match(RX);
              if (!m) continue;
              let L = Math.round(parseFloat(String(m[1]).replace(',', '.')));
              let W = Math.round(parseFloat(String(m[2]).replace(',', '.')));
              let H = Math.round(parseFloat(String(m[3]).replace(',', '.')));
              let Kg = Math.round(parseFloat(String(m[4]).replace(',', '.')));
              const Q = Math.max(1, parseInt(m[5] || '1', 10));
              if (L < W) { const tmp=L; L=W; W=tmp; }
              for (let i=0;i<Q;i++){
                const it = { id: uid(), type: 'custom', L, W, H, weight: Kg, stackable, stackCount: 1, x:0, y:0, rot:0, flags: stackable ? {} : { noStack: true } };
                placeNewItem(it);
                state.items.push(it);
                added++;
              }
            }
            if (!added) { showError('Format: 120x80x180x350 [x2]'); return; }
            if (added > 1) autopackUltra(0, true); else renderAll();
            const inp = mount.querySelector('#cOne'); if (inp) inp.value = '';
          }

          function rotateSelected(dir) {
            const it = state.items.find((x) => x.id === state.selectedId);
            if (!it) return;
            pushHistory();
            it.rot = ((it.rot || 0) + (dir || 1) + 4) % 4;
            const v = vehicle();
            const { l, w } = dims2D(it);
            if (it.x + l > v.inner_cm.L) it.x = v.inner_cm.L - l;
            if (it.y + w > v.inner_cm.W) it.y = v.inner_cm.W - w;
            renderAll();
            dispatchSelectionChange();
          }

          // Strict rotate: toggle 0 <-> 90 only, clamp, and cancel if collision/out-of-bounds
          function rotateSelectedStrict() {
            const it = state.items.find((x) => x.id === state.selectedId);
            if (!it) return false;
            const v = vehicle();
            const prevRot = it.rot || 0;
            const targetRot = (prevRot % 2 === 0) ? 1 : 0;
            // simulate rotation
            const tmp = { ...it, rot: targetRot };
            let { l, w } = dims2D(tmp);
            let nx = it.x, ny = it.y;
            // clamp inside cargo after rotation
            if (nx + l > v.inner_cm.L) nx = v.inner_cm.L - l;
            if (ny + w > v.inner_cm.W) ny = v.inner_cm.W - w;
            const cand = { x: nx, y: ny, l, w };
            // bounds and collisions
            let invalid = outOfBounds(cand, v);
            if (!invalid) {
              for (const other of state.items) {
                if (String(other.id) === String(it.id)) continue;
                const od = dims2D(other);
                const br = { x: other.x, y: other.y, l: od.l, w: od.w };
                if (intersects(cand, br)) { invalid = true; break; }
              }
            }
            if (invalid) {
              try { triggerCollisionFlash(cand, { x: 0, y: 0 }); } catch(_) {}
              return false;
            }
            pushHistory();
            it.rot = targetRot;
            it.x = nx; it.y = ny;
            renderAll();
            dispatchSelectionChange();
            return true;
          }
          function deleteSelected() {
            const i = state.items.findIndex((x) => x.id === state.selectedId);
            if (i > -1) {
              pushHistory();
              state.items.splice(i, 1);
              state.selectedId = null;
              renderAll();
              dispatchSelectionChange();
            }
          }
          function changeStack(delta) {
            const it = state.items.find((x) => x.id === state.selectedId);
            if (!it || !it.stackable) return;
            const v = vehicle();
            const max = Math.max(1, Math.floor(v.inner_cm.H / it.H));
            it.stackCount = Math.min(max, Math.max(1, it.stackCount + delta));
            renderAll();
          }

          function stackAll() {
            pushHistory();
            const v = vehicle();
            const groups = new Map();
            for (const it of state.items) {
              const key = [
                it.type,
                it.L,
                it.W,
                it.H,
                it.weight,
                it.stackable ? "1" : "0",
              ].join("|");
              const arr = groups.get(key) || [];
              arr.push(it);
              groups.set(key, arr);
            }
            const next = [];
            for (const [key, arr] of groups.entries()) {
              const a = arr[0];
              if (!a.stackable) {
                next.push(...arr);
                continue;
              }
              const cap = Math.max(1, Math.floor(v.inner_cm.H / a.H));
              let total = arr.reduce((s, x) => s + x.stackCount, 0);
              while (total > 0) {
                const cnt = Math.min(cap, total);
                next.push({
                  ...deepClone(a),
                  id: uid(),
                  x: 0,
                  y: 0,
                  stackCount: cnt,
                });
                total -= cnt;
              }
            }
            state.items = next;
            renderAll();
          }

          // Copy/Paste
          function copySelected() {
            const it = state.items.find((x) => x.id === state.selectedId);
            if (!it) return;
            state.clipboard = deepClone(it);
            showError("Skopiowano wybrany element");
          }
          function pasteClipboard() {
            if (!state.clipboard) {
              showError("Schowek pusty");
              return;
            }
            pushHistory();
            const base = deepClone(state.clipboard);
            base.id = uid();
            const sel = state.items.find((x) => x.id === state.selectedId);
            if (sel) {
              const sD = dims2D(sel);
              const cand = [
                { x: snap(sel.x + sD.l + vehicle().grid_cm), y: sel.y },
                { x: sel.x, y: snap(sel.y + sD.w + vehicle().grid_cm) },
              ];
              for (const c of cand) {
                base.x = c.x;
                base.y = c.y;
                if (
                  within({ ...base }, vehicle()) &&
                  !anyCollision({ ...base }, null)
                ) {
                  state.items.push(base);
                  state.selectedId = base.id;
                  renderAll();
                  dispatchSelectionChange();
                  return;
                }
              }
            }
            placeNewItem(base);
            state.items.push(base);
            state.selectedId = base.id;
            renderAll();
            dispatchSelectionChange();
          }

          // ===================== AUTOPACK / VARIANTS =====================
          function computePlan(items, v, seed) {
            for (const it of items) {
              if (
                Math.min(it.W, it.L) > v.inner_cm.W &&
                Math.max(it.W, it.L) > v.inner_cm.W
              )
                return {
                  placed: [],
                  unplaced: items,
                  free: [{ x: 0, y: 0, w: v.inner_cm.L, h: v.inner_cm.W }],
                };
              if (it.H > v.inner_cm.H)
                return {
                  placed: [],
                  unplaced: items,
                  free: [{ x: 0, y: 0, w: v.inner_cm.L, h: v.inner_cm.W }],
                };
            }
            let free = [{ x: 0, y: 0, w: v.inner_cm.L, h: v.inner_cm.W }],
              placed = [],
              unplaced = [];
            items.sort((a, b) =>
              seed % 3 === 0
                ? Math.max(b.W, b.L) - Math.max(a.W, a.L) ||
                  Math.min(b.W, b.L) - Math.min(a.W, a.L)
                : Math.max(b.L, b.W) - Math.max(a.L, a.W) || b.W - a.W
            );
            for (const it of items) {
              let best = null;
              let chosenRot = 0;
              for (const o of seed % 2 ? [1, 0] : [0, 1]) {
                const tmp = { ...it, rot: o };
                const { l, w } = dims2D(tmp);
                const spot = bestFreeRect(free, l, w);
                if (spot) {
                  const waste = spot.w * spot.h - l * w;
                  if (!best || waste < best.waste) {
                    best = { rect: spot, waste, l, w };
                    chosenRot = o;
                  }
                }
              }
              if (!best) {
                unplaced.push(it);
                continue;
              }
              it.rot = chosenRot;
              it.x = best.rect.x;
              it.y = best.rect.y;
              placed.push(it);
              free = guillotineSplitAndNormalize(free, best.rect, {
                l: best.l,
                w: best.w,
              });
            }
            if (unplaced.length) {
              const out = shelfPack(unplaced, v, placed, free);
              placed = out.placed;
              unplaced = out.unplaced;
              free = out.free;
            }
            return { placed, unplaced, free };
          }

          function autopackUltra(seed = 0, allowAutoStack = true) {
            pushHistory();
            const v = vehicle();
            const items = state.items.map((it) => ({ ...it }));
            const totalKg = items.reduce((s, it) => s + weightItem(it), 0);
            if (totalKg > v.payload_kg) {
              showError(`Za ciężko o ${Math.round(totalKg - v.payload_kg)} kg`);
            }

            const seeds = [0, 1, 2, 3, 4].map((s) => (s + seed) % 7);
            const plans = seeds.map((s) => computePlan(deepClone(items), v, s));
            const scored = plans
              .map((p, i) => ({
                i,
                un: p.unplaced.length,
                waste: p.free.reduce((a, r) => a + r.w * r.h, 0),
              }))
              .sort((a, b) => a.un - b.un || a.waste - b.waste);
            state.variants = {
              plans: plans.map((p) => {
                const placed = p.placed.map((x) => ({ ...x, overflow: false }));
                const unplaced = p.unplaced.map((x) => ({ ...x, overflow: true }));
                return placed.concat(unplaced);
              }),
              index: scored[0].i,
            };
            applyVariant(scored[0].i, { noHistory: true });
            const bestPlan = plans[scored[0].i];
            if (bestPlan.unplaced.length && allowAutoStack) {
              stackAll();
              autopackUltra(seed + 1, false);
            }
          }

          function applyVariant(idx, opts = {}) {
            if (!state.variants.plans.length) return;
            if (!opts.noHistory) pushHistory();
            state.variants.index = Math.max(
              0,
              Math.min(state.variants.plans.length - 1, idx)
            );
            state.items = deepClone(state.variants.plans[state.variants.index]);
            renderAll();
          }

          function updateVariantLabel() {
            varLabel.textContent = `${t("variant")} ${
              state.variants.plans.length ? state.variants.index + 1 : 0
            }/${state.variants.plans.length || 0}`;
          }

          function bestFreeRect(free, l, w) {
            let best = null;
            for (const r of free) {
              if (l <= r.w && w <= r.h) {
                const areaWaste = r.w * r.h - l * w;
                const shortSide = Math.min(r.w - l, r.h - w);
                const score = areaWaste * 1e6 + shortSide;
                if (!best || score < best.score) {
                  best = { rect: r, score };
                }
              }
            }
            return best ? best.rect : null;
          }

          function guillotineSplitAndNormalize(free, usedRect, box) {
            const out = [];
            for (const r of free) {
              if (r !== usedRect) {
                out.push(r);
                continue;
              }
              const r1 = { x: r.x + box.l, y: r.y, w: r.w - box.l, h: box.w };
              const r2 = { x: r.x, y: r.y + box.w, w: r.w, h: r.h - box.w };
              if (r1.w > 0 && r1.h > 0) out.push(r1);
              if (r2.w > 0 && r2.h > 0) out.push(r2);
            }
            return normalizeFree(out);
          }

          function normalizeFree(list) {
            list = list.filter(
              (a, i) =>
                !list.some(
                  (b, j) =>
                    j !== i &&
                    a.x >= b.x &&
                    a.y >= b.y &&
                    a.x + a.w <= b.x + b.w &&
                    a.y + a.h <= b.y + b.h
                )
            );
            list = list.map((r) => ({
              x: snap(r.x),
              y: snap(r.y),
              w: snap(r.w),
              h: snap(r.h),
            }));
            return list;
          }

          function shelfPack(unplaced, v, placed, free) {
            let y = 0,
              shelfH = 0,
              x = 0;
            unplaced.sort((a, b) => Math.max(b.W, b.L) - Math.max(a.W, a.L));
            const rest = [];
            for (const it of unplaced) {
              const { l, w } = dims2D(it);
              if (w > v.inner_cm.W || l > v.inner_cm.L) {
                rest.push(it);
                continue;
              }
              if (x + l <= v.inner_cm.L) {
                it.x = x;
                it.y = y;
                x += l;
                shelfH = Math.max(shelfH, w);
                placed.push(it);
              } else if (y + shelfH + w <= v.inner_cm.W) {
                y += shelfH;
                x = 0;
                shelfH = 0;
                it.x = 0;
                it.y = y;
                x = l;
                shelfH = Math.max(shelfH, w);
                placed.push(it);
              } else {
                rest.push(it);
              }
            }
            free = [
              { x: x, y: y, w: v.inner_cm.L - x, h: shelfH },
              {
                x: 0,
                y: y + shelfH,
                w: v.inner_cm.L,
                h: v.inner_cm.W - (y + shelfH),
              },
            ].filter((r) => r.w > 0 && r.h > 0);
            return { placed, unplaced: rest, free };
          }

          function placeNewItem(it) {
            const v = vehicle();
            const free = computeFreeRectsFromPlaced(v, state.items);
            for (const rot of [0, 1]) {
              const { l, w } = dims2D({ ...it, rot });
              const spot = bestFreeRect(free, l, w);
              if (spot) {
                it.rot = rot;
                it.x = snap(spot.x);
                it.y = snap(spot.y);
                return true;
              }
            }
            it.x = 0;
            it.y = 0;
            it.rot = 0;
            return false;
          }

          function computeFreeRectsFromPlaced(v, items) {
            let free = [{ x: 0, y: 0, w: v.inner_cm.L, h: v.inner_cm.W }];
            const placed = items.map((it) => ({
              x: it.x,
              y: it.y,
              w: dims2D(it).l,
              h: dims2D(it).w,
            }));
            for (const p of placed) {
              const next = [];
              for (const r of free) {
                if (
                  !(
                    p.x >= r.x + r.w ||
                    p.x + p.w <= r.x ||
                    p.y >= r.y + r.h ||
                    p.y + p.h <= r.y
                  )
                ) {
                  const left = { x: r.x, y: r.y, w: p.x - r.x, h: r.h };
                  const right = {
                    x: p.x + p.w,
                    y: r.y,
                    w: r.x + r.w - (p.x + p.w),
                    h: r.h,
                  };
                  const top = { x: r.x, y: r.y, w: r.w, h: p.y - r.y };
                  const bottom = {
                    x: r.x,
                    y: p.y + p.h,
                    w: r.w,
                    h: r.y + r.h - (p.y + p.h),
                  };
                  [left, right, top, bottom].forEach((q) => {
                    if (q.w > 0 && q.h > 0) next.push(q);
                  });
                } else next.push(r);
              }
              free = normalizeFree(next);
            }
            return free;
          }

          // ===================== DRAG / KEYBOARD + DOCKING =====================
          let drag = null; // {id, offXcm, offYcm, pre:{x,y}}
          const DOCK = 5; // cm

          // Grid snap to nearest minor grid (in world cm)
          function computeSnapGrid(x, y, minor) {
            const g = Math.max(1, Number(minor) || 5);
            return {
              x: Math.round(x / g) * g,
              y: Math.round(y / g) * g,
            };
          }

          // Wall snap: if close to any cargo wall within threshold (fraction of grid step)
          function computeSnapWalls(x, y, w, h, veh, th = 0.6) {
            const L = Math.max(0, veh?.inner_cm?.L || 0);
            const W = Math.max(0, veh?.inner_cm?.W || 0);
            const g = Math.max(1, veh?.grid_cm || 5);
            const d = Math.max(1, g * (Number(th) || 0.6));
            let nx = x, ny = y;
            let snapped = false;
            // Clamp into bounds first to avoid drifting beyond edges
            nx = Math.max(0, Math.min(L - w, nx));
            ny = Math.max(0, Math.min(W - h, ny));
            // Snap to left/right
            if (Math.abs(nx - 0) <= d) { nx = 0; snapped = true; }
            if (Math.abs(nx + w - L) <= d) { nx = L - w; snapped = true; }
            // Snap to top/bottom
            if (Math.abs(ny - 0) <= d) { ny = 0; snapped = true; }
            if (Math.abs(ny + h - W) <= d) { ny = W - h; snapped = true; }
            return { x: nx, y: ny, snapped };
          }

          // Edge snap to neighbor items. Returns first eligible (closest) edge within threshold.
          function computeSnapEdges(x, y, l, w, items, selfId, veh, th = 0.6) {
            const g = Math.max(1, veh?.grid_cm || 5);
            const thCm = Math.max(1, g * (Number(th) || 0.6));
            let best = { axis: null, delta: Infinity, nx: x, ny: y };
            for (const other of (items || [])) {
              if (!other || String(other.id) === String(selfId)) continue;
              const od = dims2D(other);
              const ox = Number(other.x) || 0;
              const oy = Number(other.y) || 0;
              const ol = Number(od.l) || 0;
              const ow = Number(od.w) || 0;

              // Horizontal snapping (align X) if vertical ranges overlap
              const vOverlap = !(y + w <= oy || y >= oy + ow);
              if (vOverlap) {
                // to other's right edge
                const candX1 = ox + ol; // x = other.right
                const dx1 = Math.abs(x - candX1);
                if (dx1 <= thCm && dx1 < best.delta) {
                  best = { axis: 'x', delta: dx1, nx: candX1, ny: y };
                }
                // to other's left edge (x + l = ox)
                const candX2 = ox - l; // x = other.left - self.width
                const dx2 = Math.abs(x - candX2);
                if (dx2 <= thCm && dx2 < best.delta) {
                  best = { axis: 'x', delta: dx2, nx: candX2, ny: y };
                }
              }

              // Vertical snapping (align Y) if horizontal ranges overlap
              const hOverlap = !(x + l <= ox || x >= ox + ol);
              if (hOverlap) {
                // to other's bottom edge
                const candY1 = oy + ow; // y = other.bottom
                const dy1 = Math.abs(y - candY1);
                if (dy1 <= thCm && dy1 < best.delta) {
                  best = { axis: 'y', delta: dy1, nx: x, ny: candY1 };
                }
                // to other's top edge (y + w = oy)
                const candY2 = oy - w; // y = other.top - self.height
                const dy2 = Math.abs(y - candY2);
                if (dy2 <= thCm && dy2 < best.delta) {
                  best = { axis: 'y', delta: dy2, nx: x, ny: candY2 };
                }
              }
            }
            if (best.axis) return { x: best.nx, y: best.ny, snapped: true };
            return { x, y, snapped: false };
          }

          // Generic rectangle intersection and bounds helpers (world cm)
          function intersects(a, b) {
            return !(a.x >= b.x + b.l || a.x + a.l <= b.x || a.y >= b.y + b.w || a.y + a.w <= b.y);
          }
          function outOfBounds(a, veh) {
            const L = veh?.inner_cm?.L || 0;
            const W = veh?.inner_cm?.W || 0;
            return a.x < 0 || a.y < 0 || a.x + a.l > L || a.y + a.w > W;
          }

          // Ephemeral collision flash in overlay with small sinusoidal bump
          // Disable by default (unwanted red preview rectangle while dragging into collisions)
          const COLLISION_FLASH_ON = false;
          let COLLISION = null; // {rect:{x,y,l,w}, dir:{x,y}, start, dur, amp}
          let collisionRAF = null;
          function triggerCollisionFlash(rect, dir) {
            if (!COLLISION_FLASH_ON) return; // feature turned off
            try { cancelAnimationFrame(collisionRAF); } catch(_) {}
            const now = (performance && performance.now) ? performance.now() : Date.now();
            COLLISION = { rect: { ...rect }, dir: { x: dir.x || 0, y: dir.y || 0 }, start: now, dur: 150, amp: 8 };
            renderCollisionsOverlay();
          }
          function renderCollisionsOverlay() {
            if (!COLLISION_FLASH_ON) return; // safety guard
            const overlayEl = mount.querySelector('#overlay');
            if (!overlayEl) return;
            // Cleanup previous group
            let g = overlayEl.querySelector('#gCollisionFlash');
            if (!COLLISION) { if (g) g.remove(); return; }
            const now = (performance && performance.now) ? performance.now() : Date.now();
            const t = Math.max(0, Math.min(1, (now - COLLISION.start) / (COLLISION.dur || 150)));
            const alpha = 0.9 * (1 - t);
            const ease = Math.sin(Math.PI * t);
            // World->screen scale via overlayLabels helper (fallback to 1)
            let sx = 1, sy = 1;
            try { const sc = overlayLabels.worldToScreen(0,0); sx = sc.sx || 1; sy = sc.sy || 1; } catch(_) {}
            const px = COLLISION.rect.x * sx;
            const py = COLLISION.rect.y * sy;
            const pw = Math.max(1, COLLISION.rect.l * sx);
            const ph = Math.max(1, COLLISION.rect.w * sy);
            // Direction in px normalized
            let dx = COLLISION.dir.x * sx;
            let dy = COLLISION.dir.y * sy;
            const len = Math.hypot(dx, dy) || 1;
            dx = (dx / len) * (COLLISION.amp || 8) * ease;
            dy = (dy / len) * (COLLISION.amp || 8) * ease;
            if (!g) {
              g = document.createElementNS('http://www.w3.org/2000/svg','g');
              g.setAttribute('id','gCollisionFlash');
              overlayEl.appendChild(g);
            } else {
              while (g.firstChild) g.removeChild(g.firstChild);
            }
            const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
            r.setAttribute('x', String(Math.round(px)));
            r.setAttribute('y', String(Math.round(py)));
            r.setAttribute('width', String(Math.round(pw)));
            r.setAttribute('height', String(Math.round(ph)));
            r.setAttribute('fill', 'none');
            r.setAttribute('stroke', '#ff4d4f');
            r.setAttribute('stroke-width', '2');
            r.setAttribute('opacity', String(alpha.toFixed(3)));
            r.setAttribute('pointer-events', 'none');
            r.setAttribute('transform', `translate(${dx.toFixed(2)}, ${dy.toFixed(2)})`);
            g.appendChild(r);

            if (t >= 1) {
              // Finish
              COLLISION = null;
              // Let the next frame clean the group
              collisionRAF = requestAnimationFrame(() => {
                try { const gg = overlayEl.querySelector('#gCollisionFlash'); gg && gg.remove(); } catch(_) {}
              });
            } else {
              collisionRAF = requestAnimationFrame(renderCollisionsOverlay);
            }
          }

          function bindItemEvents() {
          board.querySelectorAll("[data-rot]").forEach((c) => {
            c.addEventListener("pointerdown", (e) => {
              e.stopPropagation();
              const id = c.getAttribute("data-rot");
              state.selectedId = id;
              try { dispatchSelectionChange(); } catch (_) {}
              rotateSelected(+1);
            });
            // Hover: highlight matching overlay label
            c.addEventListener('mouseenter', () => {
              const id = c.getAttribute('data-rot');
              try { overlayLabels.setHotId(id); } catch(_) {}
            });
            c.addEventListener('mouseleave', () => {
              try { overlayLabels.setHotId(null); } catch(_) {}
            });
          });

            board.querySelectorAll("rect.item, rect.dragHit").forEach((r) => {
              r.addEventListener("pointerdown", (e) => {
                const id = r.getAttribute("data-id");
                state.selectedId = id;
                renderItems();
                try { dispatchSelectionChange(); } catch (_) {}
                const it = state.items.find((x) => x.id === id);
                const p = toSvgPoint(e);
                drag = {
                  id,
                  offXcm: p.x - it.x,
                  offYcm: p.y - it.y,
                  pre: { x: it.x, y: it.y },
                };
                try { r.setPointerCapture(e.pointerId); } catch(_) {}
                mount.classList.add("dragging");
              });
              r.addEventListener("keydown", (e) => {
                const step = vehicle().grid_cm;
                const it = state.items.find(
                  (x) => x.id === r.getAttribute("data-id")
                );
                if (!it) return;
                if (
                  [
                    "ArrowUp",
                    "ArrowDown",
                    "ArrowLeft",
                    "ArrowRight",
                    "Delete",
                    "Backspace",
                    "r",
                    "R",
                    "+",
                    "-",
                  ].includes(e.key)
                ) {
                  e.preventDefault();
                }
                if (e.key === "ArrowLeft") {
                  pushHistory();
                  it.x = Math.max(0, it.x - step);
                }
                if (e.key === "ArrowRight") {
                  pushHistory();
                  const { l } = dims2D(it);
                  it.x = Math.min(vehicle().inner_cm.L - l, it.x + step);
                }
                if (e.key === "ArrowUp") {
                  pushHistory();
                  it.y = Math.max(0, it.y - step);
                }
                if (e.key === "ArrowDown") {
                  pushHistory();
                  const { w } = dims2D(it);
                  it.y = Math.min(vehicle().inner_cm.W - w, it.y + step);
                }
                if (e.key === "Delete" || e.key === "Backspace") {
                  deleteSelected();
                }
                if (e.key === "r" || e.key === "R") {
                  rotateSelected(+1);
                }
                if (e.key === "+") {
                  changeStack(+1);
                }
                if (e.key === "-") {
                  changeStack(-1);
                }
                renderAll();
              });
              // Hover: show-only this label
              r.addEventListener('mouseenter', () => {
                const id = r.getAttribute('data-id');
                try { overlayLabels.setHotId(id); } catch(_) {}
              });
              r.addEventListener('mouseleave', () => {
                try { overlayLabels.setHotId(null); } catch(_) {}
              });
            });
            // Clear hover when leaving the board
            try {
              board.addEventListener('mouseleave', () => {
                try { overlayLabels.setHotId(null); } catch(_) {}
              });
            } catch(_) {}
          }

          // Keyboard controls on #viewport: arrows move ±1cm (Shift=±5cm), R toggles 0/90 with collision guard,
          // Delete removes, Esc cancels drag/pan/selection
          function installViewportKeys(){
            const vp = mount.querySelector('#viewport');
            if (!vp) return;
            vp.addEventListener('keydown', (e) => {
              const key = e.key;
              const it = state.items.find(x => x.id === state.selectedId);
              // Helpers
              function tryMove(dx, dy){
                if (!it) return;
                const v = vehicle();
                const d = dims2D(it);
                const nx = Math.max(0, Math.min(v.inner_cm.L - d.l, it.x + dx));
                const ny = Math.max(0, Math.min(v.inner_cm.W - d.w, it.y + dy));
                const cand = { x: nx, y: ny, l: d.l, w: d.w };
                let invalid = outOfBounds(cand, v);
                if (!invalid) {
                  for (const other of state.items) {
                    if (String(other.id) === String(it.id)) continue;
                    const od = dims2D(other);
                    const br = { x: other.x, y: other.y, l: od.l, w: od.w };
                    if (intersects(cand, br)) { invalid = true; break; }
                  }
                }
                if (invalid) {
                  try { triggerCollisionFlash(cand, { x: dx, y: dy }); } catch(_) {}
                } else {
                  pushHistory();
                  it.x = nx; it.y = ny;
                  renderAll();
                  dispatchSelectionChange();
                }
              }

              // Movement
              if (key === 'ArrowLeft' || key === 'ArrowRight' || key === 'ArrowUp' || key === 'ArrowDown') {
                e.preventDefault();
                const step = e.shiftKey ? 5 : 1; // cm
                let dx = 0, dy = 0;
                if (key === 'ArrowLeft') dx = -step;
                if (key === 'ArrowRight') dx = +step;
                if (key === 'ArrowUp') dy = -step;
                if (key === 'ArrowDown') dy = +step;
                tryMove(dx, dy);
                return;
              }

              // Rotate 0<->90
              if (key === 'r' || key === 'R') {
                e.preventDefault();
                rotateSelectedStrict();
                return;
              }

              // Delete selected
              if (key === 'Delete' || key === 'Backspace') {
                e.preventDefault();
                deleteSelected();
                return;
              }

              // Escape: cancel drag, pan, selection
              if (key === 'Escape') {
                e.preventDefault();
                try {
                  if (drag) {
                    const it2 = state.items.find(x => x.id === drag.id);
                    if (it2 && drag.pre) { it2.x = drag.pre.x; it2.y = drag.pre.y; }
                    drag = null; mount.classList.remove('dragging');
                  }
                } catch(_) {}
                try { document.dispatchEvent(new CustomEvent('vp-cancel-pan')); } catch(_) {}
                state.selectedId = null; renderAll(); dispatchSelectionChange();
                return;
              }
            });
          }

          // Click on section rectangles to select item
          section?.addEventListener("pointerdown", (e) => {
            const t = e.target;
            if (t && t.getAttribute && t.hasAttribute("data-id")) {
              state.selectedId = t.getAttribute("data-id");
              renderAll();
              dispatchSelectionChange();
            }
          });
          // Section hover: mirror hot label to corresponding item
          section?.addEventListener('pointermove', (e) => {
            const t = e.target;
            if (t && t.getAttribute && t.hasAttribute('data-id')) {
              try { overlayLabels.setHotId(t.getAttribute('data-id')); } catch(_) {}
            } else {
              try { overlayLabels.setHotId(null); } catch(_) {}
            }
          });
          section?.addEventListener('pointerleave', () => { try { overlayLabels.setHotId(null); } catch(_) {} });

          board.addEventListener("pointermove", (e) => {
            if (!drag) return;
            const id = state.selectedId;
            const it = state.items.find((x) => x.id === id);
            if (!it) return;
            const v = vehicle();
            const p = toSvgPoint(e);
            // Candidate position in world cm
            let nx = (p.x - drag.offXcm);
            let ny = (p.y - drag.offYcm);
            const { l, w } = dims2D(it);
            // 1) Snap to grid
            const gsn = computeSnapGrid(nx, ny, v.grid_cm);
            nx = gsn.x; ny = gsn.y;
            // 2) Snap to walls (after grid)
            const wsn = computeSnapWalls(nx, ny, l, w, v, 0.6);
            nx = wsn.x; ny = wsn.y;
            // 3) Snap to neighbor edges (only if walls didn’t snap)
            if (!wsn.snapped) {
              const esn = computeSnapEdges(nx, ny, l, w, state.items, id, v, 0.6);
              if (esn.snapped) { nx = esn.x; ny = esn.y; }
            }
            // Candidate rect
            const cand = { x: nx, y: ny, l, w };
            let invalid = outOfBounds(cand, v);
            if (!invalid) {
              for (const other of state.items) {
                if (String(other.id) === String(id)) continue;
                const d2 = dims2D(other);
                const br = { x: other.x, y: other.y, l: d2.l, w: d2.w };
                if (intersects(cand, br)) { invalid = true; break; }
              }
            }
            if (invalid) {
              // Block movement and show feedback
              const dir = { x: nx - it.x, y: ny - it.y };
              try { triggerCollisionFlash(cand, dir); } catch(_) {}
            } else {
              it.x = nx; it.y = ny;
            }
            board
              .querySelectorAll("rect.item")
              .forEach((n) => n.classList.remove("collide"));
            if (invalid)
              board
                .querySelector(`rect.item[data-id="${id}"]`)
                ?.classList.add("collide");
            renderItems();
            // live CoG/axle overlay + info update while dragging
            renderAxleOverlay();
            const axLive = computeAxleLoads(state.items, vehicle());
            const infoEl = mount.querySelector('#axleInfo');
            if (infoEl && axLive && axLive.totalKg) {
              const pctF = axLive.front_pct ? ` (${axLive.front_pct}%${axLive.front_pct>100?'!':''})` : '';
              const pctR = axLive.rear_pct ? ` (${axLive.rear_pct}%${axLive.rear_pct>100?'!':''})` : '';
              try {
                const frt = t('front_rear_total').split('•').map(s=>s.trim());
                const totL = frt[0] || 'Total';
                const fL = frt[1] || 'Front';
                const rL = frt[2] || 'Rear';
                infoEl.textContent = `${totL}: ${axLive.totalKg} kg • ${fL}: ${axLive.front_kg} kg${pctF} • ${rL}: ${axLive.rear_kg} kg${pctR}`;
              } catch(_) {
                infoEl.textContent = `Total: ${axLive.totalKg} kg • Front: ${axLive.front_kg} kg${pctF} • Rear: ${axLive.rear_kg} kg${pctR}`;
              }
            }
          });

          board.addEventListener("pointerup", (e) => {
            if (!drag) return;
            const id = drag.id;
            const it = state.items.find((x) => x.id === id);
            const invalid = !within(it, vehicle()) || anyCollision(it, id);
            if (invalid) {
              it.x = drag.pre.x;
              it.y = drag.pre.y;
            }
            pushHistory();
            drag = null;
            mount.classList.remove("dragging");
            renderAll();
            try { overlayLabels.updateAll(); } catch(_){}
          });

          // ===================== BULK PARSER — ULTRA v8 (dims+qty+kg, table+inline mix, RU/UA) =====================
          // Wspiera: pal/plt/pallet/palette/euro/epal/eur/ep oraz skrót **p** (kontekstowo).
          // Tryb tabelowy + wiersze inline: "1 400x150x150 862kg" oraz "1p 120x21x33" w tym samym polu.
          // Usuwa nadmiarowe spacje/entery wizualnie (nie psuje treści).

          // ——— USTAWIENIA ———
          const H_POLICY_DEFAULT = "hybrid"; // 'strict'|'zero'|'default'|'by_type'|'infer_layers'|'hybrid'
          const H_DEFAULT_CM = 160;
          const PALLET_ADD_HEIGHT_CM = 14.4;
          const MIN_DIM_MM = 30,
            MAX_DIM_MM = 5000;
          const CONF_LOW = 0.7;

          // ——— POMOCE ———
          function normDec(s) {
            return parseFloat(String(s).replace(/\s+/g, "").replace(",", "."));
          }
          function toCm(v, u) {
            if (!u) return v;
            const x = u.toLowerCase();
            if (x === "cm") return v;
            if (x === "mm") return v / 10;
            if (x === "m") return v * 100;
            if (x === "in" || x === '"' || x === "″") return v * 2.54;
            if (
              x === "ft" ||
              x === "'" ||
              x === "′" ||
              x === "фт" ||
              x === "фут"
            )
              return v * 30.48;
            return v;
          }
          function clampMm(vmm) {
            return vmm < MIN_DIM_MM || vmm > MAX_DIM_MM ? null : vmm;
          }
          function mmFromCm(cm) {
            return Math.round(cm * 10);
          }
          function within(v, min, max) {
            return v >= min && v <= max;
          }
          function isEURDims(L, W) {
            const a = [L, W].sort((x, y) => y - x);
            return within(a[0], 119, 121) && within(a[1], 79, 81);
          }

          // ——— PRE‑NORMALIZACJA ———
          function preNormalize(text) {
            let s = String(text || "");
            s = s
              .replace(/[хХ]/g, "x")
              .replace(/\bмм\b/gi, "mm")
              .replace(/\bсм\b/gi, "cm")
              .replace(/\bм\b/gi, "m");
            s = s.replace(/(\d)\s*(?:na|на|by|per|auf)\s*(\d)/gi, "$1x$2"); // 50na30
            s = s.replace(/(\d)(mm|cm|m|in|("|″)|ft|('|′))/gi, "$1 $2"); // 80cm → 80 cm
            s = s.replace(/(\d)(?=[A-Za-z\u00C0-\u024F\u0400-\u04FF])/g, "$1 "); // 4ep→4 ep, 10p→10 p
            s = s.replace(/(\d)\s+(?=\d{3}\b)/g, "$1"); // 12 000 → 12000
            return s;
          }
          function tidyWhitespaceVisual(v) {
            return String(v)
              .replace(/[ \t]{2,}/g, " ")
              .replace(/(\r?\n){2,}/g, "\n");
          }
          function sanitizeForLogistics(text) {
            return preNormalize(text)
              .replace(
                /\b\d[\d\s.,]*\s*(?:zł|pln|eur|€|\$|usd|uah|₴|rub|₽)\b/gi,
                " "
              )
              .replace(/\b\d{1,2}[./-]\d{1,2}(?:[./-]\d{2,4})?\b/g, " ")
              .replace(/\b\d{4}[./-]\d{1,2}[./-]\d{1,2}\b/g, " ")
              .replace(/\b\d{1,2}:\d{2}\b/g, " ")
              .replace(/\b(?:\+?\d[\d\-.\s()]{6,})\b/g, " ")
              .replace(/(?:#|nr\.?\s*)\d[\d/.-]*/gi, " ");
          }

          // ——— SŁOWNIKI ———
          const UNIT_ANY = "(?:mm|cm|m|in|\"|″|ft|'|′)";
          const XSEP = "(?:x|×|\\*|·|/)";
          const NUM = "\\d+(?:[.,]\\d+)?";
          const HEIGHT_KEYS =
            "(?:h|ht|hgt|wys\\.?|выс\\.?|вис\\.?|высота|висота|вис)";

          const TYPE_TOKEN = {
            pallet:
              /\b(?:pal(?:et|ety|eta)?|plt|pallet|palette|euro|epal|eur|ep|поддон|палет|палета|паллета|піддон|європалета|європіддон|европоддон)\b/i,
            box: /\b(?:box|karton|ctn|case|colli|короб|коробка|ящик|ящ\.)\b/i,
            roll: /\b(?:roll|rolka|rolki|рулон)\b/i,
            bag: /\b(?:bag|worek|мешок|мішок)\b/i,
            drum: /\b(?:drum|beczka|barrel|бочка)\b/i,
            ibc: /\b(?:ibc|paletopojemnik|еврокуб|єврокуб)\b/i,
          };
          // „p” rozpoznajemy kontekstowo (blisko liczby i wymiarów) w typeNear().

          // ——— BAZY PALET ———
          function palletBaseFromSeg(seg) {
            const s = seg.toLowerCase();
            const half =
              /(pół|pol|half|полу|пів|1\/2|eur6|d[üu]sseldorf|dus)\b/i.test(s);
            const quart = /(ćwier|quarter|четверть|1\/4|чверть)\b/i.test(s);
            if (half) return { code: "EUR6", Lcm: 80, Wcm: 60 };
            if (quart) return { code: "QEUR", Lcm: 60, Wcm: 40 };
            if (/\b(eur2|przem|industrial|uk|fin)\b/i.test(s))
              return { code: "EUR2", Lcm: 120, Wcm: 100 };
            if (/\b(eur|epal|euro|ep)\b/i.test(s))
              return { code: "EUR1", Lcm: 120, Wcm: 80 };
            if (/\b(chep)\b/i.test(s) && /\buk\b/i.test(s))
              return { code: "CHEP-1200x1000", Lcm: 120, Wcm: 100 };
            if (/\b(chep)\b/i.test(s))
              return { code: "CHEP-1200x800", Lcm: 120, Wcm: 80 };
            if (/\b(48\s*x\s*40|40\s*x\s*48|gma|usa|сша)\b/i.test(s))
              return { code: "US-48x40", Lcm: 121.9, Wcm: 101.6 };
            if (/\b(iso|1100\s*x\s*1100|asia|азиат)\b/i.test(s))
              return { code: "ISO-1100x1100", Lcm: 110, Wcm: 110 };
            return { code: "", Lcm: null, Wcm: null };
          }
          function palletDimsByCode(code) {
            switch ((code || "").toUpperCase()) {
              case "EUR1":
                return { Lcm: 120, Wcm: 80 };
              case "EUR2":
                return { Lcm: 120, Wcm: 100 };
              case "EUR3":
                return { Lcm: 120, Wcm: 100 };
              case "EUR6":
                return { Lcm: 80, Wcm: 60 };
              case "QEUR":
                return { Lcm: 60, Wcm: 40 };
              case "CHEP-1200X800":
                return { Lcm: 120, Wcm: 80 };
              case "CHEP-1200X1000":
                return { Lcm: 120, Wcm: 100 };
              case "US-48X40":
                return { Lcm: 121.9, Wcm: 101.6 };
              case "ISO-1100X1100":
                return { Lcm: 110, Wcm: 110 };
              case "FIN":
                return { Lcm: 120, Wcm: 100 };
              default:
                return { Lcm: null, Wcm: null };
            }
          }
          function defaultHByType(code) {
            if (code === "EUR6") return 90;
            if (code === "QEUR") return 60;
            return 160;
          }

          // ——— WYMIARY (globalne z indeksami) ———
          const TRIPLE_ANY_G = new RegExp(
            String.raw`(?<a>${NUM})\s*(?<ua>${UNIT_ANY})?\s*${XSEP}\s*(?<b>${NUM})\s*(?<ub>${UNIT_ANY})?\s*${XSEP}\s*(?<c>${NUM})\s*(?<uc>${UNIT_ANY})?`,
            "ig"
          );
          const SPACE_TRIPLE_G = new RegExp(
            String.raw`(?<a>${NUM})\s+(?<b>${NUM})\s+(?<c>${NUM})(?:\s*(?<u>${UNIT_ANY}))?`,
            "ig"
          );
          const LABELED_G = new RegExp(
            String.raw`(?:l|len|dł|dl|д|довжина)\s*[:=]?\s*(?<a>${NUM})\s*(?<ua>${UNIT_ANY})?.{0,12}(?:w|szer|b|breite|ш|ширина)\s*[:=]?\s*(?<b>${NUM})\s*(?<ub>${UNIT_ANY})?.{0,12}(?:h|wys|höhe|в|высота|висота)\s*[:=]?\s*(?<c>${NUM})\s*(?<uc>${UNIT_ANY})?`,
            "ig"
          );
          const DOUBLE_ANY_G = new RegExp(
            String.raw`(?<a>${NUM})\s*(?<ua>${UNIT_ANY})?\s*${XSEP}\s*(?<b>${NUM})\s*(?<ub>${UNIT_ANY})?`,
            "ig"
          );
          const DIAM_G = new RegExp(
            String.raw`(?:ø|⌀|phi|diam(?:eter)?|диаметр|діаметр)\s*(?<d>${NUM})\s*(?<ud>${UNIT_ANY})?\s*(?:${XSEP}|x)\s*(?<l>${NUM})\s*(?<ul>${UNIT_ANY})?`,
            "ig"
          );
          const HEIGHT_ONLY = new RegExp(
            String.raw`(?:^|[^\w])(?:${HEIGHT_KEYS})\s*[:=]?\s*(?<h>${NUM})\s*(?<uh>${UNIT_ANY})?(?:\b|$)`,
            "i"
          );

          // ——— ILOŚĆ ———
          function qtyNear(seg, idxStart) {
            const L = Math.max(0, idxStart - 60);
            const ctx = seg.slice(L, idxStart + 1);
            let m = ctx.match(
              /\b(\d+)\s*(?:warstw|warstwy|сло[йя]|уровн\w+|шар(?:и)?|рівн\w+)\b.*?\bpo\s*(\d+)\b/i
            );
            if (m) return parseInt(m[1], 10) * parseInt(m[2], 10);
            m = ctx.match(
              /\b(\d+)\s*x\s*(?:pal(?:et|ety|eta)?|plt|pallet|palette|euro|epal|eur|ep|p|szt|pcs|шт|ctn|box)\b/i
            );
            if (m) return parseInt(m[1], 10);
            m = ctx.match(
              /\b(\d+)\s*(?:pal(?:et|ety|eta)?|plt|pallet|palette|euro|epal|eur|ep|p|szt|pcs|шт|ctn|box)\b/i
            );
            if (m) return parseInt(m[1], 10);
            return 1;
          }

          // ——— TYP (z 'p' kontekstowo) ———
          function typeNear(seg, idxStart) {
            const L = Math.max(0, idxStart - 60);
            const ctx = seg.slice(L, idxStart + 1);
            let unit_type = null;
            for (const [kind, rx] of Object.entries(TYPE_TOKEN)) {
              if (rx.test(ctx)) {
                unit_type = kind;
                break;
              }
            }
            if (!unit_type && /\b\d+\s*p\b/i.test(ctx)) unit_type = "pallet";
            let code = "";
            if (unit_type === "pallet") code = palletBaseFromSeg(ctx).code;
            return { unit_type, code };
          }

          // ——— WYSOKOŚĆ ———
          function parseHeightAround(seg, idxStart) {
            const R = Math.min(seg.length, idxStart + 60);
            const right = seg.slice(idxStart, R);
            let m = right.match(HEIGHT_ONLY);
            if (!m) {
              const L = Math.max(0, idxStart - 60);
              const left = seg.slice(L, idxStart);
              m = left.match(HEIGHT_ONLY);
            }
            if (!m) return null;
            const h = toCm(normDec(m.groups.h), m.groups.uh || null);
            return clampMm(mmFromCm(h)) == null ? null : h;
          }

          // ——— WAGA ———
          function weightNear(seg, idxStart, qty) {
            const L = Math.max(0, idxStart - 60);
            const R = Math.min(seg.length, idxStart + 80);
            const ctx = seg.slice(L, R);
            let m = ctx.match(
              new RegExp(
                String.raw`(?:po|per|na)\s*(${NUM})\s*(?:kg|кг)\b`,
                "i"
              )
            );
            if (m) return { unit_w: normDec(m[1]), total_w: null };
            m = ctx.match(new RegExp(String.raw`(${NUM})\s*(?:kg|кг)\b`, "i"));
            if (m) {
              const v = normDec(m[1]);
              return qty <= 1
                ? { unit_w: v, total_w: null }
                : { unit_w: null, total_w: v };
            }
            m = ctx.match(new RegExp(String.raw`(?:kg|кг)\s*(${NUM})\b`, "i"));
            if (m) {
              const v = normDec(m[1]);
              return qty <= 1
                ? { unit_w: v, total_w: null }
                : { unit_w: null, total_w: v };
            }
            m = ctx.match(
              new RegExp(
                String.raw`(${NUM})\s*(?:kg|кг)\s*/\s*(?:pal(?:et|ety|eta)?|plt|pallet|pcs?|szt|шт|p)\b`,
                "i"
              )
            );
            if (m) return { unit_w: normDec(m[1]), total_w: null };
            m = ctx.match(
              new RegExp(
                String.raw`(?:total|gross|brutto|netto)\s*(${NUM})\s*(?:kg|кг|t)\b`,
                "i"
              )
            );
            if (m) {
              let v = normDec(m[1]);
              if (/t\b/i.test(m[0])) v *= 1000;
              return { unit_w: null, total_w: v };
            }
            return { unit_w: null, total_w: null };
          }

          // ——— WYMIARY: znajdź wszystkie wystąpienia ———
          function findAllDims(seg) {
            const found = [];
            function pushTriple(m, idx) {
              let a = normDec(m.groups.a),
                b = normDec(m.groups.b),
                c = normDec(m.groups.c);
              const ua = m.groups.ua,
                ub = m.groups.ub,
                uc = m.groups.uc;
              let L = toCm(a, ua || uc || null),
                W = toCm(b, ub || uc || null),
                H = toCm(c, uc || null);
              if (!ua && !ub && !uc && [L, W, H].every((v) => v >= 300))
                [L, W, H] = [L / 10, W / 10, H / 10];
              if ([L, W, H].every((v) => clampMm(mmFromCm(v)) != null))
                found.push({
                  start: idx,
                  end: idx + m[0].length,
                  L: Math.max(L, W),
                  W: Math.min(L, W),
                  H,
                  conf: 0.9,
                });
            }
            function pushSpaceTriple(m, idx) {
              let a = normDec(m.groups.a),
                b = normDec(m.groups.b),
                c = normDec(m.groups.c);
              const u = m.groups.u || null;
              if (u) {
                a = toCm(a, u);
                b = toCm(b, u);
                c = toCm(c, u);
              } else if ([a, b, c].every((v) => v >= 300)) {
                a /= 10;
                b /= 10;
                c /= 10;
              }
              if ([a, b, c].every((v) => clampMm(mmFromCm(v)) != null))
                found.push({
                  start: idx,
                  end: idx + m[0].length,
                  L: Math.max(a, b),
                  W: Math.min(a, b),
                  H: c,
                  conf: 0.8,
                });
            }
            function pushDouble(m, idx) {
              let a = normDec(m.groups.a),
                b = normDec(m.groups.b);
              const ua = m.groups.ua,
                ub = m.groups.ub;
              let L = toCm(a, ua || ub || null),
                W = toCm(b, ub || ua || null);
              if ([L, W].every((v) => clampMm(mmFromCm(v)) != null))
                found.push({
                  start: idx,
                  end: idx + m[0].length,
                  L: Math.max(L, W),
                  W: Math.min(L, W),
                  H: null,
                  conf: 0.65,
                });
            }
            function pushLabeled(m, idx) {
              const a = toCm(normDec(m.groups.a), m.groups.ua),
                b = toCm(normDec(m.groups.b), m.groups.ub),
                c = toCm(normDec(m.groups.c), m.groups.uc);
              if ([a, b, c].every((v) => clampMm(mmFromCm(v)) != null))
                found.push({
                  start: idx,
                  end: idx + m[0].length,
                  L: Math.max(a, b),
                  W: Math.min(a, b),
                  H: c,
                  conf: 0.95,
                });
            }
            function pushDiam(m, idx) {
              const d = toCm(normDec(m.groups.d), m.groups.ud),
                l = toCm(normDec(m.groups.l), m.groups.ul);
              if ([d, l].every((v) => clampMm(mmFromCm(v)) != null))
                found.push({
                  start: idx,
                  end: idx + m[0].length,
                  L: Math.max(d, l),
                  W: Math.min(d, l),
                  H: null,
                  dia: d,
                  conf: 0.8,
                });
            }
            for (const m of seg.matchAll(TRIPLE_ANY_G)) pushTriple(m, m.index);
            for (const m of seg.matchAll(LABELED_G)) pushLabeled(m, m.index);
            for (const m of seg.matchAll(DIAM_G)) pushDiam(m, m.index);
            for (const m of seg.matchAll(SPACE_TRIPLE_G))
              pushSpaceTriple(m, m.index);
            for (const m of seg.matchAll(DOUBLE_ANY_G)) pushDouble(m, m.index);

            found.sort((a, b) => a.start - b.start || b.conf - a.conf);
            const dedup = [];
            for (const f of found) {
              if (dedup.some((d) => !(f.end <= d.start || f.start >= d.end)))
                continue;
              dedup.push(f);
            }
            return dedup;
          }

          // ——— TRYB TABELA (również inline) ———
          const TABLE_HDR_RX =
            /\b(pallets?|palety|поддоны|піддони)\b|\b(length|width|height|weight|waga|длина|ширина|высота|довжина|висота|höhe|breite|länge)\b/i;
          function guessTableUnit(raw) {
            if (/\bmm\)/i.test(raw) || /\bmm\b/i.test(raw)) return "mm";
            if (/\bcm\)/i.test(raw) || /\bcm\b/i.test(raw)) return "cm";
            if (
              /\bm\)/i.test(raw) &&
              !/\bmm\b/i.test(raw) &&
              !/\bcm\b/i.test(raw)
            )
              return "m";
            return "cm";
          }
          function headerSuggestsUnitWeight(raw) {
            return /\b(per\s*(?:pallet|piece|pcs?)|kg\/(?:pal|plt|pcs?|szt)|waga\s*szt|weight\s*per)\b/i.test(
              raw
            );
          }
          function extractTableSegments(raw) {
            if (!TABLE_HDR_RX.test(raw)) return [];
            const unit = guessTableUnit(raw);
            const unitIsPer = headerSuggestsUnitWeight(raw);
            const used = [];
            const segs = [];
            const NUMR = `${NUM}`;
            function isFree(i, len) {
              return !used.some((r) => !(i + len <= r[0] || i >= r[1]));
            }
            function mark(i, len) {
              used.push([i, i + len]);
            }

            // qty + L + W + H (+ kg) — pionowo lub spacjami
            const RE_Q_LWH = new RegExp(
              String.raw`\b(?<qty>\d{1,4})\s*[\r\n\t ]+\s*(?<L>${NUMR})\s*[\r\n\t ]+\s*(?<W>${NUMR})\s*[\r\n\t ]+\s*(?<H>${NUMR})(?:\s*[\r\n\t ]+(?<kg>(?:${NUMR})))?`,
              "g"
            );
            for (const m of raw.matchAll(RE_Q_LWH)) {
              const idx = m.index,
                len = m[0].length;
              if (!isFree(idx, len)) continue;
              let q = parseInt(m.groups.qty, 10);
              let L = toCm(normDec(m.groups.L), unit),
                W = toCm(normDec(m.groups.W), unit),
                H = toCm(normDec(m.groups.H), unit);
              if ([L, W, H].some((v) => clampMm(mmFromCm(v)) == null)) continue;
              const kg = m.groups.kg ? Math.round(normDec(m.groups.kg)) : null;
              const kgStr = kg != null ? ` kg ${kg}` : "";
              segs.push(
                `${q} p ${Math.round(L)}x${Math.round(W)}x${Math.round(
                  H
                )} ${unit}${kgStr}${unitIsPer ? " /p" : ""}`
              );
              mark(idx, len);
            }

            // L + W + H (+ kg) → domyślnie qty=1
            const RE_LWH = new RegExp(
              String.raw`\b(?<L>${NUMR})\s*[\r\n\t ]+\s*(?<W>${NUMR})\s*[\r\n\t ]+\s*(?<H>${NUMR})(?:\s*[\r\n\t ]+(?<kg>(?:${NUMR})))?`,
              "g"
            );
            for (const m of raw.matchAll(RE_LWH)) {
              const idx = m.index,
                len = m[0].length;
              if (!isFree(idx, len)) continue;
              let L = toCm(normDec(m.groups.L), unit),
                W = toCm(normDec(m.groups.W), unit),
                H = toCm(normDec(m.groups.H), unit);
              if ([L, W, H].some((v) => clampMm(mmFromCm(v)) == null)) continue;
              const kg = m.groups.kg ? Math.round(normDec(m.groups.kg)) : null;
              const kgStr = kg != null ? ` kg ${kg}` : "";
              segs.push(
                `1 p ${Math.round(L)}x${Math.round(W)}x${Math.round(
                  H
                )} ${unit}${kgStr}${unitIsPer ? " /p" : ""}`
              );
              mark(idx, len);
            }

            // **NOWE**: wiersz inline "1 400x150x150 862kg" lub "1 400x150x150 kg 862"
            const RE_INLINE = new RegExp(
              String.raw`\b(?<qty>\d{1,4})\s+(?<L>${NUMR})\s*(?:x|×|\*|\/)\s*(?<W>${NUMR})\s*(?:x|×|\*|\/)\s*(?<H>${NUMR})(?:\s*(?:kg|кг)\s*(?<kg1>${NUMR})|\s*(?<kg2>${NUMR})\s*(?:kg|кг))?`,
              "gi"
            );
            for (const m of raw.matchAll(RE_INLINE)) {
              const idx = m.index,
                len = m[0].length;
              if (!isFree(idx, len)) continue;
              const q = parseInt(m.groups.qty, 10);
              let L = toCm(normDec(m.groups.L), unit),
                W = toCm(normDec(m.groups.W), unit),
                H = toCm(normDec(m.groups.H), unit);
              if ([L, W, H].some((v) => clampMm(mmFromCm(v)) == null)) continue;
              const kg = m.groups.kg1
                ? Math.round(normDec(m.groups.kg1))
                : m.groups.kg2
                ? Math.round(normDec(m.groups.kg2))
                : null;
              const kgStr = kg != null ? ` kg ${kg}` : "";
              segs.push(
                `${q} p ${Math.round(L)}x${Math.round(W)}x${Math.round(
                  H
                )} ${unit}${kgStr}${unitIsPer ? " /p" : ""}`
              );
              mark(idx, len);
            }

            return segs;
          }

          // ——— FLAGI ———
          const STACK_POS =
            /\b(?:piętrow|pietrow|stack(?:able)?|stack all|stacking allowed|штабел|stackuj)\b/i;
          const STACK_NEG =
            /\b(?:nie\s*piętrow|nie\s*pietrow|non-?stack|no stack|не\s*штаб)\b/i;
          function detectStackFlags(seg) {
            return { pos: STACK_POS.test(seg), neg: STACK_NEG.test(seg) };
          }
          function hasNoPallet(seg) {
            return /\b(?:bez palety|bez\s*poddona|без\s*поддона|без\s*палеты|без\s*палети|без\s*піддона)\b/i.test(
              seg
            );
          }

          // ——— GŁÓWNA FUNKCJA ———
          function extractLogistics(raw) {
            const original = String(raw || "");
            const text = sanitizeForLogistics(original);
            const low = text.toLowerCase();

            // segmenty klasyczne + pseudo‑segmenty z tabel (także inline)
            const segA = low
              .split(/[\n;•]+|(?<!\d)[,.](?!\d)/g)
              .map((s) => s.trim())
              .filter(Boolean);
            const tableSegs = extractTableSegments(original);
            const segments = segA.concat(tableSegs);

            const items = [];
            const orderKeys = [];

            for (const seg of segments) {
              const dimsList = findAllDims(seg);
              if (!dimsList.length) continue;

              const stack = detectStackFlags(seg);
              const addPal = hasNoPallet(seg);

              for (const d of dimsList) {
                let { unit_type: ut, code } = typeNear(seg, d.start);
                // jeśli mamy nagłówki tabeli w całym tekście i brak typu → załóż paletę
                if (!ut && tableSegs.length) {
                  ut = "pallet";
                  code = code || palletBaseFromSeg(seg).code;
                }

                if (
                  !ut &&
                  !/(?:wymiary|rozmiar|dimension|größe|размер|розмір)/i.test(
                    seg
                  )
                )
                  continue;

                const qty = qtyNear(seg, d.start);
                let L = d.L,
                  W = d.W,
                  H = d.H;
                const diameter = d.dia || null;

                const w = weightNear(seg, d.start, qty);

                // paleta → baza
                let pallet_code = code;
                if (ut === "pallet" && (L == null || W == null)) {
                  const b = palletBaseFromSeg(seg);
                  pallet_code = b.code || code;
                  if (b.Lcm && b.Wcm) {
                    L = b.Lcm;
                    W = b.Wcm;
                  }
                }

                // H polityka
                if (H == null) {
                  if (ut === "pallet") {
                    if (H_POLICY_DEFAULT === "by_type")
                      H = defaultHByType(pallet_code);
                    else if (H_POLICY_DEFAULT === "default") H = H_DEFAULT_CM;
                    else if (H_POLICY_DEFAULT === "hybrid")
                      H = defaultHByType(pallet_code) ?? H_DEFAULT_CM;
                    else if (H_POLICY_DEFAULT === "zero") H = 0;
                    else {
                      const hLocal = parseHeightAround(seg, d.start);
                      if (hLocal != null) H = hLocal;
                    }
                  } else {
                    const hLocal = parseHeightAround(seg, d.start);
                    H =
                      hLocal != null
                        ? hLocal
                        : H_POLICY_DEFAULT === "zero"
                        ? 0
                        : null;
                  }
                }

                if (addPal && H != null) H += PALLET_ADD_HEIGHT_CM;

                const plausible =
                  (L == null || clampMm(mmFromCm(L)) != null) &&
                  (W == null || clampMm(mmFromCm(W)) != null) &&
                  (H == null || clampMm(mmFromCm(H)) != null);
                const conf = d.conf || 0.7;
                const needs_review = !plausible || conf < CONF_LOW ? 1 : 0;

                const item = {
                  idx: d.start,
                  type: ut || "other",
                  subtype:
                    ut === "pallet" ? pallet_code || "unknown" : "unknown",
                  qty,
                  length_cm: L != null ? Math.round(L) : null,
                  width_cm:
                    W != null
                      ? Math.round(W)
                      : diameter != null
                      ? Math.round(diameter)
                      : null,
                  height_cm: H != null ? Math.round(H) : null,
                  diameter_cm: diameter != null ? Math.round(diameter) : null,
                  unit_weight_kg:
                    w.unit_w != null ? Math.round(w.unit_w) : null,
                  total_weight_kg:
                    w.total_w != null ? Math.round(w.total_w) : null,
                  stackable: stack.neg ? false : stack.pos ? true : null,
                  notes: addPal ? "bez palety +14.4 cm" : "",
                  lang: /[а-яёіїєґ]/i.test(seg) ? "ru/uk" : "pl/en/de",
                  confidence: Math.max(0, Math.min(1, conf)),
                  needs_review,
                };

                items.push(item);
                orderKeys.push({
                  key: `${item.type}|${item.subtype}|${item.length_cm}|${
                    item.width_cm
                  }|${item.height_cm || 0}`,
                  idx: item.idx,
                });
              }
            }

            // AGREGACJA z zachowaniem kolejności
            const order = [];
            const seen = new Set();
            for (const g of orderKeys) {
              if (!seen.has(g.key)) {
                seen.add(g.key);
                order.push(g.key);
              }
            }
            const grouped = new Map();
            for (const it of items) {
              const k = `${it.type}|${it.subtype}|${it.length_cm}|${
                it.width_cm
              }|${it.height_cm || 0}`;
              if (grouped.has(k)) {
                const x = grouped.get(k);
                x.qty += it.qty;
                x.needs_review |= it.needs_review;
                x.confidence = Math.min(x.confidence, it.confidence);
                if (
                  x.unit_weight_kg != null &&
                  it.unit_weight_kg != null &&
                  x.unit_weight_kg !== it.unit_weight_kg
                )
                  x.needs_review = 1;
                if (it.total_weight_kg != null)
                  x.total_weight_kg =
                    (x.total_weight_kg || 0) + it.total_weight_kg;
              } else grouped.set(k, { ...it });
            }
            const aggregated = order
              .map((k) => {
                for (const [gk, val] of grouped.entries()) {
                  if (gk.endsWith(k.split("|").slice(2).join("|"))) return val;
                }
                return null;
              })
              .filter(Boolean);

            return { items: aggregated, warnings: [] };
          }

          // ——— PODGLĄD ———
          function prettyExtractPreview(res) {
            if (!res.items.length) return t('no_items');
            return res.items
              .map((it) => {
                const qty = it.qty || 1;
                const dims = it.diameter_cm
                  ? `${it.diameter_cm}Ø×${it.length_cm || 0}`
                  : `${it.length_cm || 0}x${it.width_cm || 0}x${
                      it.height_cm || 0
                    }`;
                const kind = (function(){
                  if (it.type !== 'pallet') return it.type;
                  if (it.subtype === 'EUR6') return t('pallet_half');
                  if (it.subtype === 'QEUR') return t('pallet_quarter');
                  return t('pallet');
                })();
                const w =
                  it.unit_weight_kg != null
                    ? ` • ${it.unit_weight_kg} ${t('kg_per_pc')}`
                    : it.total_weight_kg != null
                    ? ` • ${it.total_weight_kg} kg ${t('total_note')}`
                    : "";
                const flag = it.needs_review ? ` • △ ${t('check_flag')}` : "";
                return `${qty} ${kind} ${dims}${w}${flag}`;
              })
              .join("\n");
          }


          function applyExtractedItems(items) {
            if (!items || !items.length) return false;
            pushHistory();
            for (const it of items) {
              const qty = Math.max(1, it.qty || 1);

              let L = it.length_cm,
                W = it.width_cm,
                H = it.height_cm;
              if ((L == null || W == null) && it.type === "pallet") {
                const base = palletDimsByCode(it.subtype || "");
                if (!L && base.Lcm != null) L = base.Lcm;
                if (!W && base.Wcm != null) W = base.Wcm;
              }
              if (H == null) {
                if (it.type === "pallet")
                  H =
                    defaultHByType((it.subtype || "").toString()) ??
                    H_DEFAULT_CM;
                else H = 0;
              }

              const perKg =
                it.unit_weight_kg != null
                  ? it.unit_weight_kg
                  : it.total_weight_kg != null && qty > 0
                  ? Math.round(it.total_weight_kg / qty)
                  : 0;

              let nodeType = "custom";
              if (
                it.type === "pallet" &&
                (/eur|epal|ep/i.test(it.subtype || "") || isEURDims(L, W))
              )
                nodeType = "eur_pallet";

              L = Math.round(L ?? 120);
              W = Math.round(W ?? (it.diameter_cm || 80));
              H = Math.round(H ?? (it.diameter_cm || 80));

              for (let i = 0; i < qty; i++) {
                const node = {
                  id: uid(),
                  type: nodeType,
                  L,
                  W,
                  H,
                  weight: Math.round(perKg || 0),
                  stackable: it.stackable == null ? true : !!it.stackable,
                  stackCount: 1,
                  x: 0,
                  y: 0,
                  rot: 0,
                  flags: (it.stackable === false) ? { noStack: true } : {}
                };
                placeNewItem(node);
                state.items.push(node);
              }
            }
            // Auto‑pack immediately after bulk add
            autopackUltra(0, true);
            return true;
          }

          // ——— SPINANIE Z UI ———
          bulkText.addEventListener("input", () => {
            const txt = bulkText.value || "";
            const res = extractLogistics(txt);
            if (res.items && res.items.length) {
              bulkOut.textContent = prettyExtractPreview(res);
            } else {
              // Fallback to MEGA‑PROMPT lightweight parser preview
              try {
                const fallbackItems = parseRawText(txt) || [];
                bulkOut.textContent = prettyExtractPreview({ items: fallbackItems });
              } catch {
                bulkOut.textContent = prettyExtractPreview({ items: [] });
              }
            }
          });
          bulkText.addEventListener("paste", () =>
            setTimeout(() => {
              bulkText.value = tidyWhitespaceVisual(bulkText.value);
            }, 0)
          );
          bulkText.addEventListener("blur", () => {
            bulkText.value = tidyWhitespaceVisual(bulkText.value);
          });

          bulkAdd.addEventListener("click", () => {
            const txt = bulkText.value || "";
            const res = extractLogistics(txt);
            let items = (res && res.items) ? res.items : [];
            if (!items.length) {
              // Fallback to MEGA‑PROMPT lightweight parser application
              try {
                const fallbackItems = parseRawText(txt) || [];
                if (fallbackItems.length) {
                  items = fallbackItems;
                }
              } catch {}
            }
            if (!items.length) {
              showError("Nie wykryto żadnych pozycji");
              return;
            }
            applyExtractedItems(items);
          });

          // View toggle 2D/3D
          // Init aria-pressed state for 2D/3D toggle
  try { if (view3DBtn) view3DBtn.setAttribute('aria-pressed', String(state.viewMode === '3d')); } catch(_) {}
  view3DBtn?.addEventListener("click", () => {
            const to3d = state.viewMode !== "3d";
            state.viewMode = to3d ? "3d" : "2d";
            view3DBtn.textContent = to3d ? ("🗺️ " + t('top2d')) : ("🎥 " + t('view_3d'));
            try { view3DBtn.setAttribute('aria-pressed', String(to3d)); } catch(_) {}
            renderAll();
            try { overlayLabels.updateAll(); } catch(_){}
            // Focus management: move focus to active viewport
            try {
              if (to3d) {
                view3d?.setAttribute('tabindex','0');
                view3d?.focus();
              } else {
                board?.focus();
              }
            } catch(_) {}
  });
  // Sketch/Illustration mode toggle
  const sketchBtn = mount.querySelector('#sketch3D');
  try { sketchBtn?.setAttribute('aria-pressed', String(!!(threeCtx && threeCtx.state && threeCtx.state.sketch))); } catch(_) {}
  sketchBtn?.addEventListener('click', () => {
    try { threeInit(); } catch(_) {}
    try {
      const on = !threeCtx.state.sketch;
      threeSetSketch(on);
      sketchBtn.setAttribute('aria-pressed', String(on));
    } catch(_) {}
  });
          // Mobile: bottom sheet toggle
          toggleSheetBtn?.addEventListener('click', () => {
            if (mount.getAttribute('data-device') !== 'mobile') return;
            const side = mount.querySelector('.side');
            if (!side) return;
            side.classList.toggle('open');
          });
          // Mobile PDF export -> print
          pdfBtn?.addEventListener('click', () => {
            try { window.print(); } catch(_) {}
          });
          window.addEventListener("resize", () => {
            applyDevice();
            if (state.viewMode === "3d") render3D();
            // Re-render items to recalc compact labels on zoom/resize
            renderItems();
            renderSection();
            try { overlayLabels.updateAll(); } catch(_) {}
            try { render(); } catch(_) {}
          });
          // Grid toggle wiring (button -> hidden checkbox)
          try {
            const gridBtn = mount.querySelector('#toggleGrid');
            const gridCb  = mount.querySelector('#gridToggle');
            gridBtn?.addEventListener('click', () => {
              if (!gridCb) return;
              gridCb.checked = !gridCb.checked;
              try { render(); } catch(_) {}
              updateStatus();
            });
          } catch(_) {}
          // Wire expanders (nowoczesne rozwijanie)
          try {
            function wireExpander(box){
              if (!box) return;
              const head = box.querySelector('.expander-head');
              const body = box.querySelector('.expander-body');
              // Przyciski akcji w nagłówku nie mogą rozwijać/zamykać
              try {
                box.querySelectorAll('.expander-head .head-actions button')
                  .forEach(b => b.addEventListener('click', (e)=> e.stopPropagation()));
              } catch(_) {}
              const setOpen = (on)=>{
                box.setAttribute('data-open', on ? 'true':'false');
                head?.setAttribute('aria-expanded', String(!!on));
                if (!body) return;
                // płynna animacja max-height
                if (on){
                  body.style.maxHeight = body.scrollHeight + 'px';
                } else {
                  body.style.maxHeight = '0px';
                }
              };
              head?.addEventListener('click', ()=> setOpen(box.getAttribute('data-open')!== 'true'));
              head?.addEventListener('keydown', (e)=>{ if (e.key==='Enter' || e.key===' ') { e.preventDefault(); head.click(); } });
              // start zamknięty
              setOpen(box.getAttribute('data-open')==='true');
              // po zmianie zawartości skoryguj wysokość
              const ro = new ResizeObserver(()=>{ if (box.getAttribute('data-open')==='true' && body) body.style.maxHeight = body.scrollHeight+'px'; });
              body && ro.observe(body);
            }
            wireExpander(mount.querySelector('#vehExpander'));
            // Dropdown dla "Własny pojazd"
            try {
              const cust = mount.querySelector('#custDD');
              const addChipInline = mount.querySelector('#addVehChipInline');
              function buildForm(){
                return `
                  <style>
                    .cv-row{display:flex;align-items:center;gap:8px}
                    .cv-row input{width:110px;padding:8px 10px;border-radius:10px;border:1px solid var(--line);background:#0c1322;color:var(--ink)}
                    .cv-row input::placeholder{color:var(--muted);opacity:.85}
                    .cv-row .sep{opacity:.6;padding:0 2px}
                    .cv-sub{display:flex;align-items:center;gap:8px;margin-top:8px}
                    .cv-sub input{width:120px}
                    .cv-sub input::placeholder{color:var(--muted);opacity:.85}
                    .cv-hint{color:var(--muted);font-size:.85rem;margin-top:4px}
                  </style>
                  <div class="cv-row">
                    <input id="cvL" type="number" min="50" value="" placeholder="${t('length_cm')}">
                    <span class="sep">×</span>
                    <input id="cvW" type="number" min="50" value="" placeholder="${t('width_cm')}">
                    <span class="sep">×</span>
                    <input id="cvH" type="number" min="50" value="" placeholder="${t('height_cm')}">
                  </div>
                  <div class="cv-sub">
                    <input id="cvKg" type="number" min="0" value="" placeholder="${t('payload_kg')}">
                    <input id="cvEP" type="number" min="0" value="" placeholder="EP">
                    <input id="cvGrid" type="number" min="1" value="" placeholder="${t('grid')} (cm)">
                    <div style="flex:1"></div>
                    <button id="cvCreate" class="btn">${t('create_vehicle')}</button>
                  </div>
                  <div class="cv-hint">${t('enter_cm_hint')}</div>`;
              }
              function openCust(){
                const anchor = addChipInline;
                if (!cust || !anchor) return; cust.innerHTML = buildForm();
                const wrap = mount.querySelector('.vp-wrap');
                const rc = anchor.getBoundingClientRect(); const w = wrap.getBoundingClientRect();
                cust.style.left = (rc.left - w.left) + 'px';
                cust.style.top  = (rc.bottom - w.top + 6) + 'px';
                cust.style.minWidth = '520px';
                cust.style.display = 'block'; cust.hidden = false;
                cust.querySelector('#cvCreate')?.addEventListener('click', ()=>{
                  const L=+cust.querySelector('#cvL').value||0; const W=+cust.querySelector('#cvW').value||0; const H=+cust.querySelector('#cvH').value||0;
                  const Kg=+cust.querySelector('#cvKg').value||0; const EP=+cust.querySelector('#cvEP').value||0; const Grid=+cust.querySelector('#cvGrid').value||5;
                  createVehicleWith(L,W,H,Kg,EP,Grid); closeCust();
                });
                setTimeout(()=>{
                  const onDoc=(e)=>{ if (!cust.contains(e.target) && !anchor.contains(e.target)) { closeCust(); document.removeEventListener('pointerdown', onDoc);} };
                  document.addEventListener('pointerdown', onDoc);
                },0);
              }
              function closeCust(){ if (!cust) return; cust.style.display='none'; cust.hidden=true; }
              function wireChip(el){
                if (!el) return; el.addEventListener('click',(e)=>{ e.stopPropagation(); openCust(); });
                let timer=null; const delayClose=()=>{ clearTimeout(timer); timer=setTimeout(closeCust,180); }; const cancel=()=> clearTimeout(timer);
                el.addEventListener('mouseenter', ()=>{ cancel(); openCust(); });
                el.addEventListener('mouseleave', ()=> delayClose());
                cust?.addEventListener('mouseenter', ()=> cancel());
                cust?.addEventListener('mouseleave', ()=> delayClose());
              }
              wireChip(addChipInline);
            } catch(_){}
          } catch(_) {}
          // Canvas hit-test selection
          try {
            const cv = mount.querySelector('#floor');
            cv?.addEventListener('pointerdown', (e) => {
              const rect = cv.getBoundingClientRect();
              const sx = e.clientX - rect.left;
              const sy = e.clientY - rect.top;
              const hit = hitTest(sx, sy);
              VP2D.selectedId = hit ? hit.id : null;
              render();
            });
            // Hover on 2D canvas: show label for the hovered rectangle
            cv?.addEventListener('pointermove', (e) => {
              const rect = cv.getBoundingClientRect();
              const sx = e.clientX - rect.left;
              const sy = e.clientY - rect.top;
              const hit = hitTest(sx, sy);
              try { overlayLabels.setHotId(hit ? hit.id : null); } catch(_) {}
            });
            cv?.addEventListener('pointerleave', () => { try { overlayLabels.setHotId(null); } catch(_) {} });
          } catch(_) {}
          // Autosave 2D model (no debug items by default)
          try {
            loadState2D();
            // Wyczyść ewentualne testowe prostokąty z poprzednich sesji
            if (Array.isArray(VP2D.items) && VP2D.items.length) {
              VP2D.items = [];
              try { saveState2D(); } catch(_) {}
            }
          } catch(_) {}
          try {
            setInterval(saveState2D, 2000);
            window.addEventListener('beforeunload', saveState2D);
          } catch(_) {}
          
          // ===================== MEGA‑PROMPT LIGHT PARSER (non-intrusive) =====================
          // Standalone, minimal parser helpers. Does not modify existing parser functions.
          function normalizeUnits(raw) {
            // Reuse existing preNormalize where possible, then apply small cleanups.
            let s = preNormalize(String(raw || ""));
            s = s
              .replace(/×/g, "x")
              .replace(/\*/g, "x")
              .replace(/·/g, "x")
              .replace(/\s{2,}/g, " ")
              .trim();
            return s;
          }

          function detectType(tok){
            const t = String(tok || "").toLowerCase();
            if (/(europal|epal|eur|euro|pallet|palet|palette|plt|поддон|палет|піддон)/.test(t)) return "pallet";
            if (/(box|carton|ctn|case|karton|krab|caja|scatola|doos)/.test(t)) return "box";
            if (/(roll|rolka|рулон|rulle|ruolon|tekercs)/.test(t)) return "roll";
            if (/(drum|barrel|beczka|бочка)/.test(t)) return "drum";
            if (/(bag|worek|мешок|sac|saco|bolsa)/.test(t)) return "bag";
            if (/\bibc\b|eurocube|еврокуб|єврокуб/.test(t)) return "ibc";
            return "other";
          }

          function mapPalletSubtype(label, L, W){
            const s = String(label || "").toLowerCase();
            // preferuj po nazwie; w razie braku – po rozmiarze
            if (/eur1|euro\s*120\s*[x×*]\s*80|chep.*1200.*800/.test(s) || (L===120 && W===80)) return "EUR1";
            if (/eur2|120\s*[x×*]\s*100|chep.*1200.*1000/.test(s) || (L===120 && W===100)) return "EUR2";
            if (/eur3|100\s*[x×*]\s*120/.test(s) || (L===120 && W===100)) return "EUR3";
            if (/eur6|80\s*[x×*]\s*60/.test(s) || (L===80  && W===60))  return "EUR6";
            if (/qeur|60\s*[x×*]\s*40/.test(s) || (L===60  && W===40))  return "QEUR";
            if (/us.*48\s*[x×*]\s*40|121\.9.*101\.6/.test(s))           return "US-48x40";
            if (/iso.*1100\s*[x×*]\s*1100|110\s*[x×*]\s*110/.test(s))   return "ISO-1100x1100";
            return "unknown";
          }

          function parseLWH(raw){
            // obsługa LxWxH oraz etykiet L/W/H; zwraca {L,W,H, byLabel}
            const s = normalizeUnits(raw);
            const byLabel = {};
            // etykiety
            const labRe = /\b(L(en|ength|änge)?|Dł|Dl|Длина)\s*[:=]?\s*(\d+(\.\d+)?)\s*(mm|cm|m|")?\b.*?\b(W(idth|eite)?|Szer|Ширина)\s*[:=]?\s*(\d+(\.\d+)?)\s*(mm|cm|m|")?\b.*?\b(H(eight|öhe)?|Wys|Высота)\s*[:=]?\s*(\d+(\.\d+)?)\s*(mm|cm|m|")?\b/i;
            const mLab = s.match(labRe);
            if (mLab){
              byLabel.L = {v:+mLab[3], u:(mLab[5]||"cm")};
              byLabel.W = {v:+mLab[9], u:(mLab[11]||"cm")};
              byLabel.H = {v:+mLab[15],u:(mLab[17]||"cm")};
            }
            // trójka/podwójka
            const m = s.match(/(\d+(?:[.,]\d+)?)\s*[x×*\/]\s*(\d+(?:[.,]\d+)?)\s*(?:[x×*\/]\s*(\d+(?:[.,]\d+)?))?\s*(mm|cm|m|")?/i);
            if (!m && !mLab) return null;

            const unit = (m?.[4] || byLabel.L?.u || "cm").toLowerCase();
            const toCm = v => {
              const n = parseFloat(String(v).replace(",","."));
              if (unit==="mm") return Math.round(n/10);
              if (unit==='m')  return Math.round(n*100);
              if (unit==='"')  return Math.round(n*2.54);
              return Math.round(n); // cm
            };
            let L = m ? toCm(m[1]) : toCm(byLabel.L.v);
            let W = m ? toCm(m[2]) : toCm(byLabel.W.v);
            let H = m ? (m[3]? toCm(m[3]) : 0) : toCm(byLabel.H.v);
            if (L < W) [L,W] = [W,L]; // normalizacja
            if (Math.min(L,W) < 3 || Math.max(L,W,H) > 500) return null;
            return { L,W,H, byLabel: !!mLab };
          }

          function parseDiameter(raw){
            const s = normalizeUnits(raw);
            const dm = s.match(/(ø|⌀|phi|diam(?:eter)?|Durchmesser|diámetro|diametro)\s*[:=]?\s*(\d+(?:[.,]\d+)?)\s*(mm|cm|m|")?/i);
            if (!dm) return null;
            const u = (dm[3]||"cm").toLowerCase();
            const toCm = v => u==="mm"?Math.round(v/10):u==="m"?Math.round(v*100):u==='"'?Math.round(v*2.54):Math.round(v);
            return toCm(parseFloat(String(dm[2]).replace(",", ".")));
          }

          function parseWeights(raw){
            const s = normalizeUnits(raw).toLowerCase();
            const unit = /(\d+(?:[.,]\d+)?)\s*(t|kg)\b/gi;
            let total=null, per=null, note="";
            // per szt/pal
            const perM = s.match(/(\d+(?:[.,]\d+)?)\s*(kg|t)\s*(?:\/|na|per|pro|je|\/\s*(?:szt|pcs|pal|plt))/i);
            if (perM) { const v=parseFloat(perM[1].replace(",", ".")); per = perM[2]==="t"? v*1000 : v; }
            // total
            let m=null; while ((m = unit.exec(s))) { const v=parseFloat(m[1].replace(",", ".")); const kg = m[2]==="t"? v*1000:v; total = (total||0)+kg; }
            if (/brutto|gross/.test(s)) note="brutto"; if (/netto/.test(s)) note=(note?note+";":"")+"netto";
            return { total_weight_kg: total||null, unit_weight_kg: per||null, note };
          }

          function aggregateItems(items){
            const key = it => [it.type,it.subtype,it.length_cm,it.width_cm,it.height_cm].join("|");
            const map = new Map();
            for (const it of items){
              const k = key(it);
              if (!map.has(k)) map.set(k,{...it});
              else{
                const acc = map.get(k);
                acc.qty += it.qty||1;
                if (acc.total_weight_kg!=null || it.total_weight_kg!=null) {
                  acc.total_weight_kg = (acc.total_weight_kg||0) + (it.total_weight_kg||0);
                }
                if (acc.unit_weight_kg!=null && it.unit_weight_kg!=null && acc.unit_weight_kg!==it.unit_weight_kg){
                  acc.needs_review = 1;
                }
                acc.confidence = Math.min(acc.confidence||0.95, it.confidence||0.95);
              }
            }
            return Array.from(map.values());
          }

          function parseRawText(text){
            // minimalny parser: skanuje liniami, wykrywa typ/ilość/wymiary/średnicę i wagę
            const lines = normalizeUnits(text).split(/\n|;/);
            const out = [];
            for (const ln of lines){
              const l = ln.trim(); if (!l) continue;
              const qtyM = l.match(/\b(\d{1,4})\s*(pcs|szt|шт|ks|db|ud|uds|ctn|box|pallet|pal|plt|ibc)?\b/i);
              const qty = qtyM ? Math.max(1, parseInt(qtyM[1],10)) : 1;
              const type = detectType(l);
              const dims = parseLWH(l);
              if (!dims && !/ø|⌀|phi|diam/i.test(l)) continue;

              let {L,W,H} = dims || {L:0,W:0,H:0};
              const diam = parseDiameter(l);
              if (diam) { W = diam; }

              let subtype = type==="pallet" ? mapPalletSubtype(l, L, W) : "unknown";
              if (type==="pallet" && H===0) H = 160; // domyślna H dla palet
              if (type!=="pallet" && H===0) { /* zostaw 0 i oznacz review */ }

              const { unit_weight_kg, total_weight_kg, note } = parseWeights(l);
              out.push({
                type, subtype, qty,
                length_cm:L, width_cm:W, height_cm:H, diameter_cm: diam||null,
                unit_weight_kg: unit_weight_kg||null, total_weight_kg: total_weight_kg||null,
                stackable: /stapelbar|stackable|stohovat|piętr/.test(l) ? true : /non-?stack|nicht stapel|nie ?piętr|не штаб/i.test(l) ? false : null,
                notes: note||"",
                lang: "auto",
                confidence: dims?.byLabel ? 0.9 : 0.75,
                needs_review: (H===0||!dims) ? 1 : 0
              });
            }
            return aggregateItems(out);
          }
          // ===================== /MEGA‑PROMPT LIGHT PARSER =====================

          // ===================== /BULK PARSER — ULTRA v8 =====================
          // One‑line custom add
          mount.querySelector("#cAddOne")?.addEventListener("click", addCustomLine);
          
          // ===================== Three.js 3D (real camera/controls) =====================
          const CM_TO_M = 0.01; // 1 m = 100 cm
          const threeCtx = {
            init: false,
            container: null,
            scene: null,
            camera: null,
            perspCam: null,
            orthoCam: null,
            renderer: null,
            controls: null,
            meshes: { vehicle: null, hullMesh: null, gridMinor: null, gridMajor: null, axes: null, items: new Map(), instanced: [], overflow: [] },
            materials: { pallet: null, fragile: null, noStack: null, default: null, instanced: null },
            raycaster: null,
            mouse: null,
            drag: null,
            instIndexMap: new Map(),
            gizmo: null,
            ui: { tooltip: null },
            raf: null,
            clippingPlane: null,
            state: { sectionEnabled: false, sectionPos: 0.5, activeLayer: 0, top2d: false, sketch: false },
            geoCache: new Map(),
            dummy: null,
            composer: null,
            passes: { render: null, outline: null, bloom: null, fxaa: null },
          };

          function threeInit(){
            try {
              if (threeCtx.init) return true;
              if (typeof THREE === 'undefined') { console.warn('THREE not loaded'); return false; }
              const cont = mount.querySelector('#view3d');
              if (!cont) return false;
              threeCtx.container = cont;
              const rect = cont.getBoundingClientRect();
              const w = Math.max(100, rect.width|0), h = Math.max(100, rect.height|0);

              const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
              // DPR capped for performance
              renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
              renderer.setSize(w, h);
              renderer.localClippingEnabled = true;
              // Quality: tone mapping and color space; keep shadows off by default
              try { renderer.toneMapping = THREE.ACESFilmicToneMapping; } catch(_) {}
              try { renderer.toneMappingExposure = 1.05; } catch(_) {}
              try { renderer.outputColorSpace = THREE.SRGBColorSpace; } catch(_) {}
              try { renderer.shadowMap.enabled = false; } catch(_) {}
              cont.innerHTML = '';
              cont.appendChild(renderer.domElement);

              const scene = new THREE.Scene();
              // Lighting: Hemisphere + Directional
              const hemi = new THREE.HemisphereLight(0xffffff, 0x0b1220, 0.6);
              scene.add(hemi);
              const dir = new THREE.DirectionalLight(0xffffff, 0.85);
              dir.position.set(3, 4, 5);
              scene.add(dir);

              // Cameras: perspective + orthographic (top-down)
              const persp = new THREE.PerspectiveCamera(50, w/h, 0.1, 5000);
              persp.position.set(6, 5, 6);
              const ortho = new THREE.OrthographicCamera(-5, 5, 5, -5, 0.1, 5000);
              ortho.position.set(0, 10, 0);
              ortho.up.set(0, 0, -1);
              ortho.lookAt(0, 0, 0);

              let controls = null;
              try { controls = new THREE.OrbitControls(persp, renderer.domElement); } catch(_) {}
              if (controls) {
                controls.enableDamping = true;
                controls.dampingFactor = 0.08;
                controls.enableZoom = true;
                controls.target.set(0, 0, 0);
                controls.update();
              }

              // Helpers
              const axes = new THREE.AxesHelper(2.0);
              scene.add(axes);

              threeCtx.scene = scene;
              threeCtx.camera = persp;
              threeCtx.perspCam = persp;
              threeCtx.orthoCam = ortho;
              threeCtx.renderer = renderer;
              threeCtx.controls = controls;
              threeCtx.meshes.axes = axes;
              threeCtx.raycaster = new THREE.Raycaster();
              threeCtx.mouse = new THREE.Vector2();
              threeCtx.init = true;
              threeCtx.dummy = new THREE.Object3D();

              // Prepare composer (post‑FX) lazily
              try { threeEnsureComposer(); } catch(_) {}

              // Global clipping plane for side section (YZ plane moving along X)
              threeCtx.clippingPlane = new THREE.Plane(new THREE.Vector3(1, 0, 0), 0);
              threeCtx.renderer.clippingPlanes = [];

              // First vehicle box
              threeUpdateVehicle();
              // Items
              threeUpdateItems();
              // Picking (hover/click)
              threeAttachPicking();

              const loop = () => {
                try {
                  if (threeCtx.controls) threeCtx.controls.update();
                  threeRender();
                } catch(_) {}
                threeCtx.raf = requestAnimationFrame(loop);
              };
              threeCtx.raf = requestAnimationFrame(loop);

              // Resize
              window.addEventListener('resize', threeResize);
              return true;
            } catch (e) {
              console.warn('threeInit failed', e);
              return false;
            }
          }

  function threeResize(){
    if (!threeCtx.init || !threeCtx.container) return;
    const rect = threeCtx.container.getBoundingClientRect();
    const w = Math.max(100, rect.width|0), h = Math.max(100, rect.height|0);
    try {
      // Update active camera
      if (threeCtx.camera && threeCtx.camera.isPerspectiveCamera) {
        threeCtx.camera.aspect = w / h;
        threeCtx.camera.updateProjectionMatrix();
      } else if (threeCtx.camera && threeCtx.camera.isOrthographicCamera) {
        // Keep ortho frustum ratios consistent
        threeFrameTopOrtho();
      }
      threeCtx.renderer.setSize(w, h);
      try { threeCtx.composer?.setSize(w, h); } catch(_) {}
      try {
        if (threeCtx.passes?.fxaa && threeCtx.renderer) {
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          threeCtx.passes.fxaa.uniforms['resolution'].value.set(1/(w*dpr), 1/(h*dpr));
        }
      } catch(_) {}
    } catch(_) {}
  }

          // Switch active camera between perspective and orthographic top-down
  function threeSetCamera(kind){
            if (!threeCtx.init) return;
            const rect = threeCtx.container.getBoundingClientRect();
            const w = Math.max(100, rect.width|0), h = Math.max(100, rect.height|0);
            // Dispose old controls
            try { threeCtx.controls?.dispose?.(); } catch(_) {}
    if (kind === 'ortho') {
      threeCtx.camera = threeCtx.orthoCam;
              // Create controls for ortho camera (pan/zoom only)
              try {
                threeCtx.controls = new THREE.OrbitControls(threeCtx.camera, threeCtx.renderer.domElement);
                threeCtx.controls.enableRotate = false;
                threeCtx.controls.enableDamping = true;
                threeCtx.controls.dampingFactor = 0.08;
                threeCtx.controls.update();
              } catch(_) { threeCtx.controls = null; }
              threeFrameTopOrtho();
      try {
        if (threeCtx.passes?.render) threeCtx.passes.render.camera = threeCtx.camera;
        if (threeCtx.passes?.outline) threeCtx.passes.outline.renderCamera = threeCtx.camera;
      } catch(_) {}
    } else {
      // Perspective
      threeCtx.camera = threeCtx.perspCam;
      threeCtx.camera.aspect = w / h;
      threeCtx.camera.updateProjectionMatrix();
              try {
                threeCtx.controls = new THREE.OrbitControls(threeCtx.camera, threeCtx.renderer.domElement);
                threeCtx.controls.enableDamping = true;
                threeCtx.controls.dampingFactor = 0.08;
                threeCtx.controls.enableZoom = true;
                threeCtx.controls.target.set(0, 0, 0);
                threeCtx.controls.update();
              } catch(_) { threeCtx.controls = null; }
      try {
        if (threeCtx.passes?.render) threeCtx.passes.render.camera = threeCtx.camera;
        if (threeCtx.passes?.outline) threeCtx.passes.outline.renderCamera = threeCtx.camera;
      } catch(_) {}
      animateCameraTo('persp');
    }
  }

          // Compute XZ bounds (in meters) of current items or fallback to hull
          function computeItemsBoundsXZ(itemsArg){
            const v = vehicle();
            const Lm = (v?.inner_cm?.L || 0) * CM_TO_M;
            const Wm = (v?.inner_cm?.W || 0) * CM_TO_M;
            const items = (itemsArg || state.items || []).filter(it => it && !it.overflow);
            if (!items.length) {
              return { minX: -Lm/2, maxX: Lm/2, minZ: -Wm/2, maxZ: Wm/2 };
            }
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            for (const it of items){
              const d = dims2D(it);
              const gl = Math.max(0, d.l) * CM_TO_M;
              const gw = Math.max(0, d.w) * CM_TO_M;
              const x0 = (-Lm/2) + (it.x||0) * CM_TO_M;
              const z0 = (-Wm/2) + (it.y||0) * CM_TO_M;
              const x1 = x0 + gl;
              const z1 = z0 + gw;
              if (x0 < minX) minX = x0;
              if (x1 > maxX) maxX = x1;
              if (z0 < minZ) minZ = z0;
              if (z1 > maxZ) maxZ = z1;
            }
            return { minX, maxX, minZ, maxZ };
          }

          // Fit orthographic camera to items' bounding box
          function threeFrameTopOrtho(margin = 1.12){
            if (!threeCtx.init) return;
            const cam = threeCtx.orthoCam;
            const rect = threeCtx.container.getBoundingClientRect();
            const aspect = Math.max(0.0001, rect.width / Math.max(1, rect.height));
            const v = vehicle();
            const Hm = (v?.inner_cm?.H || 0) * CM_TO_M;
            const b = computeItemsBoundsXZ();
            threeFrameTopToBounds(b, margin);
          }

          // Generic orthographic fit to provided bounds
  function threeFrameTopToBounds(bounds, margin = 1.12){
            if (!threeCtx.init) return;
            const cam = threeCtx.orthoCam;
            const rect = threeCtx.container.getBoundingClientRect();
            const aspect = Math.max(0.0001, rect.width / Math.max(1, rect.height));
            const v = vehicle();
            const Hm = (v?.inner_cm?.H || 0) * CM_TO_M;
            const b = bounds;
            const widthW = Math.max(0.1, (b.maxX - b.minX) * margin);
            const heightW = Math.max(0.1, (b.maxZ - b.minZ) * margin);
            let viewW = widthW, viewH = heightW;
            if (viewW / viewH > aspect) { viewH = viewW / aspect; } else { viewW = viewH * aspect; }
            const cx = (b.minX + b.maxX) / 2;
            const cz = (b.minZ + b.maxZ) / 2;
            cam.left = -viewW / 2; cam.right = viewW / 2; cam.top = viewH / 2; cam.bottom = -viewH / 2;
            cam.updateProjectionMatrix();
            cam.position.set(cx, Math.max(5, Hm + 1), cz);
            cam.lookAt(cx, 0, cz);
            cam.up.set(0, 0, -1);
          }

          // Compute length span along X for loaded items
          function computeLoadedSpan(items){
            // Optional items param; otherwise use current state
            const b = computeItemsBoundsXZ(items);
            return { minX: b.minX, maxX: b.maxX };
          }

          // Focus camera on a given X-span (and current Z bounds), keeping height
          function threeFocusLoaded(padding = 0.12){
            if (!threeCtx.init) return;
            const v = vehicle();
            const Lm = (v?.inner_cm?.L || 0) * CM_TO_M;
            const Hm = (v?.inner_cm?.H || 0) * CM_TO_M;
            const b = computeItemsBoundsXZ();
            // If span covers almost all length, just overview
            const spanLen = Math.max(0, b.maxX - b.minX);
            if (spanLen <= 0.0001 || spanLen >= Lm * 0.92) { animateCameraTo('persp'); return; }
            // Expand span by padding
            const pad = Math.max(0, padding || 0);
            const cx = (b.minX + b.maxX) / 2;
            const cz = (b.minZ + b.maxZ) / 2;
            const dx = spanLen * (1 + pad);
            const dz = Math.max(0.1, (b.maxZ - b.minZ) * (1 + pad));
            // Compute distance to fit a sphere enclosing this sub-box
            const radius = 0.5 * Math.sqrt(dx*dx + dz*dz + Hm*Hm) * 1.12;
            const cam = threeCtx.perspCam;
            const fov = (cam?.fov || 50) * Math.PI / 180;
            const dist = radius / Math.sin(Math.max(0.0001, fov/2));
            const fromPos = threeCtx.camera.position.clone();
            const fromTgt = (threeCtx.controls?.target?.clone && threeCtx.controls.target.clone()) || new THREE.Vector3();
            const k = 0.72;
            const toPos = new THREE.Vector3(cx + dist*k, Hm*0.55 + dist*0.0, cz + dist*k);
            const toTgt = new THREE.Vector3(cx, Hm/2, cz);
            // Switch to perspective if not already
            threeSetCamera('persp');
            // Animate
            const t0 = (performance && performance.now) ? performance.now() : Date.now();
            const dur = 650;
            const ease = (t)=> (t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2);
            function step(){
              const now = (performance && performance.now) ? performance.now() : Date.now();
              const tt = Math.min(1, (now - t0) / dur);
              const kk = ease(tt);
              threeCtx.camera.position.lerpVectors(fromPos, toPos, kk);
              if (threeCtx.controls) {
                const tgt = new THREE.Vector3().lerpVectors(fromTgt, toTgt, kk);
                threeCtx.controls.target.copy(tgt);
                threeCtx.controls.update();
              }
              if (tt < 1) requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
          }

          // Generic focus to provided X-span (meters). If top2d is active, fit ortho to that span + current Z bounds.
          function focusSpan(span, padding = 0.12){
            if (!threeCtx.init || !span) return;
            const v = vehicle();
            const Hm = (v?.inner_cm?.H || 0) * CM_TO_M;
            const bAll = computeItemsBoundsXZ();
            const b = { minX: span.minX, maxX: span.maxX, minZ: bAll.minZ, maxZ: bAll.maxZ };
            if (threeCtx.state.top2d) {
              threeSetCamera('ortho');
              threeFrameTopToBounds(b, 1 + Math.max(0, padding));
            } else {
              threeFocusLoaded(padding);
            }
          }

          // Enable/disable side section clipping and set plane position (0..1 along length)
          function threeSetSectionEnabled(on){
            if (!threeCtx.init) return;
            threeCtx.state.sectionEnabled = !!on;
            threeCtx.renderer.clippingPlanes = on ? [threeCtx.clippingPlane] : [];
            threeUpdateSectionPlane(threeCtx.state.sectionPos);
          }
          function threeUpdateSectionPlane(pos01){
            if (!threeCtx.init) return;
            const v = vehicle();
            const Lm = (v?.inner_cm?.L || 0) * CM_TO_M;
            const xClip = (-Lm/2) + Math.max(0, Math.min(1, pos01||0)) * Lm;
            threeCtx.state.sectionPos = Math.max(0, Math.min(1, pos01||0));
            if (threeCtx.clippingPlane) {
              // Plane eq: x - xClip >= 0 => keep rear part
              threeCtx.clippingPlane.set(new THREE.Vector3(1,0,0), -xClip);
            }
          }

          // Active layer: 0 = all; 1..3 -> filter by item mid-height within [h0,h1]
          function threeSetActiveLayer(layerIndex){
            threeCtx.state.activeLayer = Math.max(0, Math.min(3, layerIndex|0));
            threeUpdateItems();
          }

  function threeUpdateVehicle(){
            if (!threeCtx.init) return;
            const v = vehicle();
            const L = (v?.inner_cm?.L || 100) * CM_TO_M;
            const W = (v?.inner_cm?.W || 100) * CM_TO_M;
            const H = ((v?.inner_cm?.H ?? 200) || 200) * CM_TO_M; // default 2m if missing
            // remove old
            if (threeCtx.meshes.vehicle) {
              try { threeCtx.scene.remove(threeCtx.meshes.vehicle); threeCtx.meshes.vehicle.geometry?.dispose(); threeCtx.meshes.vehicle.material?.dispose(); } catch(_) {}
              threeCtx.meshes.vehicle = null;
            }
            if (threeCtx.meshes.hullMesh) {
              try { threeCtx.scene.remove(threeCtx.meshes.hullMesh); threeCtx.meshes.hullMesh.geometry?.dispose(); threeCtx.meshes.hullMesh.material?.dispose(); } catch(_) {}
              threeCtx.meshes.hullMesh = null;
            }
            // build box edges
            const geo = new THREE.BoxGeometry(L, H, W);
            const edges = new THREE.EdgesGeometry(geo);
            const mat = new THREE.LineBasicMaterial({ color: 0x83a1ff });
            const wire = new THREE.LineSegments(edges, mat);
            wire.position.set(0, H/2, 0); // floor at y=0
            threeCtx.scene.add(wire);
            threeCtx.meshes.vehicle = wire;
            // semi‑transparent walls (interior)
            const wallMat = new THREE.MeshBasicMaterial({ color: 0x83a1ff, transparent: true, opacity: 0.08, depthWrite: false, side: THREE.BackSide });
            const hullMesh = new THREE.Mesh(geo, wallMat);
            hullMesh.position.set(0, H/2, 0);
            threeCtx.scene.add(hullMesh);
            threeCtx.meshes.hullMesh = hullMesh;

            // Grid (floor) with 0.1 m minor and 0.5 m major steps on XZ plane (Y up)
    threeBuildFloorGrid(L, W);
            // frame camera a bit out
            try {
              const cam = threeCtx.camera;
              const maxDim = Math.max(L, W, H);
              const dist = maxDim * 1.6 + 2.5;
              cam.position.set(dist, dist * 0.9, dist);
              if (threeCtx.controls) {
                threeCtx.controls.target.set(0, H/2, 0);
                threeCtx.controls.update();
              }
    } catch(_) {}

    // Update outline targets if sketch mode is on
    try { if (threeCtx.state.sketch) threeRefreshOutlineTargets(); } catch(_) {}
  }

  // Mark items as overflow if their dimensions exceed vehicle interior (L/W/H × stack)
  function enforceOverflowRules(){
    try {
      const v = vehicle();
      const L = v?.inner_cm?.L || 0;
      const W = v?.inner_cm?.W || 0;
      const H = v?.inner_cm?.H || 0;
      let changed = false;
      for (const it of (state.items || [])){
        if (!it) continue;
        const d = dims2D(it);
        const tooTall = (it.H || 0) * (it.stackCount || 1) > H + 1e-6;
        const tooWide = (d.w || 0) > W + 1e-6;
        const tooLong = (d.l || 0) > L + 1e-6;
        const ov = !!(tooTall || tooWide || tooLong);
        if (it.overflow !== ov) { it.overflow = ov; changed = true; }
      }
      if (changed) {
        try { if (threeCtx && threeCtx.init) threeUpdateItems(); } catch(_) {}
      }
    } catch(_) {}
  }

  // Compute scene bounds (vehicle + items) and return framing info
  function frameAll(margin = 1.15){
            const v = vehicle();
            const L = (v?.inner_cm?.L || 100) * CM_TO_M;
            const W = (v?.inner_cm?.W || 100) * CM_TO_M;
            const H = ((v?.inner_cm?.H ?? 200) || 200) * CM_TO_M;
            // Our cargo is centered at x=0,z=0; y spans [0..H]
            const center = new THREE.Vector3(0, H/2, 0);
            const size = new THREE.Vector3(L, H, W);
            const radius = 0.5 * Math.sqrt(L*L + H*H + W*W) * margin;
            // Distance to fit sphere by vertical FOV
            const cam = threeCtx.camera;
            const fov = (cam?.fov || 50) * Math.PI / 180;
            const dist = radius / Math.sin(Math.max(0.0001, fov/2));
            return { center, size, radius, dist };
          }

          // Smoothly animate camera + controls.target to a preset
          function animateCameraTo(preset = 'persp', ms = 650){
            if (!threeCtx.init || !threeCtx.camera) return;
            const { center, dist } = frameAll(1.18);
            const cam = threeCtx.camera;
            const ctr = threeCtx.controls;
            const fromPos = cam.position.clone();
            const fromTgt = (ctr?.target?.clone && ctr.target.clone()) || new THREE.Vector3();
            let toPos = fromPos.clone();
            let toTgt = center.clone();
            const up = new THREE.Vector3(0,1,0);
            // Choose direction vectors
            if (preset === 'top') {
              toPos = new THREE.Vector3(center.x, center.y + dist, center.z);
            } else if (preset === 'side') { // right side (+X)
              toPos = new THREE.Vector3(center.x + dist, center.y + dist*0.12, center.z);
            } else if (preset === 'rear') { // rear (-X)
              toPos = new THREE.Vector3(center.x - dist, center.y + dist*0.12, center.z);
            } else if (preset === 'rearLeft') { // 3/4 rear-left (−X, −Z)
              const k = 0.78;
              toPos = new THREE.Vector3(center.x - dist*k, center.y + dist*0.42, center.z - dist*0.52);
            } else { // perspective/isometric
              const k = 0.72;
              toPos = new THREE.Vector3(center.x + dist*k, center.y + dist*0.55, center.z + dist*k);
            }
            cam.up.copy(up);

            const t0 = (performance && performance.now) ? performance.now() : Date.now();
            const dur = Math.max(100, ms|0);
            const ease = (t)=> (t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2); // cubic in/out
            function step(){
              const now = (performance && performance.now) ? performance.now() : Date.now();
              const tt = Math.min(1, (now - t0) / dur);
              const k = ease(tt);
              cam.position.lerpVectors(fromPos, toPos, k);
              if (ctr) {
                const tgt = new THREE.Vector3().lerpVectors(fromTgt, toTgt, k);
                ctr.target.copy(tgt);
                ctr.update();
              }
              if (tt < 1) requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
          }

          // Helpers for colors
          function isPalletType(t){
            if (!t) return false;
            return /(eur|pallet|palet|plt|epal|eur|paleta)/i.test(String(t));
          }
          function hslToHex(h, s, l){
            // h in [0..360], s,l in [0..100]
            const hh = ((+h)%360)/360, ss = Math.max(0, Math.min(1, (+s)/100)), ll = Math.max(0, Math.min(1, (+l)/100));
            const c = (1 - Math.abs(2*ll - 1)) * ss;
            const x = c * (1 - Math.abs((hh * 6) % 2 - 1));
            const m = ll - c/2;
            let r=0,g=0,b=0;
            if (hh < 1/6) { r=c; g=x; b=0; }
            else if (hh < 2/6) { r=x; g=c; b=0; }
            else if (hh < 3/6) { r=0; g=c; b=x; }
            else if (hh < 4/6) { r=0; g=x; b=c; }
            else if (hh < 5/6) { r=x; g=0; b=c; }
            else { r=c; g=0; b=x; }
            const R = Math.round((r+m)*255), G = Math.round((g+m)*255), B = Math.round((b+m)*255);
            const toHex = (n) => n.toString(16).padStart(2, '0');
            return `#${toHex(R)}${toHex(G)}${toHex(B)}`;
          }
          function colorFromItem(it){
            // Flags override
            if (it?.flags?.fragile) return '#ef4444'; // warm
            if (it?.flags?.noStack || it?.stackable === false) return '#3b82f6'; // cool
            // Pallet-like types -> neutral
            if (isPalletType(it?.type)) return '#a0aec0';
            // fallback to deterministic HSL from 2D color
            try {
              const hsl = getItemColor(it); // e.g., hsl(h,s%,l%)
              const m = /hsl\((\d+),\s*(\d+)%\,\s*(\d+)%\)/.exec(hsl);
              if (m) return hslToHex(+m[1], +m[2], +m[3]);
            } catch(_) {}
            return '#7c9cf5';
          }

          function disposeItemMeshes(){
            try {
              if (!threeCtx.meshes.items) return;
              for (const [, mesh] of threeCtx.meshes.items) {
                try {
                  threeCtx.scene.remove(mesh);
                  // Geometry is cached and reused; do not dispose here
                } catch(_) {}
              }
              threeCtx.meshes.items.clear();
            } catch(_) {}
          }

  function disposeInstancedMeshes(){
            try {
              const arr = threeCtx.meshes.instanced || [];
              for (const m of arr) {
                try {
                  threeCtx.scene.remove(m);
                  // Geometry comes from cache; do not dispose here
                } catch(_) {}
              }
              threeCtx.meshes.instanced = [];
            } catch(_) {}
          }

  function ensureItemMaterials(){
    const M = threeCtx.materials;
    if (!M.pallet)   M.pallet   = new THREE.MeshLambertMaterial({ color: 0xa0aec0 });
    if (!M.fragile)  M.fragile  = new THREE.MeshLambertMaterial({ color: 0xef4444 });
    if (!M.noStack)  M.noStack  = new THREE.MeshLambertMaterial({ color: 0x3b82f6 });
    if (!M.default)  M.default  = new THREE.MeshLambertMaterial({ color: 0x7c9cf5 });
    if (!M.instanced) M.instanced = new THREE.MeshLambertMaterial({ vertexColors: true });
    if (!M.overflow) {
      const mat = new THREE.MeshStandardMaterial({ color: 0xff4d4f, emissive: 0xff5555, emissiveIntensity: 2.0, roughness: 0.6, metalness: 0.0, transparent: true, opacity: 0.92 });
      M.overflow = mat;
    }
  }

  function disposeOverflowMeshes(){
    try {
      const arr = threeCtx.meshes.overflow || [];
      for (const m of arr) {
        try { threeCtx.scene.remove(m); } catch(_) {}
      }
      threeCtx.meshes.overflow = [];
    } catch(_) {}
  }

          function getBoxGeometryCached(gl, gh, gw){
            const key = `${gl.toFixed(6)}|${gh.toFixed(6)}|${gw.toFixed(6)}`;
            const cache = threeCtx.geoCache;
            if (!cache.has(key)) cache.set(key, new THREE.BoxGeometry(gl, gh, gw));
            return cache.get(key);
          }

          function pickMaterialFor(it){
            ensureItemMaterials();
            if (it?.flags?.fragile) return threeCtx.materials.fragile;
            if (it?.flags?.noStack || it?.stackable === false) return threeCtx.materials.noStack;
            if (isPalletType(it?.type)) return threeCtx.materials.pallet;
            // Fallback: create on-the-fly material from derived color (cache by hex)
            const hex = colorFromItem(it);
            const key = `dyn:${hex}`;
            if (!threeCtx.materials[key]) threeCtx.materials[key] = new THREE.MeshLambertMaterial({ color: new THREE.Color(hex) });
            return threeCtx.materials[key];
          }

  function threeUpdateItems(){
    if (!threeCtx.init) return;
    const v = vehicle();
    const L = (v?.inner_cm?.L || 0) * CM_TO_M;
    const W = (v?.inner_cm?.W || 0) * CM_TO_M;
    const H = (v?.inner_cm?.H || 0);
    // clear previous
    disposeItemMeshes();
    disposeInstancedMeshes();
    disposeOverflowMeshes();
    threeCtx.instIndexMap = new Map();

            // Filter items (skip overflow and layer filter)
            const include = [];
    for (const it of (state.items || [])){
      if (!it || it.overflow) continue;
              const hTotal = Math.max(0, (it.H || 0) * (it.stackCount || 1));
              if (threeCtx.state.activeLayer > 0) {
                const layerH = Math.max(1, H) / 3;
                const idx = threeCtx.state.activeLayer - 1;
                const h0 = idx * layerH;
                const h1 = (idx + 1) * layerH;
                const mid = hTotal / 2;
                if (!(mid > h0 && mid <= h1)) continue;
              }
              include.push(it);
            }

            // Group by geometry dimensions (meters)
            const groups = new Map(); // key -> { gl, gw, gh, items: [] }
            for (const it of include){
              const d = dims2D(it);
              const gl = Math.max(0.001, d.l * CM_TO_M);
              const gw = Math.max(0.001, d.w * CM_TO_M);
              const gh = Math.max(0.001, (it.H * (it.stackCount || 1)) * CM_TO_M);
              const key = `${gl.toFixed(6)}|${gw.toFixed(6)}|${gh.toFixed(6)}`;
              if (!groups.has(key)) groups.set(key, { gl, gw, gh, items: [] });
              groups.get(key).items.push(it);
            }

            ensureItemMaterials();
            const dummy = threeCtx.dummy || new THREE.Object3D();
            const instancedMat = threeCtx.materials.instanced;

            for (const { gl, gw, gh, items } of groups.values()){
              if (items.length >= 2){
                const geo = getBoxGeometryCached(gl, gh, gw);
                const count = items.length;
                const inst = new THREE.InstancedMesh(geo, instancedMat, count);
                const ids = [];
                for (let i=0;i<count;i++){
                  const it = items[i];
                  const cx = (-L/2) + ((it.x || 0) * CM_TO_M) + gl/2;
                  const cz = (-W/2) + ((it.y || 0) * CM_TO_M) + gw/2;
                  const cy = gh / 2;
                  dummy.position.set(cx, cy, cz);
                  dummy.rotation.set(0, 0, 0);
                  dummy.updateMatrix();
                  inst.setMatrixAt(i, dummy.matrix);
                  // Per-instance color
                  try {
                    const hex = colorFromItem(it);
                    const col = new THREE.Color(hex);
                    inst.setColorAt(i, col);
                  } catch(_) {}
                  ids.push(String(it.id));
                  try { threeCtx.instIndexMap.set(String(it.id), { inst, index: i }); } catch(_) {}
                }
                try { inst.instanceMatrix.needsUpdate = true; } catch(_) {}
                try { inst.instanceColor && (inst.instanceColor.needsUpdate = true); } catch(_) {}
                inst.userData.ids = ids;
                threeCtx.scene.add(inst);
                threeCtx.meshes.instanced.push(inst);
              } else {
                // Single item -> regular mesh but reuse cached geometry + shared materials
                const it = items[0];
                const geo = getBoxGeometryCached(gl, gh, gw);
                const mat = pickMaterialFor(it);
                const mesh = new THREE.Mesh(geo, mat);
                const cx = (-L/2) + ((it.x || 0) * CM_TO_M) + gl/2;
                const cz = (-W/2) + ((it.y || 0) * CM_TO_M) + gw/2;
                const cy = gh / 2;
                mesh.position.set(cx, cy, cz);
                mesh.userData.itemId = String(it.id);
                threeCtx.scene.add(mesh);
                threeCtx.meshes.items.set(String(it.id), mesh);
              }
    }
    try { threeUpdateGizmo(); } catch(_) {}

    // Update outline targets if sketch mode is on
    try { if (threeCtx.state.sketch) threeRefreshOutlineTargets(); } catch(_) {}

    // Render overflow items outside the hull with red glow
    try {
      const ov = (state.items || []).filter(it => it && it.overflow);
      ensureItemMaterials();
      for (const it of ov){
        const d = dims2D(it);
        const gl = Math.max(0.001, d.l * CM_TO_M);
        const gw = Math.max(0.001, d.w * CM_TO_M);
        const gh = Math.max(0.001, (it.H * (it.stackCount || 1)) * CM_TO_M);
        const geo = getBoxGeometryCached(gl, gh, gw);
        const mesh = new THREE.Mesh(geo, threeCtx.materials.overflow);
        // place just behind the rear (−X)
        const x = (-L/2) - gl/2 - 0.05;
        const z = 0;
        mesh.position.set(x, gh/2, z);
        mesh.userData.itemId = String(it.id);
        threeCtx.scene.add(mesh);
        threeCtx.meshes.overflow.push(mesh);
      }
    } catch(_) {}

    // Refresh outline selections if needed
    try { if (threeCtx.state.sketch) threeRefreshOutlineTargets(); } catch(_) {}
  }

  // ============== Postprocessing & Sketch mode ==============
  function threeEnsureComposer(){
    if (!threeCtx || !threeCtx.renderer || !threeCtx.scene || !threeCtx.camera) return;
    try {
      if (!THREE.EffectComposer || !THREE.RenderPass) return; // libs may not be loaded
    } catch(_) { return; }
    if (!threeCtx.composer){
      const rect = threeCtx.container.getBoundingClientRect();
      const w = Math.max(100, rect.width|0), h = Math.max(100, rect.height|0);
      const composer = new THREE.EffectComposer(threeCtx.renderer);
      const rp = new THREE.RenderPass(threeCtx.scene, threeCtx.camera);
      composer.addPass(rp);
      // Outline (general)
      let op = null;
      try {
        op = new THREE.OutlinePass(new THREE.Vector2(w, h), threeCtx.scene, threeCtx.camera);
        op.edgeStrength = 2.0;
        op.edgeGlow = 0.0;
        op.edgeThickness = 1.0;
        op.pulsePeriod = 0;
        op.visibleEdgeColor.set('#444');
        op.hiddenEdgeColor.set('#222');
        composer.addPass(op);
      } catch(_) {}
      // Outline (overflow, red)
      let op2 = null;
      try {
        op2 = new THREE.OutlinePass(new THREE.Vector2(w, h), threeCtx.scene, threeCtx.camera);
        op2.edgeStrength = 2.0;
        op2.edgeGlow = 0.0;
        op2.edgeThickness = 1.0;
        op2.pulsePeriod = 0;
        op2.visibleEdgeColor.set('#ff4d4f');
        op2.hiddenEdgeColor.set('#a61b1d');
        composer.addPass(op2);
      } catch(_) {}
      // Bloom (subtle, helps red overflow glow)
      let bp = null;
      try {
        bp = new THREE.UnrealBloomPass(new THREE.Vector2(w,h), 0.25, 0.6, 0.9);
        composer.addPass(bp);
      } catch(_) {}
      // FXAA for cleaner lines
      let fx = null;
      try {
        fx = new THREE.ShaderPass(THREE.FXAAShader);
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        fx.uniforms['resolution'].value.set(1/(w*dpr), 1/(h*dpr));
        composer.addPass(fx);
      } catch(_) {}
      threeCtx.composer = composer;
      threeCtx.passes.render = rp;
      threeCtx.passes.outline = op;
      threeCtx.passes.outlineOverflow = op2;
      threeCtx.passes.bloom = bp;
      threeCtx.passes.fxaa = fx;
    } else {
      // Keep passes' camera in sync
      try { threeCtx.passes.render.camera = threeCtx.camera; } catch(_) {}
      try { threeCtx.passes.outline.renderCamera = threeCtx.camera; } catch(_) {}
    }
  }

  function threeRefreshOutlineTargets(){
    if (!threeCtx || !threeCtx.passes || !threeCtx.passes.outline) return;
    const targets = [];
    try { if (threeCtx.meshes.hullMesh) targets.push(threeCtx.meshes.hullMesh); } catch(_) {}
    try {
      for (const m of (threeCtx.meshes.instanced || [])) targets.push(m);
      for (const [, m] of (threeCtx.meshes.items || [])) targets.push(m);
    } catch(_) {}
    try { threeCtx.passes.outline.selectedObjects = targets; } catch(_) {}
    // Overflow (red outline)
    try {
      const ov = [];
      for (const m of (threeCtx.meshes.overflow || [])) ov.push(m);
      if (threeCtx.passes.outlineOverflow) threeCtx.passes.outlineOverflow.selectedObjects = ov;
    } catch(_) {}
  }

  function threeRender(){
    if (!threeCtx || !threeCtx.renderer) return;
    if (threeCtx.state.sketch && threeCtx.composer) {
      try { threeCtx.composer.render(); return; } catch(_) {}
    }
    try { threeCtx.renderer.render(threeCtx.scene, threeCtx.camera); } catch(_) {}
  }

  function threeSetSketch(on){
    if (!threeCtx || !threeCtx.init) return;
    threeCtx.state.sketch = !!on;
    try { threeEnsureComposer(); } catch(_) {}
    if (threeCtx.state.sketch) {
      try { threeRefreshOutlineTargets(); } catch(_) {}
      try { threeCtx.renderer.setClearColor(0x000000, 0); } catch(_) {}
    } else {
      try { threeCtx.renderer.setClearColor(0x000000, 0); } catch(_) {}
    }
  }

          function ensure3DTooltip(){
            if (!threeCtx.init) return null;
            if (!threeCtx.ui.tooltip) {
              const tip = document.createElement('div');
              tip.id = 'vp3dTip';
              tip.style.position = 'absolute';
              tip.style.zIndex = '20';
              tip.style.pointerEvents = 'auto';
              tip.style.display = 'none';
              tip.style.maxWidth = '240px';
              tip.style.background = 'rgba(0,0,0,0.8)';
              tip.style.color = '#fff';
              tip.style.border = '1px solid rgba(255,255,255,0.15)';
              tip.style.borderRadius = '8px';
              tip.style.padding = '8px 10px';
              tip.style.font = '600 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif';
              threeCtx.container.appendChild(tip);
              threeCtx.ui.tooltip = tip;
            }
            return threeCtx.ui.tooltip;
          }
          function hide3DTooltip(){
            const tip = ensure3DTooltip();
            if (tip) tip.style.display = 'none';
          }
          function show3DTooltip(it, clientX, clientY){
            const tip = ensure3DTooltip();
            if (!tip || !it) return;
            const d2 = dims2D(it);
            const dims = `${d2.l}×${d2.w}×${it.H} cm`;
            const kg = `${Math.max(0, it.weight||0)} kg`;
            const typ = it.type || '—';
            const flags = it.flags||{};
            const fHtml = [
              flags.noStack ? '<span title="no‑stack" style="margin-right:6px">⛔</span>' : '',
              flags.fragile ? '<span title="fragile" style="margin-right:6px">🍷</span>' : ''
            ].join('');
            tip.innerHTML = `
              <div style=\"margin-bottom:4px\"><b>${t('dims_label')}:</b> ${dims}</div>
              <div style=\"margin-bottom:4px\"><b>${t('weight')}:</b> ${kg}</div>
              <div style=\"margin-bottom:6px\"><b>Typ:</b> ${typ} ${fHtml}</div>
              <div style=\"display:flex;gap:6px;justify-content:flex-end\">
                <button id=\"vp3dRot\" style=\"appearance:none;border:1px solid rgba(255,255,255,0.25);background:transparent;color:#fff;border-radius:6px;padding:4px 8px;cursor:pointer\">↻ ${t('rotateR') || t('rotate_right') || 'Rotate 90° right'}</button>
                <button id=\"vp3dMore\" class=\"vp3dMoreBtn\" style=\"appearance:none;border:1px solid rgba(255,255,255,0.25);background:transparent;color:#fff;border-radius:6px;padding:4px 8px;cursor:pointer\">${t('more_btn')}</button>
              </div>
            `;
            const rect = threeCtx.container.getBoundingClientRect();
            const x = Math.round(clientX - rect.left + 8);
            const y = Math.round(clientY - rect.top + 8);
            tip.style.left = `${x}px`;
            tip.style.top  = `${y}px`;
            tip.style.display = 'block';
            // Wire the button
            tip.querySelector('#vp3dMore')?.addEventListener('click', (e) => {
              e.stopPropagation();
              try {
                mount.dispatchEvent(new CustomEvent('showItemDetails', { detail: { itemId: it.id, item: JSON.parse(JSON.stringify(it)) } }));
              } catch(_) {}
            }, { once: true });
            tip.querySelector('#vp3dRot')?.addEventListener('click', (e) => {
              e.stopPropagation();
              state.selectedId = String(it.id);
              const ok = rotateSelectedStrict();
              if (!ok) return;
              try { threeUpdateItems(); } catch(_) {}
              try { threeUpdateGizmo(); } catch(_) {}
              try { overlayLabels.updateAll?.(); } catch(_) {}
            });
          }

          function threeAttachPicking(){
            if (!threeCtx.init || !threeCtx.renderer) return;
            const el = threeCtx.renderer.domElement;
            if (!el || el.__vpPickingInstalled) return;
            const ray = threeCtx.raycaster || new THREE.Raycaster();
            threeCtx.raycaster = ray;
            let dragMoved = false;
            function updateMouse(ev){
              const r = el.getBoundingClientRect();
              const nx = ((ev.clientX - r.left) / r.width) * 2 - 1;
              const ny = -((ev.clientY - r.top) / r.height) * 2 + 1;
              if (!threeCtx.mouse) threeCtx.mouse = new THREE.Vector2();
              threeCtx.mouse.set(nx, ny);
              return { nx, ny, rect: r };
            }
            el.addEventListener('pointermove', (ev) => {
              updateMouse(ev);
              if (threeCtx.drag) { dragMoved = true; threeUpdateDrag(ev); }
            });
            el.addEventListener('pointerdown', (ev) => {
              dragMoved = false;
              const { nx, ny } = updateMouse(ev);
              ray.setFromCamera({ x: nx, y: ny }, threeCtx.camera);
              const singles = Array.from(threeCtx.meshes.items.values());
              const insts = (threeCtx.meshes.instanced || []);
              const targets = singles.concat(insts);
              if (!targets.length) return;
              const hits = ray.intersectObjects(targets, true);
              if (!hits || !hits.length) return;
              const hit = hits[0];
              let m = hit.object;
              while (m && !m.userData?.itemId && !m.isInstancedMesh && m.parent) m = m.parent;
              let id = '';
              let meshType = 'mesh';
              let instIndex = -1;
              if (m && m.isInstancedMesh) {
                meshType = 'inst';
                instIndex = (hit.instanceId != null ? hit.instanceId : -1);
                const ids = m.userData?.ids || [];
                id = String(ids[instIndex] || '');
              } else {
                id = String(m?.userData?.itemId || '');
              }
              const it = (state.items || []).find(x => String(x.id) === id);
              if (!it) return;
              state.selectedId = id; dispatchSelectionChange(); try { threeUpdateGizmo(); } catch(_) {}
              threeStartDrag(ev, { id, meshType, target: m, instIndex });
            });
            el.addEventListener('pointerup', (ev) => {
              if (!threeCtx.drag) return;
              threeEndDrag(ev);
              if (!dragMoved) {
                try {
                  const it = (state.items || []).find(x => String(x.id) === String(state.selectedId||''));
                  if (it) show3DTooltip(it, ev.clientX, ev.clientY);
                } catch(_) {}
              }
            });
            // Hide tooltip on ESC or leaving 3D view
            threeCtx.container.addEventListener('mouseleave', hide3DTooltip);
            el.__vpPickingInstalled = true;
          }

          function threeBuildFloorGrid(L, W){
            // Remove previous
            for (const k of ['gridMinor','gridMajor']) {
              const old = threeCtx.meshes[k];
              if (old) { try { threeCtx.scene.remove(old); old.geometry?.dispose(); old.material?.dispose(); } catch(_) {} threeCtx.meshes[k] = null; }
            }
            // Helper to build line geometry for a set of segments
            function buildLines(positions){
              const geo = new THREE.BufferGeometry();
              const arr = new Float32Array(positions);
              geo.setAttribute('position', new THREE.BufferAttribute(arr, 3));
              const mat = new THREE.LineBasicMaterial({ color: 0x2a3958, transparent: true, opacity: 0.35 });
              return new THREE.LineSegments(geo, mat);
            }
            function buildPositions(step){
              const pos = [];
              // vertical lines along Z from z=0..W at x = 0..L
              for (let x=0; x<=L+1e-6; x+=step){
                pos.push(x, 0.0001, 0,  x, 0.0001, W);
              }
              // horizontal lines along X from x=0..L at z = 0..W
              for (let z=0; z<=W+1e-6; z+=step){
                pos.push(0, 0.0001, z,  L, 0.0001, z);
              }
              return pos;
            }
            // Minor grid (0.1 m)
            const minorPos = buildPositions(0.1);
            const minor = buildLines(minorPos);
            // Major grid (0.5 m) different color/opacity
            const majorPos = buildPositions(0.5);
            const majorGeo = new THREE.BufferGeometry();
            majorGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(majorPos), 3));
            const majorMat = new THREE.LineBasicMaterial({ color: 0x3a4d77, transparent: true, opacity: 0.8 });
            const major = new THREE.LineSegments(majorGeo, majorMat);

            threeCtx.scene.add(minor);
            threeCtx.scene.add(major);
            threeCtx.meshes.gridMinor = minor;
            threeCtx.meshes.gridMajor = major;
          }

          // ============ 3D Drag/Snap/Collision ==========
          function threePlaneIntersect(ev){
            const r = threeCtx.raycaster; const el = threeCtx.renderer?.domElement; if (!el) return null;
            const rect = el.getBoundingClientRect();
            const nx = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
            const ny = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
            r.setFromCamera({ x: nx, y: ny }, threeCtx.camera);
            const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
            const out = new THREE.Vector3();
            const ok = r.ray.intersectPlane(plane, out);
            return ok ? out : null;
          }

          function threeStartDrag(ev, info){
            if (!info || !info.id) return;
            const it = state.items.find(x => String(x.id) === String(info.id));
            if (!it) return;
            const v = vehicle();
            const d = dims2D(it);
            const Lm = (v?.inner_cm?.L || 0) * CM_TO_M;
            const Wm = (v?.inner_cm?.W || 0) * CM_TO_M;
            const gl = d.l * CM_TO_M; const gw = d.w * CM_TO_M;
            const cx = (-Lm/2) + (it.x || 0)*CM_TO_M + gl/2;
            const cz = (-Wm/2) + (it.y || 0)*CM_TO_M + gw/2;
            const pt = threePlaneIntersect(ev);
            let off = { x: 0, z: 0 };
            if (pt) off = { x: pt.x - cx, z: pt.z - cz };
            threeCtx.drag = { id: info.id, meshType: info.meshType, target: info.target, instIndex: info.instIndex, offset: off, start: { x: cx, z: cz }, moved: false };
            try { if (threeCtx.controls) threeCtx.controls.enabled = false; } catch(_) {}
          }

          function threeCandidateFromCenterMeters(it, cx, cz){
            const v = vehicle();
            const d = dims2D(it);
            const Lm = (v?.inner_cm?.L || 0) * CM_TO_M;
            const Wm = (v?.inner_cm?.W || 0) * CM_TO_M;
            const gl = d.l * CM_TO_M; const gw = d.w * CM_TO_M;
            let nx = ((cx + Lm/2) - gl/2) / CM_TO_M;
            let ny = ((cz + Wm/2) - gw/2) / CM_TO_M;
            const gsn = computeSnapGrid(nx, ny, 1);
            nx = gsn.x; ny = gsn.y;
            const wsn = computeSnapWalls(nx, ny, d.l, d.w, v, 1.0);
            nx = wsn.x; ny = wsn.y;
            if (!wsn.snapped){
              const esn = computeSnapEdges(nx, ny, d.l, d.w, state.items, it.id, v, 1.0);
              if (esn.snapped) { nx = esn.x; ny = esn.y; }
            }
            return { x: nx, y: ny, l: d.l, w: d.w };
          }

          function threeBox3ForItem(it){
            const v = vehicle();
            const d = dims2D(it);
            const Lm = (v?.inner_cm?.L || 0) * CM_TO_M;
            const Wm = (v?.inner_cm?.W || 0) * CM_TO_M;
            const gl = d.l * CM_TO_M; const gw = d.w * CM_TO_M; const gh = (it.H * (it.stackCount||1)) * CM_TO_M;
            const x0 = (-Lm/2) + (it.x||0)*CM_TO_M;
            const z0 = (-Wm/2) + (it.y||0)*CM_TO_M;
            const min = new THREE.Vector3(x0, 0, z0);
            const max = new THREE.Vector3(x0 + gl, gh, z0 + gw);
            return new THREE.Box3(min, max);
          }

          function threeBox3ForCandidate(it, cand){
            const v = vehicle();
            const Lm = (v?.inner_cm?.L || 0) * CM_TO_M;
            const Wm = (v?.inner_cm?.W || 0) * CM_TO_M;
            const gl = (cand.l||0) * CM_TO_M; const gw = (cand.w||0) * CM_TO_M; const gh = (it.H * (it.stackCount||1)) * CM_TO_M;
            const x0 = (-Lm/2) + (cand.x||0)*CM_TO_M;
            const z0 = (-Wm/2) + (cand.y||0)*CM_TO_M;
            return new THREE.Box3(new THREE.Vector3(x0,0,z0), new THREE.Vector3(x0+gl, gh, z0+gw));
          }

          function threeCandidateValid(it, cand){
            const v = vehicle();
            if (outOfBounds(cand, v)) return false;
            const bC = threeBox3ForCandidate(it, cand);
            for (const other of (state.items||[])){
              if (!other || String(other.id) === String(it.id) || other.overflow) continue;
              const bO = threeBox3ForItem(other);
              if (bC.intersectsBox(bO)) return false;
            }
            return true;
          }

          function threeApplyCenterToVisual(it, cx, cz){
            const d = dims2D(it);
            const gh = (it.H * (it.stackCount||1)) * CM_TO_M;
            const cy = gh / 2;
            if (threeCtx.drag?.meshType === 'inst'){
              const inst = threeCtx.drag.target;
              const index = threeCtx.drag.instIndex;
              const obj = threeCtx.dummy || new THREE.Object3D();
              obj.position.set(cx, cy, cz); obj.rotation.set(0,0,0); obj.updateMatrix();
              try { inst.setMatrixAt(index, obj.matrix); inst.instanceMatrix.needsUpdate = true; } catch(_) {}
            } else {
              const mesh = threeCtx.meshes.items.get(String(it.id));
              if (mesh) { mesh.position.set(cx, cy, cz); }
            }
            try { threeUpdateGizmo({ cx, cz }); } catch(_) {}
          }

          function threeUpdateDrag(ev){
            const drag = threeCtx.drag; if (!drag) return;
            const it = state.items.find(x => String(x.id) === String(drag.id)); if (!it) return;
            const v = vehicle();
            const d = dims2D(it);
            const Lm = (v?.inner_cm?.L || 0) * CM_TO_M;
            const Wm = (v?.inner_cm?.W || 0) * CM_TO_M;
            const gl = d.l * CM_TO_M; const gw = d.w * CM_TO_M;
            const pt = threePlaneIntersect(ev); if (!pt) return;
            let cx = pt.x - (drag.offset?.x||0);
            let cz = pt.z - (drag.offset?.z||0);
            const cand = threeCandidateFromCenterMeters(it, cx, cz);
            if (!threeCandidateValid(it, cand)) return;
            it.x = cand.x; it.y = cand.y;
            cx = (-Lm/2) + it.x*CM_TO_M + gl/2; cz = (-Wm/2) + it.y*CM_TO_M + gw/2;
            threeApplyCenterToVisual(it, cx, cz);
            threeCtx.drag.moved = true;
          }

          function threeEndDrag(ev){
            const drag = threeCtx.drag; if (!drag) { try { if (threeCtx.controls) threeCtx.controls.enabled = true; } catch(_) {} return; }
            const moved = !!drag.moved; threeCtx.drag = null;
            try { if (threeCtx.controls) threeCtx.controls.enabled = true; } catch(_) {}
            if (moved) { try { pushHistory(); } catch(_) {} try { recalc(); } catch(_) {} }
          }

          function threeEnsureGizmo(){
            if (!threeCtx.init) return null;
            if (threeCtx.gizmo) return threeCtx.gizmo;
            const grp = new THREE.Group();
            const mat = new THREE.LineBasicMaterial({ color: 0xff7a00, transparent: true, opacity: 0.9 });
            const geo = new THREE.BufferGeometry();
            const L = 0.6; const arr = new Float32Array([
              -L/2, 0.002, 0,   L/2, 0.002, 0,
               0,   0.002, -L/2,  0,  0.002, L/2
            ]);
            geo.setAttribute('position', new THREE.BufferAttribute(arr, 3));
            const lines = new THREE.LineSegments(geo, mat);
            grp.add(lines);
            grp.visible = false;
            threeCtx.scene.add(grp);
            threeCtx.gizmo = grp;
            return grp;
          }

          function threeUpdateGizmo(opt){
            try { threeEnsureGizmo(); } catch(_) {}
            const g = threeCtx.gizmo; if (!g) return;
            const id = String(state.selectedId || '');
            const it = (state.items||[]).find(x => String(x.id) === id && !x.overflow);
            if (!it || state.viewMode !== '3d') { g.visible = false; return; }
            const v = vehicle(); const d = dims2D(it);
            const Lm = (v?.inner_cm?.L || 0) * CM_TO_M; const Wm = (v?.inner_cm?.W || 0) * CM_TO_M;
            const gl = d.l * CM_TO_M; const gw = d.w * CM_TO_M;
            let cx, cz;
            if (opt && typeof opt.cx === 'number' && typeof opt.cz === 'number') { cx = opt.cx; cz = opt.cz; }
            else { cx = (-Lm/2) + (it.x||0)*CM_TO_M + gl/2; cz = (-Wm/2) + (it.y||0)*CM_TO_M + gw/2; }
            g.position.set(cx, 0.001, cz);
            g.visible = true;
          }

          // ===================== EPAL Pallet (blocky) =====================
          // createPallet({L=1200, W=800, H=144}) in millimeters.
          // Returns: { group: THREE.Group, box: THREE.Box3 }
          // - Geometry: 9 blocks + 3 bottom boards + 5 top boards (rough sizes)
          // - Pivot: base-center (x/z center, y at floor plane)
          function createPallet({ L = 1200, W = 800, H = 144, tTop = 22, tBot = 22, blockL = 145, blockW = 100 } = {}) {
            if (typeof THREE === 'undefined') throw new Error('THREE not available');
            const mm = (v) => (v || 0) * 0.001; // mm -> meters
            const grp = new THREE.Group();
            grp.name = 'EPAL-pallet';

            // Materials (matte wood variants)
            const matWood = new THREE.MeshStandardMaterial({ color: 0xB68C5A, roughness: 0.88, metalness: 0.03 });
            const matWoodDark = new THREE.MeshStandardMaterial({ color: 0x9C7A4F, roughness: 0.9, metalness: 0.02 });

            // Derived heights
            const blockH = Math.max(10, H - tTop - tBot); // mm
            const halfL = L / 2;
            const halfW = W / 2;

            // Helper to add a board (length along X, width along Z, thickness along Y)
            function addBoard(lenMM, thickMM, widthMM, cxMM, cyMM, czMM, mat) {
              const geo = new THREE.BoxGeometry(mm(lenMM), mm(thickMM), mm(widthMM));
              const mesh = new THREE.Mesh(geo, mat);
              mesh.position.set(mm(cxMM), mm(cyMM), mm(czMM));
              mesh.castShadow = true; mesh.receiveShadow = true;
              grp.add(mesh);
              return mesh;
            }

            // 1) Bottom deck: 3 boards spanning full length (equally split across width)
            const botY = tBot / 2; // center of thickness from floor
            const botW = W / 3;    // each board covers ~1/3 width
            for (let i = 0; i < 3; i++) {
              const cz = -halfW + (i + 0.5) * botW;
              addBoard(L, tBot, botW, 0, botY, cz, matWoodDark);
            }

            // 2) Blocks: 3 × 3 grid (rough placement with small edge margins)
            const marginX = 25, marginZ = 25; // mm, edge offsets
            const blkY = tBot + blockH / 2;
            const colX = [ -halfL + blockL / 2 + marginX, 0, halfL - blockL / 2 - marginX ];
            const rowZ = [ -halfW + blockW / 2 + marginZ, 0, halfW - blockW / 2 - marginZ ];
            for (const x of colX) {
              for (const z of rowZ) {
                addBoard(blockL, blockH, blockW, x, blkY, z, matWood);
              }
            }

            // 3) Top deck: 5 boards spanning full length (equally split across width)
            const topY = tBot + blockH + tTop / 2;
            const topW = W / 5;
            for (let i = 0; i < 5; i++) {
              const cz = -halfW + (i + 0.5) * topW;
              addBoard(L, tTop, topW, 0, topY, cz, matWoodDark);
            }

            // Compute local bounds (pivot is base-center -> y: [0..H])
            grp.updateMatrixWorld(true);
            const box = new THREE.Box3().setFromObject(grp);
            grp.userData.size_mm = { L, W, H };
            grp.userData.bounds = box.clone();
            grp.userData.pivot = 'base-center';
            return { group: grp, box };
          }

          // Optional helper: add a pallet to current 3D scene at floor level
          function threeAddPallet(opts = {}) {
            if (!threeCtx || !threeCtx.scene) throw new Error('3D scene not initialised');
            const res = createPallet(opts);
            // Base-center pivot -> y=0 places it on the floor
            res.group.position.set(0, 0, 0);
            threeCtx.scene.add(res.group);
            return res;
          }

          // Expose for quick testing in console
          try { window.createPallet = createPallet; window.threeAddPallet = threeAddPallet; } catch(_) {}

          // ===================== Cardboard Box (FEFCO 0201‑like) =====================
          // createBox({L,W,H,t=3, massKg=0, stackable=true, maxStack=0, label='BOX'})
          // Units: mm. Pivot: base‑center (x/z center, y at floor). Returns { group, box }.
          function createBox({ L = 600, W = 400, H = 350, t = 3, massKg = 0, stackable = true, maxStack = 0, label = 'BOX' } = {}) {
            if (typeof THREE === 'undefined') throw new Error('THREE not available');
            // Guard for minimum wall thickness vs outer dims
            const tw = Math.max(0.5, +t || 3);
            const mm = (v) => (v || 0) * 0.001; // mm -> m
            const halfL = L / 2, halfW = W / 2;
            const innerL = Math.max(1, L - 2 * tw);
            const innerW = Math.max(1, W - 2 * tw);
            const innerH = Math.max(1, H - 2 * tw);

            const grp = new THREE.Group();
            grp.name = 'Box-0201';
            // Cardboard material
            const matCard = new THREE.MeshStandardMaterial({ color: 0xD2AA74, roughness: 0.88, metalness: 0.02 });
            const matCardDark = new THREE.MeshStandardMaterial({ color: 0xB8905E, roughness: 0.9, metalness: 0.02 });

            function addPart(xMM, yMM, zMM, cxMM, cyMM, czMM, mat) {
              const geo = new THREE.BoxGeometry(mm(xMM), mm(yMM), mm(zMM));
              const mesh = new THREE.Mesh(geo, mat);
              mesh.position.set(mm(cxMM), mm(cyMM), mm(czMM));
              mesh.castShadow = true; mesh.receiveShadow = true;
              grp.add(mesh);
              return mesh;
            }

            // Four side walls (outer envelope LxWxH with thickness tw)
            // Long walls (thickness along Z)
            addPart(L, H, tw, 0, H / 2,  halfW - tw / 2, matCard);
            addPart(L, H, tw, 0, H / 2, -halfW + tw / 2, matCard);
            // Short walls (thickness along X)
            addPart(tw, H, W,  halfL - tw / 2, H / 2, 0, matCard);
            addPart(tw, H, W, -halfL + tw / 2, H / 2, 0, matCard);

            // Bottom flaps (closed) – 2 panels meeting at centerline (no visible gap)
            const botY = tw / 2; // plate center from floor
            addPart(innerL, tw, innerW / 2, 0, botY, -innerW / 4, matCardDark);
            addPart(innerL, tw, innerW / 2, 0, botY,  innerW / 4, matCardDark);

            // Top flaps (closed)
            const topY = H - tw / 2;
            addPart(innerL, tw, innerW / 2, 0, topY, -innerW / 4, matCardDark);
            addPart(innerL, tw, innerW / 2, 0, topY,  innerW / 4, matCardDark);

            // User metadata
            grp.userData = Object.assign({}, grp.userData, {
              kind: 'box0201',
              outer_mm: { L, W, H },
              wall_mm: tw,
              massKg: +massKg || 0,
              stackable: !!stackable,
              maxStack: Math.max(0, maxStack|0),
              label: String(label || 'BOX')
            });

            // Bounds (world‑independent now; update again after positioning if needed)
            grp.updateMatrixWorld(true);
            const box = new THREE.Box3().setFromObject(grp);
            return { group: grp, box };
          }

          // Helper: place object with base‑pivot on top of base object (by Box3)
          function placeOnTopOf(baseObj, obj, dxMM = 0, dzMM = 0) {
            const mm = (v) => (v || 0) * 0.001;
            const b = new THREE.Box3().setFromObject(baseObj);
            const topY = b.max.y; // world Y of base top
            obj.position.set((baseObj.position.x || 0) + mm(dxMM), topY + (obj.position.y||0), (baseObj.position.z || 0) + mm(dzMM));
          }

          // Convenience: add a box to scene at floor or at given mm offset
          function threeAddBox(opts = {}, pos = { x: 0, y: 0, z: 0 }) {
            if (!threeCtx || !threeCtx.scene) throw new Error('3D scene not initialised');
            const mm = (v) => (v || 0) * 0.001;
            const res = createBox(opts);
            res.group.position.set(mm(pos.x || 0), mm(pos.y || 0), mm(pos.z || 0));
            threeCtx.scene.add(res.group);
            return res;
          }

          try { window.createBox = createBox; window.threeAddBox = threeAddBox; window.placeOnTopOf = placeOnTopOf; } catch(_) {}
          mount
            .querySelector('[data-act="undo"]')
            .addEventListener("click", undo);
          mount
            .querySelector('[data-act="redo"]')
            .addEventListener("click", redo);
          mount
            .querySelector('[data-act="autopack"]')
            .addEventListener("click", () => autopackUltra(0, true));
          mount
            .querySelector('[data-act="altpack"]')
            .addEventListener("click", () =>
              autopackUltra((Math.random() * 100) | 0, true)
            );
          mount
            .querySelector('[data-act="compare"]')
            .addEventListener("click", () => {
              state.compareOn = !state.compareOn;
              renderAll();
            });
          mount
            .querySelector('[data-act="stackAll"]')
            .addEventListener("click", stackAll);
          mount
            .querySelector('[data-act="prevVar"]')
            .addEventListener("click", () =>
              applyVariant(state.variants.index - 1)
            );
          mount
            .querySelector('[data-act="nextVar"]')
            .addEventListener("click", () =>
              applyVariant(state.variants.index + 1)
            );
          mount
            .querySelector('[data-act="reset"]')
            .addEventListener("click", () => {
              if (confirm("Wyczyścić wszystkie elementy?")) {
                pushHistory();
                state.items = [];
                state.selectedId = null;
                state.variants = { plans: [], index: 0 };
                renderAll();
              }
            });
          mount
            .querySelector('[data-act="save"]')
            .addEventListener("click", saveLocal);
          mount
            .querySelector('[data-act="share"]')
            .addEventListener("click", shareLink);
          mount
            .querySelector('[data-act="rotR"]')
            .addEventListener("click", () => rotateSelected(+1));
          mount
            .querySelectorAll('[data-act="delete"]')
            .forEach((b) => b.addEventListener("click", deleteSelected));

          // 3D Camera preset buttons
          try {
            mount.querySelector('[data-act="camTop"]').addEventListener('click', () => animateCameraTo('top'));
            mount.querySelector('[data-act="camSide"]').addEventListener('click', () => animateCameraTo('side'));
            mount.querySelector('[data-act="camRear"]').addEventListener('click', () => animateCameraTo('rear'));
            mount.querySelector('[data-act="camRearLeft"]').addEventListener('click', () => animateCameraTo('rearLeft'));
            mount.querySelector('[data-act="camPersp"]').addEventListener('click', () => animateCameraTo('persp'));
            // Overview frames the whole scene (perspective)
            mount.querySelector('[data-act="camOverview"]').addEventListener('click', () => {
              threeCtx.state.top2d = false;
              threeSetCamera('persp');
              animateCameraTo('persp');
            });
            // Show whole (alias): if top2d then fit to hull, else perspective overview
            mount.querySelector('[data-act="camAll"]').addEventListener('click', () => {
              if (threeCtx.state.top2d) {
                const v = vehicle();
                const Lm = (v?.inner_cm?.L || 0) * CM_TO_M;
                const Wm = (v?.inner_cm?.W || 0) * CM_TO_M;
                threeSetCamera('ortho');
                threeFrameTopToBounds({ minX: -Lm/2, maxX: Lm/2, minZ: -Wm/2, maxZ: Wm/2 }, 1.08);
              } else {
                threeSetCamera('persp');
                animateCameraTo('persp');
              }
            });
            // Show loaded span: top2d frames to loaded bounds; persp focuses span along X
            mount.querySelector('[data-act="camLoaded"]').addEventListener('click', () => {
              if (threeCtx.state.top2d) {
                threeSetCamera('ortho');
                const b = computeItemsBoundsXZ();
                threeFrameTopToBounds(b, 1.1);
              } else {
                threeFocusLoaded(0.12);
              }
            });
            // Side section toggle (global clipping plane)
            const sectionBtn = mount.querySelector('[data-act="sectionToggle"]');
            sectionBtn.addEventListener('click', () => {
              const on = !threeCtx.state.sectionEnabled;
              threeSetSectionEnabled(on);
              if (sectionSlider) sectionSlider.style.display = on ? 'inline-block' : 'none';
            });
            if (sectionSlider) {
              sectionSlider.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value || '50') / 100;
                threeUpdateSectionPlane(v);
              });
            }
            // Layers: 1/2/3 and All
            mount.querySelector('[data-act="layer1"]').addEventListener('click', () => threeSetActiveLayer(1));
            mount.querySelector('[data-act="layer2"]').addEventListener('click', () => threeSetActiveLayer(2));
            mount.querySelector('[data-act="layer3"]').addEventListener('click', () => threeSetActiveLayer(3));
            mount.querySelector('[data-act="layerAll"]').addEventListener('click', () => threeSetActiveLayer(0));
            // Top view 2D: orthographic camera
            const topBtn = mount.querySelector('[data-act="top2d"]');
            topBtn.addEventListener('click', () => {
              threeCtx.state.top2d = !threeCtx.state.top2d;
              if (threeCtx.state.top2d) {
                topBtn.textContent = t('view_perspective');
                threeSetCamera('ortho');
              } else {
                topBtn.textContent = t('top2d');
                threeSetCamera('persp');
              }
            });
          } catch(_) {}

          // Brakujące akcje przycisków Piętrowanie +/− (obok wybranego elementu)
          mount
            .querySelector('[data-act="stack-+"]')
            ?.addEventListener("click", () => changeStack(+1));
          mount
            .querySelector('[data-act="stack--"]')
            ?.addEventListener("click", () => changeStack(-1));

          

          // ===================== INIT =====================
          function seedPresets() {
            state.items.push({
              id: uid(),
              type: "eur_pallet",
              L: 120,
              W: 80,
              H: 180,
              weight: 350,
              stackable: true,
              stackCount: 1,
              x: 0,
              y: 0,
              rot: 0,
              flags: {}
            });
            state.items.push({
              id: uid(),
              type: "eur_pallet",
              L: 120,
              W: 80,
              H: 180,
              weight: 350,
              stackable: true,
              stackCount: 1,
              x: 120,
              y: 0,
              rot: 0,
              flags: {}
            });
          }
  function firstTimeInit() {
    if (!loadFromHash()) loadLocal();
    renderPresets();
    applyDevice();
    renderAll();
    // Ensure the floor grid starts fitted to full cargo width
    try { fitCanvasToVehicleWidth(true); } catch(_) {}
    if (!state.items.length) {
      seedPresets();
      renderAll();
      try { fitCanvasToVehicleWidth(true); } catch(_) {}
    }
    try { render(); } catch(_) {}
  }

  // ===================== SELF TEST: Overlay Labels =====================
  function selfTestLabels() {
    try {
      const log = (...a) => console.log('[selfTest]', ...a);
      const pass = (name) => log(name + ': PASS');
      const fail = (name, msg) => log(name + ': FAIL', msg || '');

      // dims-rot
      try {
        const it = { id: 't_rot', type: 'test', L: 120, W: 80, H: 100, weight: 10, stackCount: 1, rot: 0 };
        const el0 = overlayLabels.buildLabel(it);
        const txt0 = el0.querySelector('.body')?.textContent || '';
        it.rot = 1;
        const el1 = overlayLabels.buildLabel(it);
        const txt1 = el1.querySelector('.body')?.textContent || '';
        if (txt0.includes('120×80×100') && txt1.includes('80×120×100')) pass('dims-rot'); else fail('dims-rot', `${txt0} | ${txt1}`);
      } catch (e) { fail('dims-rot', e?.message); }

      // auto-place: two boxes minimal collision; in crowd choose "-out"
      const backupItems = deepClone(state.items);
      try {
        const a = { id: 't_a1', type: 'test', L: 120, W: 80, H: 150, weight: 300, stackCount: 1, x: 0, y: 0, rot: 0 };
        const b = { id: 't_a2', type: 'test', L: 120, W: 80, H: 150, weight: 300, stackCount: 1, x: 120, y: 0, rot: 0 };
        state.items = [a, b];
        renderAll();
        overlayLabels.updateAll();
        const la = mount.querySelector('#labels .label[data-id="t_a1"]');
        const lb = mount.querySelector('#labels .label[data-id="t_a2"]');
        const ra = la?.getBoundingClientRect(); const rb = lb?.getBoundingClientRect();
        let inter = 0; if (ra && rb) {
          const x1 = Math.max(ra.left, rb.left), y1 = Math.max(ra.top, rb.top);
          const x2 = Math.min(ra.right, rb.right), y2 = Math.min(ra.bottom, rb.bottom);
          inter = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
        }
        const area = (ra?.width || 1) * (ra?.height || 1);
        if (inter <= area * 0.20) pass('auto-place'); else fail('auto-place', `overlap=${inter.toFixed(1)} area=${area.toFixed(1)}`);

        // crowd test: force many boxes to increase overlap -> expect "-out"
        const crowd = [];
        let idn = 0;
        for (let y = 0; y < 5; y++) {
          for (let x = 0; x < 6; x++) {
            crowd.push({ id: 't_c' + (++idn), type: 'crowd', L: 100, W: 80, H: 120, weight: 100, stackCount: 1, x: x*100, y: y*80, rot: 0 });
          }
        }
        const c = { id: 't_crowd', type: 'test', L: 90, W: 70, H: 100, weight: 80, stackCount: 1, x: 50, y: 50, rot: 0 };
        state.items = crowd.concat([c]);
        renderAll();
        overlayLabels.updateAll();
        const anchor = (c.label && c.label.anchor) || '';
        if (/-out$/.test(anchor)) pass('auto-place crowd'); else fail('auto-place crowd', anchor);
      } catch (e) { fail('auto-place', e?.message); }

      // contrast: light/dark backgrounds choose variant
      try {
        const light = overlayLabels.test_applyContrast_on('rgb(255,255,255)');
        const dark = overlayLabels.test_applyContrast_on('rgb(5,5,5)');
        const lightOk = (
          light.color === '#111' ||
          light.color === '#121212' ||
          light.color === 'rgb(17, 17, 17)' ||
          light.color === 'rgb(18, 18, 18)'
        );
        const darkOk = (
          dark.color === '#fff' ||
          dark.color === 'white' ||
          dark.color === 'rgb(255, 255, 255)'
        );
        if (lightOk && darkOk) pass('contrast'); else fail('contrast', `light=${light.color} dark=${dark.color}`);
      } catch (e) { fail('contrast', e?.message); }

      // icons: noStack/fragile render
      try {
        const it = { id: 't_icons', type: 'test', L: 120, W: 80, H: 100, weight: 10, stackCount: 1, flags: { noStack: true, fragile: true }, rot: 0 };
        const el = overlayLabels.buildLabel(it);
        const uses = Array.from(el.querySelectorAll('use')).map(u => u.getAttribute('href'));
        if (uses.includes('#i-nostack') && uses.includes('#i-fragile')) pass('icons'); else fail('icons', String(uses));
      } catch (e) { fail('icons', e?.message); }

      // tooltip-aria: aria-describedby open/close
      try {
        const id = 't_rot';
        const okOpen = overlayLabels.openTooltip(id);
        const lab = mount.querySelector(`#labels .label[data-id="${id}"]`);
        const has = lab?.getAttribute('aria-describedby') === 'labelTip';
        const okClose = overlayLabels.closeTooltip(id);
        const gone = !lab?.hasAttribute('aria-describedby');
        if (okOpen && okClose && has && gone) pass('tooltip-aria'); else fail('tooltip-aria');
      } catch (e) { fail('tooltip-aria', e?.message); }

      // selection: .is-selected reacts to selectionchange
      try {
        state.items = [{ id: 't_sel', type: 'test', L: 120, W: 80, H: 100, weight: 10, stackCount: 1, x: 0, y: 0, rot: 0 }];
        renderAll(); overlayLabels.updateAll();
        state.selectedId = 't_sel';
        dispatchSelectionChange();
        const selEl = mount.querySelector('#labels .label[data-id="t_sel"]');
        if (selEl && selEl.classList.contains('is-selected')) pass('selection'); else fail('selection');
      } catch (e) { fail('selection', e?.message); }

      // perf: 200 labels < 16 ms (build + measure only)
      try {
        const N = 200;
        const t0 = (performance && performance.now) ? performance.now() : Date.now();
        for (let i=0;i<N;i++) {
          const it = { id: 't_perf_' + i, type: 'test', L: 80 + (i%5)*10, W: 60 + (i%7)*10, H: 100, weight: 10, stackCount: 1, rot: (i%2) };
          const el = overlayLabels.buildLabel(it);
          overlayLabels.measureLabel(el);
        }
        const t1 = (performance && performance.now) ? performance.now() : Date.now();
        const dt = t1 - t0;
        if (dt < 16) pass('perf 200'); else fail('perf 200', `${dt.toFixed(1)} ms`);
      } catch (e) { fail('perf 200', e?.message); }

      // restore
      state.items = backupItems;
      renderAll(); overlayLabels.updateAll();
    } catch (e) {
      console.warn('[selfTest] unexpected', e);
    }
  }

  // ===================== SELF TEST: 2D Keys & Rulers =====================
  function selfTest2D(){
    try {
      const log = (n, ok, msg='') => console.log(`[${ok?'PASS':'FAIL'} ${n}]${msg? ' '+msg:''}`);
      const vp = mount.querySelector('#viewport');
      const v = vehicle();
      // Backup
      const backup = deepClone({ items: state.items, sel: state.selectedId });
      // Helper to dispatch key
      const key = (k, opt={}) => vp.dispatchEvent(new KeyboardEvent('keydown', { key: k, bubbles: true, shiftKey: !!opt.shift }));
      // Ensure focusable
      try { vp.focus(); } catch(_) {}

      // Setup a clean scene
      state.items = [];
      const a = { id: 'k_a', type: 'test', L: 120, W: 80, H: 100, weight: 10, stackCount: 1, x: 10, y: 10, rot: 0 };
      state.items.push(a);
      state.selectedId = a.id; renderAll();

      // 1) viewport tabbable
      log('tabindex', vp.getAttribute('tabindex') === '0');

      // 2) ArrowRight +1 cm
      const x0 = a.x; key('ArrowRight');
      log('arrow +1', a.x === x0 + 1);

      // 3) Shift+ArrowDown +5 cm
      const y0 = a.y; key('ArrowDown', { shift: true });
      log('shift +5', a.y === y0 + 5);

      // 4) Clamp to bounds (force to right wall)
      a.x = v.inner_cm.L - dims2D(a).l; renderAll(); key('ArrowRight');
      log('clamp bounds', a.x === v.inner_cm.L - dims2D(a).l);

      // 5) Rotate R toggles 0<->1
      a.rot = 0; renderAll(); key('r');
      log('rotate 0->90', (a.rot % 2) === 1);
      key('r'); log('rotate 90->0', (a.rot % 2) === 0);

      // 6) Rotate with collision -> revert
      const b = { id: 'k_b', type: 'test', L: 120, W: 80, H: 100, weight: 10, stackCount: 1, x: 0, y: 0, rot: 0 };
      state.items = [b, { ...a, id: 'k_sel', x: 100, y: 0, rot: 0 }];
      state.selectedId = 'k_sel'; renderAll();
      const beforeRot = state.items.find(x=>x.id==='k_sel').rot;
      key('R');
      const afterRot = state.items.find(x=>x.id==='k_sel').rot;
      log('rotate collision revert', beforeRot === afterRot);

      // 7) Delete selected
      key('Delete');
      log('delete selected', !state.items.some(x=>x.id==='k_sel'));

      // 8) Escape cancels selection and drag
      state.items = [a]; state.selectedId = a.id; renderAll();
      // simulate drag
      drag = { id: a.id, pre: { x: a.x, y: a.y }, offXcm: 0, offYcm: 0 };
      key('Escape');
      log('escape clears selection', !state.selectedId && drag === null);

      // 9) Rulers ticks + labels every 10 cm
      try { updateRulers(); } catch(_) {}
      const overlay = mount.querySelector('#overlay');
      const tx = overlay.querySelectorAll('#rulerX .rulerTick').length;
      const ty = overlay.querySelectorAll('#rulerY .rulerTick').length;
      const has10 = Array.from(overlay.querySelectorAll('#rulerX text')).some(t=>/\b10\b/.test(t.textContent||''));
      log('rulers ticks', tx>0 && ty>0);
      log('rulers labels 10cm', has10);

      // 10) Collision flash on blocked move
      state.items = [ { id:'c1', type:'t', L:120, W:80, H:100, stackCount:1, x:0, y:0, rot:0 }, { id:'c2', type:'t', L:120, W:80, H:100, stackCount:1, x:120, y:0, rot:0 } ];
      state.selectedId = 'c2'; renderAll();
      // try to move left into c1 (should snap collide and flash)
      key('ArrowLeft');
      const flash = mount.querySelector('#overlay #gCollisionFlash');
      log('collision flash', !!flash);

      // restore
      state.items = backup.items; state.selectedId = backup.sel; renderAll();
    } catch (e) {
      console.warn('[selfTest2D] unexpected', e);
    }
  }

  // ===================== SELF TEST: 3D =====================
  function selfTest3D(){
    try {
      const log = (name, ok, msg='') => console.log(`[${ok?'PASS':'FAIL'} ${name}]${msg? ' '+msg:''}`);
      // Backup current state and view
      const backup = {
        items: deepClone(state.items),
        sel: state.selectedId,
        mode: state.viewMode,
        top2d: (threeCtx && threeCtx.state ? threeCtx.state.top2d : false),
        sectionOn: (threeCtx && threeCtx.state ? threeCtx.state.sectionEnabled : false),
        sectionPos: (threeCtx && threeCtx.state ? threeCtx.state.sectionPos : 0.5),
      };

      // Ensure 3D mode and init
      state.viewMode = '3d'; renderAll(); threeInit(); threeUpdateVehicle();

      // Create a unique single item to avoid instancing
      const it = { id: 'test3d_one', type: 'test', L: 123, W: 77, H: 50, weight: 10, stackCount: 1, x: 10, y: 10, rot: 0 };
      state.items = [it]; state.selectedId = it.id; renderAll();
      let okRender = false;
      try { threeCtx.renderer.render(threeCtx.scene, threeCtx.camera); okRender = true; } catch(_) { okRender = false; }
      log('3D render', okRender);

      // frameAll + focusSpan API smoke
      try { frameAll(1.10); const span = computeLoadedSpan(); focusSpan(span, 0.10); log('frameAll+focusSpan', true); } catch(e) { log('frameAll+focusSpan', false, e?.message||''); }

      // Raycast should return the item
      try {
        threeUpdateItems();
        const v = vehicle();
        const d = dims2D(it);
        const gl = d.l * CM_TO_M, gw = d.w * CM_TO_M, gh = (it.H * it.stackCount) * CM_TO_M;
        const L = (v?.inner_cm?.L||0) * CM_TO_M, W = (v?.inner_cm?.W||0) * CM_TO_M;
        const cx = (-L/2) + (it.x||0)*CM_TO_M + gl/2;
        const cy = gh/2;
        const cz = (-W/2) + (it.y||0)*CM_TO_M + gw/2;
        const p = new THREE.Vector3(cx, cy, cz).project(threeCtx.camera);
        const ray = threeCtx.raycaster; ray.setFromCamera({ x: p.x, y: p.y }, threeCtx.camera);
        const singles = Array.from(threeCtx.meshes.items.values());
        const insts = (threeCtx.meshes.instanced || []);
        const hits = ray.intersectObjects(singles.concat(insts), true);
        let hitId = '';
        if (hits && hits.length) {
          let m = hits[0].object; while (m && !m.userData?.itemId && !m.isInstancedMesh && m.parent) m = m.parent;
          if (m && m.isInstancedMesh) {
            const idx = (hits[0].instanceId != null ? hits[0].instanceId : -1);
            const ids = m.userData?.ids || []; hitId = String(ids[idx] || '');
          } else { hitId = String(m?.userData?.itemId || ''); }
        }
        log('raycast item', hitId === it.id);
      } catch(e) { log('raycast item', false, e?.message||''); }

      // Top view 2D camera
      try { threeSetCamera('ortho'); const ok = !!(threeCtx.camera && threeCtx.camera.isOrthographicCamera); log('top view 2D', ok); } catch(e) { log('top view 2D', false, e?.message||''); }

      // Clipping plane movement
      try {
        threeSetSectionEnabled(true); threeUpdateSectionPlane(0.33);
        const ok = threeCtx.state.sectionEnabled && Math.abs(threeCtx.state.sectionPos - 0.33) < 1e-3 && (threeCtx.renderer.clippingPlanes||[]).length > 0;
        log('clipping plane', ok);
      } catch(e) { log('clipping plane', false, e?.message||''); }

      // Performance: N=300 boxes, ~>30 FPS on desktop (approx)
      try {
        const dev = getDevice();
        const N = 300; const v = vehicle();
        const cell = 10; // cm
        const cols = Math.max(1, Math.floor(v.inner_cm.L / cell));
        const rows = Math.max(1, Math.floor(v.inner_cm.W / cell));
        const many = [];
        for (let i=0;i<N;i++){
          const x = (i % cols) * cell;
          const y = Math.floor(i / cols) * cell;
          if (y + cell > v.inner_cm.W) break; // keep within
          many.push({ id: `p${i}`, type: 'bulk', L: cell, W: cell, H: 10, weight: 1, stackCount: 1, x, y, rot: 0 });
        }
        state.items = many; renderAll();
        const t0 = (performance && performance.now) ? performance.now() : Date.now();
        threeUpdateItems();
        const t1 = (performance && performance.now) ? performance.now() : Date.now();
        threeCtx.renderer.render(threeCtx.scene, threeCtx.camera);
        const t2 = (performance && performance.now) ? performance.now() : Date.now();
        const drawMs = t2 - t1; // render cost
        const ok = dev !== 'desktop' ? true : drawMs <= 33; // ~30 FPS
        log(`perf 300 (render ${drawMs.toFixed(1)} ms)`, ok);
      } catch(e) { log('perf 300', false, e?.message||''); }

      // Restore prior state
      state.items = backup.items; state.selectedId = backup.sel; state.viewMode = backup.mode;
      if (threeCtx && threeCtx.state) { threeCtx.state.top2d = backup.top2d; threeSetSectionEnabled(backup.sectionOn); threeUpdateSectionPlane(backup.sectionPos); }
      renderAll();
    } catch(e) {
      console.warn('[selfTest3D] unexpected', e);
    }
  }

          // Shortcuts (global) — honor typing contexts (inputs/textarea/contenteditable)
          window.addEventListener("keydown", (e) => {
            const t = e.target;
            const tag = t && t.tagName ? String(t.tagName).toUpperCase() : "";
            const isTyping = !!t && (t.isContentEditable || tag === 'INPUT' || tag === 'TEXTAREA');
            // If user types inside an input/textarea (e.g., bulkText), do not hijack clipboard or other keys
            if (isTyping) return;
            if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "c") {
              e.preventDefault();
              copySelected();
            }
            if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "v") {
              e.preventDefault();
              pasteClipboard();
            }
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
              e.preventDefault();
              undo();
            }
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y") {
              e.preventDefault();
              redo();
            }
            if (e.key === "R" || e.key === "r") rotateSelected(+1);
            try { overlayLabels.updateAll(); } catch(_){}
            if (e.key === "Delete") {
              deleteSelected();
            }
            if (e.key === "+" || e.key === "=") {
              changeStack(+1);
            }
            if (e.key === "-") {
              changeStack(-1);
            }
            if (
              e.key === "ArrowLeft" &&
              e.shiftKey &&
              (e.metaKey || e.ctrlKey)
            ) {
              applyVariant(state.variants.index - 1);
            }
            if (
              e.key === "ArrowRight" &&
              e.shiftKey &&
              (e.metaKey || e.ctrlKey)
            ) {
              applyVariant(state.variants.index + 1);
            }
          });

          // Convenience: in bulk input allow Cmd/Ctrl+Enter to analyze and add
          try {
            bulkText.addEventListener('keydown', (e) => {
              if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
                e.preventDefault();
                bulkAdd?.click();
              }
            });
          } catch(_) {}

  firstTimeInit();
  // Ensure language button reflects current language after state/URL load
  try {
    (function(){
      const btn = mount.querySelector('#lang-trigger');
      const pop = mount.querySelector('#lang-popover');
      const FLAGS = { pl:'🇵🇱', ru:'🇷🇺', uk:'🇺🇦', it:'🇮🇹', fr:'🇫🇷', de:'🇩🇪', en:'🇬🇧' };
      const CODEMAP = { uk: 'UA' };
      if (btn) {
        btn.querySelector('.hdr-flag').textContent = FLAGS[lang] || '🏳️';
        btn.querySelector('.hdr-lang-code').textContent = (CODEMAP[lang] || lang || 'pl').toUpperCase();
        pop?.querySelectorAll('[role="menuitemradio"]').forEach(el=>{
          const on = el.getAttribute('data-lang') === lang; el.setAttribute('aria-checked', String(on));
        });
      }
    })();
  } catch(_) {}
  try { installViewportKeys(); } catch(_) {}
  // Observe only viewport size to re-layout positions; font size stays CSS-driven (vw)
  try {
    const vp = mount.querySelector('#viewport');
    if (vp && 'ResizeObserver' in window) {
      const ro = new ResizeObserver(() => {
        try { overlayLabels.updateAll(); } catch(_) {}
        try { layoutLabels2D(); } catch(_) {}
      });
      ro.observe(vp);
    }
  } catch(_) {}
  // Run self test after startup
  try { setTimeout(selfTestLabels, 0); } catch(_) {}
  try { setTimeout(selfTest2D, 0); } catch(_) {}
  try { setTimeout(selfTest3D, 50); } catch(_) {}
        } catch (err) {
          const root = document.getElementById("van-pack");
          const box = document.createElement("div");
          box.style.cssText =
            "background:#2b1111;color:#ffd7d7;border:1px solid #7a2b2b;border-radius:10px;padding:10px;margin:10px 0";
          box.textContent =
            t('error_init_prefix') + (err && err.message ? err.message : err);
          root.appendChild(box);
          console.error(err);
        }
      })();
    </script>
  </body>
</html>
