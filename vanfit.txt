<!-- @format -->

<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Van Pack – widget demo v8</title>
    <style>
      /* ===================== THEME TOKENS ===================== */
      .vp {
        --bg: #0f1117;
        --ink: #e8eef9;
        --muted: #9fb0ca;
        --accent: #ff5a00;
        --accent-ink: #fff;
        --ok: #1fcf6d;
        --bad: #ff4d4f;
        --line: #223047;
        --card: #121a2b;
        --soft: #1a2236;
        --rad: 14px;
        --gap: 12px;
        --grid: 5;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial,
          sans-serif;
        color: var(--ink);
      }
      @media (prefers-color-scheme: light) {
        .vp:not([data-theme="dark"]) {
          --bg: #f5f7fb;
          --ink: #141a2a;
          --muted: #5b6a85;
          --accent: #ef5a00;
          --accent-ink: #fff;
          --ok: #0f9b5f;
          --bad: #d43030;
          --line: #d5dcef;
          --card: #ffffff;
          --soft: #f0f3fa;
        }
      }
      .vp[data-theme="light"] {
        --bg: #f5f7fb;
        --ink: #141a2a;
        --muted: #5b6a85;
        --accent: #ef5a00;
        --accent-ink: #fff;
        --ok: #0f9b5f;
        --bad: #d43030;
        --line: #d5dcef;
        --card: #ffffff;
        --soft: #f0f3fa;
      }

      /* ===================== BASE ===================== */
      .vp * {
        box-sizing: border-box;
      }
      .vp a {
        color: var(--accent);
      }
      /* Brand (VanFit) */
      .vp .brand {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 6px;
      }
      .vp .brand-name {
        font-weight: 800;
        letter-spacing: .3px;
        color: var(--accent);
        font-size: 1.05rem;
      }
      
      /* Goodloading-style header */
      .vp .header-bar {
        background: #1e3a8a;
        color: white;
        padding: 12px 20px;
        border-radius: 8px 8px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: -16px -16px 16px -16px;
      }
      
      .vp .header-left {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      
      .vp .header-icon {
        width: 32px;
        height: 32px;
        background: rgba(255,255,255,0.1);
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s;
      }
      
      .vp .header-icon:hover {
        background: rgba(255,255,255,0.2);
      }
      
      .vp .header-right {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      
      .vp .pro-button {
        background: #10b981;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
      }
      
      .vp .user-icon {
        width: 32px;
        height: 32px;
        background: #3b82f6;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
      }
      
      /* Welcome banner */
      .vp .welcome-banner {
        background: #d1fae5;
        border: 1px solid #10b981;
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 20px;
        position: relative;
      }
      
      .vp .welcome-banner .close-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
        color: #065f46;
      }
      
      /* Left sidebar styling */
      .vp .side {
        background: #dbeafe;
        border: 1px solid #93c5fd;
        border-radius: var(--rad);
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        position: relative;
        color: #1e40af;
      }
      
      .vp .side h4 {
        margin: 0;
        font-size: 1rem;
        color: #1e40af;
        font-weight: 600;
      }
      
      .vp .side .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      
      .vp .side .add-btn {
        background: #3b82f6;
        color: white;
        border: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .vp .side .menu-btn {
        background: none;
        border: none;
        color: #1e40af;
        cursor: pointer;
        font-size: 18px;
      }
      
      /* Algorithm settings */
      .vp .algorithm-settings {
        background: white;
        border: 1px solid #93c5fd;
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 16px;
      }
      
      .vp .radio-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 12px;
      }
      
      .vp .radio-item {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
      }
      
      .vp .radio-item input[type="radio"] {
        accent-color: #3b82f6;
      }
      
      .vp .info-icon {
        color: #6b7280;
        cursor: help;
        font-size: 14px;
      }
      
      /* Cargo list styling */
      .vp .cargo-item {
        background: white;
        border: 1px solid #93c5fd;
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 8px;
      }
      
      .vp .cargo-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      
      .vp .cargo-title {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 600;
      }
      
      .vp .cargo-icon {
        width: 20px;
        height: 20px;
        background: #3b82f6;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 12px;
      }
      
      .vp .cargo-dropdown {
        background: none;
        border: none;
        color: #1e40af;
        cursor: pointer;
        font-size: 16px;
      }
      
      .vp .cargo-menu {
        background: none;
        border: none;
        color: #1e40af;
        cursor: pointer;
        font-size: 18px;
      }
      
      .vp .pallet-item {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 8px;
        margin: 4px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .vp .pallet-count {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .vp .count-btn {
        background: #3b82f6;
        color: white;
        border: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .vp .vp-wrap {
        background: var(--bg);
        border: 1px solid var(--line);
        border-radius: var(--rad);
        padding: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        /* Widen the workspace for better readability on long cargo spaces */
        max-width: 98vw;
        margin: 0 auto;
      }
      .vp .topbar {
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
      }
      .vp .title {
        font-weight: 700;
        letter-spacing: 0.2px;
      }
      .vp .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        margin-top: 10px;
      }
      .vp select,
      .vp input[type="number"],
      .vp input[type="text"],
      .vp input[type="date"],
      .vp input[type="time"],
      .vp textarea {
        background: #0c1322;
        color: var(--ink);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
      }
      .vp[data-theme="light"] select,
      .vp[data-theme="light"] input,
      .vp[data-theme="light"] textarea {
        background: #fff;
      }
      .vp label {
        color: var(--muted);
        font-size: 0.95rem;
      }
      .vp .chip {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 0.9rem;
        color: var(--muted);
      }

      /* Theme toggle */
      .vp .theme {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .vp .toggle {
        width: 62px;
        height: 28px;
        border-radius: 20px;
        border: 1px solid var(--line);
        background: var(--soft);
        position: relative;
        cursor: pointer;
      }
      .vp .knob {
        position: absolute;
        top: 3px;
        left: 3px;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: #ffd166;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease;
      }
      .vp[data-theme="light"] .knob {
        transform: translateX(34px);
        background: #ffe08a;
      }
      .vp[data-theme="dark"] .knob {
        transform: translateX(0);
      }
      /* Grid */
      .vp .grid {
        display: grid;
        grid-template-columns: minmax(240px, 1fr) 400px;
        gap: 16px;
      }
      @media (max-width: 1120px) {
        .vp .grid {
          grid-template-columns: 1fr;
        }
      }

      /* Stage */
      .vp .stage-card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: var(--rad);
        padding: 10px;
        position: relative;
      }
      .vp .stage-wrap {
        position: relative;
        width: 100%;
        /* More responsive height for better visibility */
        height: clamp(520px, 68vh, 860px);
      }
      .vp .stage-wrap.compare {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        align-items: stretch;
      }
      @media (min-width: 1400px) {
        .vp .stage-wrap {
          height: 640px;
        }
      }
      .vp svg {
        width: 100%;
        height: 100%;
        display: block;
        /* Subtle orange‑tinted gradient for nicer depth */
        background: radial-gradient(1000px 520px at 20% 0%, rgba(255,90,0,.08), rgba(255,90,0,0) 60%),
          linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.02),
            rgba(255, 255, 255, 0) 30%
          ),
          var(--soft);
        border-radius: 10px;
      }
      /* Sunlight: stronger contrast and outlines */
      html.sunlight .vp .gridline { stroke: #1f2b44; stroke-width: 0.35; }
      html.sunlight .vp .hull { stroke-width: 1.2; }
      html.sunlight .vp .item { stroke-width: 1.1; filter: drop-shadow(0 2px 4px rgba(0,0,0,.45)); }
      html.sunlight .vp .label { stroke-width: 0.9; }
      .vp svg.boardB { display: none; }
      .vp canvas.board3d {
        width: 100%;
        height: 100%;
        display: none;
        background: radial-gradient(1200px 600px at 50% 30%, rgba(255,255,255,0.05), transparent 60%), var(--soft);
        border-radius: 10px;
      }
      .vp .board {
        outline: 1px solid #2b3958;
      }
      .vp .gridline {
        stroke: #26334e;
        stroke-width: 0.2;
      }
      .vp[data-theme="light"] .gridline {
        stroke: #e8eef9;
      }
      .vp .hull {
        fill: #0e1526;
        stroke: #3a4d77;
        stroke-width: 0.8;
      }
      .vp[data-theme="light"] .hull {
        fill: #f2f5fb;
        stroke: #d5dcef;
      }
      .vp .sectionline {
        stroke: var(--accent);
        stroke-width: 0.8;
        stroke-dasharray: 3 3;
        opacity: 0.8;
      }
      /* Axle/CoG overlay */
      .vp .axline { stroke: var(--accent); stroke-width: 1; stroke-dasharray: 4 3; opacity: .9; }
      .vp .axmark { fill: var(--accent); opacity: .9; }
      .vp .axbar { fill: rgba(255,90,0,.18); stroke: var(--accent); stroke-width: .6; }
      .vp .axtext { font-size: 3.2px; fill: var(--muted); }
      /* HUD overlay for readable labels */
      .vp .hud-layer {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      /* Overlay viewport: canvas -> svg -> div(labels) order */
      .vp #viewport {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 5;
        /* Hide floating/overlay labels – we will render info inside items */
        display: none;
      }
      /* Print mode: show overlay viewport */
      html.print .vp #viewport { display: block !important; }
      .vp #viewport > canvas,
      .vp #viewport > svg,
      .vp #viewport > div {
        position: absolute;
        inset: 0;
      }
      .vp #floor { width: 100%; height: 100%; display: block; }
      .vp #overlay { width: 100%; height: 100%; display: block; background: transparent !important; }
      .vp #labels { width: 100%; height: 100%; pointer-events: none; }
      /* Minimal label style (non-scaling DOM labels) */
      .vp #labels .label { position:absolute; font:600 clamp(10px,1.2vw,14px)/1.2 system-ui; background:rgba(0,0,0,.7); color:#fff; border-radius:4px; padding:2px 6px; white-space:nowrap; pointer-events:none; }
      .vp #labels .label .body { pointer-events:auto; }
      .vp #labels .label.is-selected { outline:2px solid var(--accent); box-shadow:0 0 0 2px rgba(255,90,0,0.35); background:var(--accent); color:var(--accent-ink); z-index: 20; }
      .vp .leaderline { stroke: var(--accent); stroke-width: 1.4; stroke-dasharray: 3 2; opacity:.85; }
      /* Icon inside overlay label */
      .label .ico { width:1em; height:1em; vertical-align:-0.15em; margin-left:.35em; fill:currentColor; opacity:.9; }
      .vp .hud {
        position: absolute;
        padding: 2px 4px;
        border-radius: 6px;
        font-size: 12px;
        line-height: 1;
        color: var(--ink);
        background: rgba(0, 0, 0, 0.25);
      }
      .vp[data-theme="light"] .hud {
        background: rgba(255, 255, 255, 0.7);
        border: 1px solid rgba(0, 0, 0, 0.08);
      }

      .vp .item {
        /* Default fill/stroke are overridden via JS for per-item colors */
        fill: #2a3b60;
        stroke: #83a1ff;
        stroke-width: 0.7;
        cursor: grab;
        /* Add subtle drop shadow for a pseudo‑3D effect */
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.35));
      }
      .vp[data-theme="light"] .item {
        fill: #cdd7f7;
        stroke: #4a77ff;
      }
      .vp .dragging .item.selected {
        cursor: grabbing;
      }
      .vp .item.collide {
        stroke: var(--bad);
      }
      .vp .item.selected {
        filter: drop-shadow(0 0 10px rgba(90, 163, 255, 0.6));
      }
      /* Larger, responsive in-SVG text (inside pallets) */
      .vp .label {
        font-size: clamp(12px, 1.1vw, 18px);
        fill: #d7e3ff;
        paint-order: stroke;
        stroke: #0b1020;
        stroke-width: 0.6;
      }
      .vp .label.dimA { font-size: clamp(14px, 1.3vw, 22px); font-weight: 700; }
      .vp .label.dimB { font-size: clamp(12px, 1.1vw, 18px); opacity: .95; }
      /* Compact label mode: hide the secondary line when zoomed out */
      .vp g.compact .label.dimB { display: none; }
      /* Print: hide in-rect labels, rely on overlay labels placed outside */
      html.print .vp .label { display: none !important; }
      /* Print: small frame for printable areas */
      html.print .vp .board { outline: 2px solid #000; background: #fff; }
      html.print .vp svg.section { outline: 1px solid #000; background: #fff; }
      .vp .rulerText { font-size: 3px; fill: var(--muted); }
      .vp .rulerTick { stroke: #435273; stroke-width: 0.6; }
      .vp[data-theme="light"] .rulerTick { stroke: #c6d2ef; }
      .vp .rotBtn {
        fill: #0c1322;
        stroke: #83a1ff;
        stroke-width: 0.5;
        cursor: pointer;
      }
      .vp .rotHit {
        fill: transparent;
        pointer-events: all;
        cursor: pointer;
      }

      /* Side cut (W×H) preview */
      .vp .section-cut {
        margin-top: 10px;
        background: var(--soft);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
      }
      .vp svg.section {
        width: 100%;
        height: 180px;
        display: block;
        background: linear-gradient(
            180deg,
            rgba(255, 255, 255, 0.02),
            rgba(255, 255, 255, 0) 30%
          ),
          var(--soft);
        border-radius: 8px;
      }
      .vp .sec-gridline {
        stroke: #26334e;
        stroke-width: 0.2;
      }
      .vp[data-theme="light"] .sec-gridline {
        stroke: #e8eef9;
      }

      /* Underbar */
      .vp .underbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding-top: 10px;
        border-top: 1px dashed #2b3958;
        margin-top: 10px;
      }

      /* Metrics bar inside underbar */
      .vp .metrics-bar .card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
        min-width: 120px;
      }
      .vp .metrics-bar progress {
        width: 100%;
        height: 10px;
      }
      .vp .metrics-bar progress::-webkit-progress-value {
        background: var(--accent);
      }
      .vp .metrics-bar progress::-webkit-progress-bar {
        background: #23314d;
      }
      .vp[data-theme="light"] .metrics-bar progress::-webkit-progress-bar {
        background: #e8eef9;
      }
      .vp .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        background: var(--accent);
        color: var(--accent-ink);
        border: none;
        border-radius: 10px;
        padding: 10px 12px;
        cursor: pointer;
      }
      .vp .btn.secondary {
        background: var(--soft);
        color: var(--ink);
        border: 1px solid var(--line);
      }
      .vp .btn.ghost {
        background: transparent;
        border: 1px dashed var(--line);
      }

      /* Side */
      .vp .side {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: var(--rad);
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        position: relative;
      }
      .vp .side h4 {
        margin: 0;
        font-size: 1rem;
        color: #d7e3ff;
      }
      .vp[data-theme="light"] .side h4 {
        color: #1a2233;
      }
      .vp .preset-list {
        display: grid;
        grid-template-columns: repeat(1, minmax(0, 1fr));
        gap: 8px;
      }
      .vp .preset {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        background: var(--soft);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
      }
      .vp .preset small {
        color: var(--muted);
      }
      .vp .qty {
        display: flex;
        gap: 6px;
        align-items: center;
      }
      .vp .qty input {
        width: 64px;
      }

      /* Bulk */
      .vp .bulk {
        background: var(--soft);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 10px;
      }
      .vp .bulk .out {
        background: #0c1322;
        border: 1px dashed #33425f;
        border-radius: 8px;
        padding: 8px;
        min-height: 40px;
        color: #c9d6f0;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        white-space: pre-wrap;
      }
      .vp[data-theme="light"] .bulk .out {
        background: #fff;
        color: #2b3b55;
        border-color: #cfd8ef;
      }
      .vp .note {
        color: var(--muted);
        font-size: 0.9rem;
      }

      /* Custom small form */
      .vp .custom {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }
      .vp .custom .row {
        display: flex;
        flex-direction: column;
      }
      .vp .custom .wide {
        grid-column: 1 / -1;
      }

      /* New one‑line custom input */
      .vp .custom-line {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .vp .custom-line input[type="text"] {
        flex: 1 1 240px;
        min-width: 180px;
      }
      .vp .custom-hint {
        color: var(--muted);
        font-size: .85rem;
        margin: 6px 0 12px 0;
      }

      /* Add vehicle */
      .vp .vehbox {
        background: var(--soft);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
      }
      .vp .vehgrid {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 8px;
      }
      @media (max-width: 560px) {
        .vp .vehgrid {
          grid-template-columns: repeat(2, 1fr);
        }
      }

      .vp .meters {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .vp .meters .card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
      }
      progress {
        width: 100%;
        height: 10px;
      }
      progress::-webkit-progress-value {
        background: var(--accent);
      }
      progress::-webkit-progress-bar {
        background: #23314d;
      }
      .vp[data-theme="light"] progress::-webkit-progress-bar {
        background: #e8eef9;
      }

      .vp .status {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .vp .badge {
        padding: 6px 10px;
        border-radius: 999px;
        font-weight: 600;
      }
      .vp .badge.ok {
        background: rgba(31, 207, 109, 0.12);
        color: #0be481;
        border: 1px solid #1fcf6d;
      }
      .vp .badge.bad {
        background: rgba(255, 77, 79, 0.12);
        color: #ff4d4f;
        border: 1px solid #ff4d4f;
      }

      .vp .actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .vp details {
        background: var(--soft);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
      }

      /* Selected item panel */
      .vp .selected-panel {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
        display: none;
      }
      .vp .selected-panel.active {
        display: block;
      }
      .vp .selected-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
      }

      /* Modal */
      .vp .modal {
        position: fixed;
        inset: 0;
        background: rgba(5, 8, 15, 0.66);
        display: none;
        align-items: center;
        justify-content: center;
      }
      .vp .modal[open] {
        display: flex;
      }
      .vp .modal .box {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: 16px;
        padding: 16px;
        width: min(900px, 96vw);
      }
      .vp .modal h3 {
        margin-top: 0;
      }
      .vp .modal .two {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .vp .modal input,
      .vp .modal textarea {
        width: 100%;
        background: #0c1322;
        color: var(--ink);
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px;
      }
      .vp[data-theme="light"] .modal input,
      .vp[data-theme="light"] .modal textarea {
        background: #fff;
        color: #111;
      }
      .vp .modal .foot {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 10px;
      }

      /* Focus & a11y */
      .vp [tabindex]:focus {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      /* Error box */
      .vp .error {
        background: #2b1111;
        color: #ffd7d7;
        border: 1px solid #7a2b2b;
        border-radius: 10px;
        padding: 10px;
        display: none;
      }
      .vp .error[aria-hidden="false"] {
        display: block;
      }

      /* Fancy checkbox (stackable) */
      .vp .chk {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: var(--soft);
        cursor: pointer;
        user-select: none;
      }
      .vp .chk input {
        appearance: none;
        width: 16px;
        height: 16px;
        border: 1px solid #41527a;
        border-radius: 4px;
        display: inline-block;
        background: #0c1322;
        position: relative;
      }
      .vp .chk input:checked {
        background: #0d2418;
        border-color: #2a9d6f;
      }
      .vp .chk input:checked::after {
        content: "";
        position: absolute;
        inset: 2px;
        background: #2dd07a;
        border-radius: 2px;
      }
      .vp .chk span {
        color: var(--muted);
      }
    </style>
  </head>
  <body>
    <div id="van-pack" class="vp" data-lang="pl">
      <noscript
        ><div
          style="
            color: #fff;
            background: #c00;
            padding: 10px;
            border-radius: 8px;
          "
        >
          Ta aplikacja wymaga JavaScript.
        </div></noscript
      >
    </div>

    <script>
      (() => {
        try {
          // ===================== CONFIG & I18N =====================
          const VEHICLES = [
            // Busy  EP
            {
              id: "bus_5ep",
              group: "Bus 3,5 t",
              name_pl: "Bus 3,6x1,6x1,8 m",
              inner_cm: { L: 360, W: 160, H: 180 },
              payload_kg: 1350,
              europallets: 5,
              grid_cm: 5,
            },
            {
              id: "bus_8ep",
              group: "Bus 3,5 t",
              name_pl: "Bus 4,2x2,2x2,6 m",
              inner_cm: { L: 420, W: 220, H: 260 },
              payload_kg: 1100,
              europallets: 8,
              grid_cm: 5,
            },
            {
              id: "solo_10ep_4_2m",
              group: "Bus 3,5 t",
              name_pl: "Bus 4,2×2,2×2,6 m",
              inner_cm: { L: 420, W: 220, H: 240 },
              payload_kg: 1000,
              europallets: 10,
              grid_cm: 5,
            },
            {
              id: "solo_10ep_4_2m",
              group: "Bus 3,5 t",
              name_pl: "Bus 4,2×2,25×2,6 m",
              inner_cm: { L: 420, W: 220, H: 240 },
              payload_kg: 1000,
              europallets: 10,
              grid_cm: 5,
            },
            {
              id: "solo_10ep_4_8m",
              group: "Bus 3,5 t",
              name_pl: "Bus 4,8×2,2×2,6 m",
              inner_cm: { L: 480, W: 220, H: 260 },
              payload_kg: 1000,
              europallets: 10,
              grid_cm: 5,
            },

            // Solówki — realne wymiary
            {
              id: "solo_6m_low",
              group: "Solówka",
              name_pl: "Solówka 6,0×2,45×2,2 m",
              inner_cm: { L: 600, W: 245, H: 220 },
              payload_kg: 2500,
              europallets: 14,
              grid_cm: 5,
            },
            {
              id: "solo_7_2m",
              group: "Solówka",
              name_pl: "Solówka 7,2×2,45×2,5 m",
              inner_cm: { L: 720, W: 245, H: 250 },
              payload_kg: 5000,
              europallets: 18,
              grid_cm: 5,
            },
            {
              id: "solo_8_2m",
              group: "Solówka",
              name_pl: "Solówka 8,2×2,45×2,7 m",
              inner_cm: { L: 820, W: 245, H: 270 },
              payload_kg: 9000,
              europallets: 20,
              grid_cm: 5,
            },
            {
              id: "solo_8_9m_high",
              group: "Solówka",
              name_pl: "Solówka 8,9×2,48×3,0 m",
              inner_cm: { L: 890, W: 248, H: 300 },
              payload_kg: 12000,
              europallets: 22,
              grid_cm: 5,
            },

            // Naczepy — realne wymiary
            {
              id: "trailer_13_6",
              group: "Naczepa 13,6 m",
              name_pl: "Naczepa 13,6×2,45×2,65 m",
              inner_cm: { L: 1360, W: 245, H: 265 },
              payload_kg: 24000,
              europallets: 33,
              grid_cm: 5,
            },
            {
              id: "trailer_13_6_h3",
              group: "TIR firanka/sztywka",
              name_pl: "TIR 13,6×2,45×2,8 m",
              inner_cm: { L: 1360, W: 245, H: 280 },
              payload_kg: 24000,
              europallets: 33,
              grid_cm: 5,
            },
            {
              id: "trailer_mega",
              group: "Naczepa Mega",
              name_pl: "Mega 13,6×2,48×3,0 m",
              inner_cm: { L: 1360, W: 248, H: 300 },
              payload_kg: 24000,
              europallets: 33,
              grid_cm: 5,
            },
            {
              id: "trailer_chlodnia",
              group: "Naczepa chłodnia",
              name_pl: "Chłodnia 13,3×2,45×2,6 m",
              inner_cm: { L: 1330, W: 245, H: 260 },
              payload_kg: 22000,
              europallets: 33,
              grid_cm: 5,
            },
          ];

          const I18N = {
            pl: {
              heading:
                "Ułóż ładunek. Sprawdzamy D/S/W i wagę – bez objętościowego czarowania.",
              sub: "Planowanie wymiarowe + reguły piętrowania. LDM tylko jako wskaźnik.",
              vehicle: "Pojazd",
              dims: "Wymiary (cm)",
              weight: "Waga (kg)",
              presets: "Szybkie presety",
              custom: "Własny element",
              rotate: "Obróć 90°",
              rotateL: "↶ 90°",
              rotateR: "↷ 90°",
              autopack: "Ułóż automatycznie",
              altpack: "Ułóż inaczej",
              reset: "Reset",
              save: "Zapisz",
              share: "Udostępnij",
              deleteSel: "Usuń zaznaczone",
              stackAll: "Spiętruj wszystko",
              volume_used: "Zajętość (m³)",
              weight_used: "Waga (kg)",
              fits_yes: "Mieści się",
              fits_no: "Nie mieści się",
              exceeds_payload: "Przekroczono ładowność o {kg} kg",
              quote: "Wycena transportu w 60 s",
              leftover: "Zapas L/W: {L} cm / {W} cm",
              undo: "Cofnij",
              redo: "Ponów",
              add: "Dodaj",
              stack: "×",
              remove: "Usuń",
              items: "Przedmioty",
              lang: "Język",
              lwh: "D×S×W",
              payload: "Ładowność",
              volume: "Objętość",
              pallets: "EUR palet",
              ldm: "LDM (szac.)",
              modal_title: "Szybka wycena (60 s)",
              route_from: "Skąd",
              route_to: "Dokąd",
              load: "Załadunek",
              unload: "Rozładunek",
              date: "Data",
              from: "od (godz)",
              to: "do (godz)",
              notes: "Uwagi",
              send: "Wyślij",
              cancel: "Anuluj",
              warn_big: "Wymiary przekraczają wymiary przestrzeni ładunkowej.",
              selected: "Wybrany element",
              qty: "Ilość",
              stack_ui: "Piętrowanie",
              suggestions: "Sugestie (co zdjąć / warianty)",
              invalid: "Uzupełnij wymagane pola",
              help_title: "Zasady prawidłowego załadunku (skrót)",
              variants: "Wariant",
              prev: "Poprzedni",
              next: "Następny",
              bulk_title: "Wklej opis ładunku (rozpoznamy liczby i wymiary)",
              bulk_btn: "Analizuj i dodaj",
              bulk_hint:
                "Przykłady: \n1pal 120x80x150/100kg \n4pal 120x100x170/250kg.       \n3 box 40x40x40/20kg \nSłowa kluczowe: pal/ep/eur, szt/colli.",
              stackable: "stackable",
              theme: "Motyw",
              add_vehicle: "Własny pojazd",
              create_vehicle: "Utwórz i wybierz",
            },
          };

          const PRESETS = [
            {
              id: "eur_pallet",
              label: "EP",
              dims: { L: 120, W: 80, H: 150 },
              weight: 350,
              stackable: true,
            },
            {
              id: "Pal_Przemyslowa",
              label: "Pal Przemyslowa",
              dims: { L: 120, W: 100, H: 150 },
              weight: 350,
              stackable: true,
            },
          ];

          // ===================== STATE =====================
          const mount = document.getElementById("van-pack");
          let lang = "pl";
          // Theme init — follow system preference automatically
          const prefersLight = matchMedia("(prefers-color-scheme: light)");
          let theme = prefersLight.matches ? "light" : "dark";
          mount.setAttribute("data-theme", theme);
          try {
            prefersLight.addEventListener('change', (e) => {
              const th = e.matches ? 'light' : 'dark';
              setTheme(th);
              try { renderAll(); try { if (document.documentElement.classList.contains('print')) { overlayLabels.updateAll(); } } catch(_){} } catch(_){}
            });
          } catch(_) {}

          const state = {
            vehicleIndex: 0,
            items: [], // {id,type,L,W,H,weight,stackable,stackCount,x,y,rot}
            selectedId: null,
            history: [],
            future: [],
            suggestions: [],
            clipboard: null,
            variants: { plans: [], index: 0 },
            viewMode: "2d",
            compareOn: false,
          };

          // -------- Minimalny store/dispatcher (MVP porządkowania stanu) --------
          // Ujednolica mutacje i odświeżanie, ułatwi kolejne kroki (A/B, przekrój, overlay osi).
          const Store = (() => {
            const listeners = [];
            return {
              get() {
                return state;
              },
              set(patch = {}) {
                Object.assign(state, patch);
                renderAll();
                listeners.forEach((fn) => {
                  try {
                    fn(state);
                  } catch (_) {}
                });
              },
              subscribe(fn) {
                listeners.push(fn);
                return () => {
                  const i = listeners.indexOf(fn);
                  if (i > -1) listeners.splice(i, 1);
                };
              },
              mutate(label, fn) {
                try {
                  pushHistory();
                  fn(state);
                  renderAll();
                } catch (e) {
                  console.error("Store.mutate fail:", label, e);
                }
              },
            };
          })();

          function t(key, vars = {}) {
            const str =
              key.split(".").reduce((o, k) => o && o[k], I18N[lang]) || key;
            return str.replace(
              /\{(\w+)\}/g,
              (_, k) => vars[k] ?? "{" + k + "}"
            );
          }
          function vehicle() {
            return VEHICLES[state.vehicleIndex];
          }

          // ===================== DOM BUILD =====================
          mount.innerHTML = `
        <div class="vp-wrap" role="region" aria-label="Van Pack">
          

          <!-- Welcome banner -->
          <div class="welcome-banner" id="welcomeBanner">
            <button class="close-btn" onclick="this.parentElement.style.display='none'">×</button>
            <div style="color: #065f46; font-size: 14px; line-height: 1.5;">
              <strong>Witaj!</strong> Cieszymy się, że zdecydowałeś się wypróbować VanFit. Obecnie korzystasz z wersji darmowej.
            </div>
          </div>

          <div class="topbar">
            <div>
              <div class="brand">
                <span class="brand-name">VanFit</span>
              </div>
              <div class="title">${t("heading")}</div>
              <div class="muted" style="color:var(--muted); font-size:.95rem">${t(
                "sub"
              )}</div>
            </div>
            <div class="theme" aria-label="${t("theme")}">
              <div style="color:var(--muted)">Motyw</div>
              <div class="toggle" id="themeToggle" role="button" aria-pressed="${
                theme === "light"
              }" tabindex="0" title="Przełącz motyw">
                <div class="knob" id="themeKnob">${
                  theme === "light" ? "☀" : "☾"
                }</div>
              </div>
            </div>
          </div>

          <div class="row" id="vehRow">
            <label for="vehSel">${t("vehicle")}</label>
            <select id="vehSel"></select>
            <div class="chip" id="vehDims"></div>
            <div class="chip" id="vehPayload"></div>
            <div class="chip" id="vehPallets"></div>
            <div class="chip" id="vehLDM"></div>
          </div>

          <!-- Przeniesione przyciski akcji dla wybranego elementu -->
          <div class="row" style="margin-top: 12px; gap: 8px; flex-wrap: wrap;">
            <button class="btn secondary" data-act="stack-+">${t("stack_ui")} +</button>
            <button class="btn secondary" data-act="stack--">${t("stack_ui")} −</button>
            <button class="btn secondary" data-act="delete">${t("remove")}</button>
          </div>

          <details class="vehbox">
            <summary>➕ ${t("add_vehicle")}</summary>
            <div class="vehgrid" style="margin-top:8px">
              <div class="row"><label>D (cm)</label><input type="number" id="vL" min="50" value="500"></div>
              <div class="row"><label>S (cm)</label><input type="number" id="vW" min="50" value="220"></div>
              <div class="row"><label>W (cm)</label><input type="number" id="vH" min="50" value="240"></div>
              <div class="row"><label>${t(
                "payload"
              )}</label><input type="number" id="vKg" min="0" value="3000"></div>
              <div class="row"><label>EP</label><input type="number" id="vEP" min="0" value="10"></div>
              <div class="row"><label>Grid (cm)</label><input type="number" id="vGrid" min="1" value="5"></div>
              <div class="row" style="grid-column:1/-1"><button class="btn" id="vCreate">${t(
                "create_vehicle"
              )}</button></div>
            </div>
          </details>

          <div class="grid">
            <div class="stage-card">
              <div class="stage-wrap">
                <svg class="board" tabindex="0" aria-label="Board"></svg>
                <!-- Overlay viewport: floor (canvas), overlay (svg), labels (div) -->
                <div id="viewport" aria-hidden="true">
                  <canvas id="floor"></canvas>
                  <svg id="overlay" aria-hidden="true"></svg>
                  <div id="labels" aria-live="polite"></div>
                </div>
                <canvas class="board3d" id="board3d" aria-label="Board 3D"></canvas>
                <div class="hud-layer" id="hudLayer"></div>
                <svg class="boardB" aria-label="Board B"></svg>
              </div>
              <div id="errBox" class="error" aria-hidden="true"></div>

              <!-- SIDE CUT (W×H at middle of length) -->
              <div class="section-cut">
                <div class="row" style="margin:0 0 6px 0;gap:8px;align-items:center;justify-content:space-between">
                  <span class="chip" id="secLabel">Przekrój (środek długości)</span>
                  <small style="color:var(--muted)">Widok Szerokość × Wysokość przy D=L/2</small>
                </div>
                <svg class="section" aria-label="Przekrój boczny"></svg>
              </div>

              <!-- UNDERBAR just under cargo area -->
              <div class="underbar">
                <!-- Metrics on the left -->
                <div class="metrics-bar" style="flex:1;display:flex;flex-wrap:wrap;gap:10px;align-items:center">
                  <div class="card">
                    <div style="display:flex;justify-content:space-between"><span>${t(
                      "volume_used"
                    )}</span><span id="volText"></span></div>
                    <progress id="volBar" value="0" max="100"></progress>
                  </div>
                  <div class="card">
                    <div style="display:flex;justify-content:space-between"><span>${t(
                      "weight_used"
                    )}</span><span id="kgText"></span></div>
                    <progress id="kgBar" value="0" max="100"></progress>
                  </div>
                  <span class="badge ok" id="fitBadge">${t("fits_yes")}</span>
                  <span class="badge" id="leftBadge"></span>
                  <span class="tiny" id="axleInfo" style="display:block;margin-top:4px"></span>
                  <div id="warnList" style="display:flex;gap:6px;flex-wrap:wrap;margin-top:4px"></div>
                </div>
                <!-- Actions on the right -->
                <div class="actions-bar" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:flex-end">
                  <button class="btn secondary" data-act="undo">⟲ ${t(
                    "undo"
                  )}</button>
                  <button class="btn secondary" data-act="redo">⟳ ${t(
                    "redo"
                  )}</button>
                  <button class="btn secondary" data-act="rotL">${
                    t("rotateL") || "↶ 90°"
                  }</button>
                  <button class="btn secondary" data-act="rotR">${
                    t("rotateR") || "↷ 90°"
                  }</button>
                  <button class="btn secondary" data-act="autopack">🤖 ${t(
                    "autopack"
                  )}</button>
                  <button class="btn secondary" data-act="altpack">🎲 ${t(
                    "altpack"
                  )}</button>
                  <button class="btn secondary" data-act="compare">🆚 A/B</button>
                  <button class="btn secondary" data-act="stackAll">🧱 ${t(
                    "stackAll"
                  )}</button>
                  <button class="btn secondary" data-act="prevVar">⬅ ${t(
                    "prev"
                  )}</button>
                  <span id="varLabel" class="chip" style="align-self:center">${t(
                    "variants"
                  )} 0/0</span>
                  <button class="btn secondary" data-act="nextVar">${t(
                    "next"
                  )} ➡</button>
                  <button class="btn secondary" id="view3D">🎥 3D widok</button>
                  <button class="btn ghost" data-act="delete">${t(
                    "deleteSel"
                  )}</button>
                  <button class="btn" data-act="quote">📦 ${t("quote")}</button>
                </div>
              </div>
            </div>

            <aside class="side">
              <h4>${t("bulk_title")}</h4>
              <div class="bulk">
                <textarea id="bulkText" rows="4" placeholder="${t(
                  "bulk_hint"
                )}"></textarea>
                <div class="row" style="margin-top:8px">
                  <button class="btn" id="bulkAdd">${t("bulk_btn")}</button>
                  <span class="note">Zrozumiemy: “6 pal 120x80”, “3 szt 180x20x20”, “6 eur palet 1600 kg”.</span>
                </div>
                <div id="bulkOut" class="out" aria-live="polite"></div>
              </div>

              <h4>${t("presets")}</h4>
              <div class="preset-list"></div>

              <h4>${t("custom")}</h4>
              <div class="custom-line">
                <input id="cOne" type="text" placeholder="np. 120x80x180x350 x2, 60x40x40x10 x10" />
                <label class="chk" style="margin:0"><input type="checkbox" id="cStack" checked><span>${t("stackable")}</span></label>
                <button class="btn" id="cAddOne">➕ ${t("add")}</button>
              </div>
              <div class="custom-hint">Format: D×S×W×kg opcjonalnie ×ilość; wiele pozycji oddziel przecinkami.</div>

              <div class="selected-panel" id="selPanel">
                <h4>${t("selected")}</h4>
                <!-- Przyciski zostały przeniesione nad sekcję "Własny pojazd" -->
              </div>

              <!-- Moved metrics and status into bottom bar -->

              <details>
                <summary>${t("help_title")}</summary>
                <ul style="margin:8px 0 0 18px; color:var(--muted)">
                  <li>Ciężkie sztuki bliżej środka (40–60% długości) i osi szerokości.</li>
                  <li>Unikaj przekroczeń szerokości i wysokości – to twarde ograniczenia.</li>
                  <li>Piętrowanie tylko gdy stabilne i nośność dolnej warstwy nie jest przekroczona.</li>
                  <li>Wysokie/wąskie elementy – nie przy samej burcie; dociśnij je innymi lub pasami.</li>
                  <li>LDM traktuj jako wskaźnik długości zajętej względem szerokości naczepy.</li>
                </ul>
              </details>

              <div class="actions">
                <button class="btn secondary" data-act="reset">${t(
                  "reset"
                )}</button>
                <button class="btn secondary" data-act="save">💾 ${t(
                  "save"
                )}</button>
                <button class="btn secondary" data-act="share">🔗 ${t(
                  "share"
                )}</button>
              </div>
            </aside>
          </div>
        </div>

        <div class="modal" id="vpModal" role="dialog" aria-modal="true" aria-labelledby="vpModalTitle">
          <div class="box">
            <h3 id="vpModalTitle">${t("modal_title")}</h3>
            <div id="summary" style="font-size:.95rem; color:var(--muted); margin-bottom:10px"></div>
            <div class="two">
              <input id="mFrom" placeholder="${t("route_from")} *">
              <input id="mTo" placeholder="${t("route_to")} *">
              <div>
                <div style="font-weight:600">${t("load")}</div>
                <div class="row" style="margin:6px 0 0 0">
                  <input type="date" id="ldate"> <input type="time" id="lfrom" placeholder="${t(
                    "from"
                  )}"> <input type="time" id="lto" placeholder="${t("to")}">
                </div>
              </div>
              <div>
                <div style="font-weight:600">${t("unload")}</div>
                <div class="row" style="margin:6px 0 0 0">
                  <input type="date" id="udate"> <input type="time" id="ufrom" placeholder="${t(
                    "from"
                  )}"> <input type="time" id="uto" placeholder="${t("to")}">
                </div>
              </div>
              <textarea id="mNotes" class="wide" rows="3" placeholder="${t(
                "notes"
              )}"></textarea>
            </div>
            <div class="foot">
              <button class="btn secondary" data-act="modal-cancel">${t(
                "cancel"
              )}</button>
              <button class="btn" data-act="modal-send">${t("send")}</button>
            </div>
          </div>
        </div>
      `;

          // Theme toggle
          const themeToggle = mount.querySelector("#themeToggle");
          const themeKnob = mount.querySelector("#themeKnob");
          function setTheme(th) {
            mount.setAttribute("data-theme", th);
            try { themeKnob.textContent = th === "light" ? "☀" : "☾"; } catch(_){}
            try { themeToggle?.setAttribute('aria-pressed', String(th === 'light')); } catch(_){}
          }
          // Disable manual theme toggle; theme follows system preference
          try {
            themeToggle?.setAttribute('aria-disabled','true');
            themeToggle?.setAttribute('title', 'Motyw ustawia się automatycznie wg systemu');
            themeToggle?.style?.setProperty('pointer-events','none');
            themeToggle?.addEventListener('click', (e) => { e.preventDefault(); });
            themeToggle?.addEventListener('keydown', (e) => {
              if (e.key === 'Enter' || e.key === ' ') e.preventDefault();
            });
          } catch(_) {}

          // Cache DOM
          const board = mount.querySelector("svg.board");
          const board3d = mount.querySelector("#board3d");
          const hudLayer = mount.querySelector("#hudLayer");
          const boardB = mount.querySelector("svg.boardB");
          const stageWrap = mount.querySelector(".stage-wrap");
          const section = mount.querySelector("svg.section");
          const secLabel = mount.querySelector("#secLabel");
          const vehSel = mount.querySelector("#vehSel");
          const specsDims = mount.querySelector("#vehDims");
          const specsPayload = mount.querySelector("#vehPayload");
          const specsPallets = mount.querySelector("#vehPallets");
          const specsLDM = mount.querySelector("#vehLDM");
          const presetList = mount.querySelector(".preset-list");
          const volBar = mount.querySelector("#volBar");
          const kgBar = mount.querySelector("#kgBar");
          const volText = mount.querySelector("#volText");
          const kgText = mount.querySelector("#kgText");
          const fitBadge = mount.querySelector("#fitBadge");
          const leftBadge = mount.querySelector("#leftBadge");
          const modal = mount.querySelector("#vpModal");
          const selPanel = mount.querySelector("#selPanel");
          const errBox = mount.querySelector("#errBox");
          const varLabel = mount.querySelector("#varLabel");
          const view3DBtn = mount.querySelector("#view3D");

          // Bulk parser elements
          const bulkText = mount.querySelector("#bulkText");
          const bulkAdd = mount.querySelector("#bulkAdd");
          const bulkOut = mount.querySelector("#bulkOut");

          // Add vehicle form element
          const vCreate = mount.querySelector("#vCreate");

          // ===================== UTIL =====================
          const uid = () => "it" + Math.random().toString(36).slice(2, 8);
          const deepClone = (obj) => JSON.parse(JSON.stringify(obj));
          function dispatchSelectionChange(){
            try { mount.dispatchEvent(new Event('selectionchange')); } catch(_) {}
          }

          function cm3ToM3(c) {
            return c / 1_000_000;
          }
          function volItem(it) {
            return cm3ToM3(it.L * it.W * it.H) * it.stackCount;
          }
          function weightItem(it) {
            return (it.weight || 0) * it.stackCount;
          }
          function dims2D(it) {
            const rotated = it.rot % 2 !== 0;
            return rotated ? { l: it.W, w: it.L } : { l: it.L, w: it.W };
          }
          
          // ===================== Overlay Labels (IIFE) =====================
          // Provides: buildLabel(item), layoutLabels(), updateAll(), worldToScreen(x,y)
          const overlayLabels = (() => {
            let viewport = mount.querySelector('#viewport');
            let floor = mount.querySelector('#floor');
            let overlay = mount.querySelector('#overlay');
            let labels = mount.querySelector('#labels');
            // Caches and helpers for label layout
            const labelSizeCache = new Map(); // Map<id, {w,h}>
            const placed = new Map(); // Map<id, {left,top,w,h}>
            let ro = null; // ResizeObserver for label content changes

            // Helper: parse CSS color to RGB array [r,g,b]
            function parseColor(c){
              if (!c) return [0,0,0];
              c = String(c).trim();
              // rgb/rgba
              let m = c.match(/^rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
              if (m) return [parseInt(m[1],10), parseInt(m[2],10), parseInt(m[3],10)];
              // hsl
              m = c.match(/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i);
              if (m) {
                const h = (+m[1]) % 360, s = (+m[2])/100, l = (+m[3])/100;
                function h2rgb(p,q,t){ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3-t)*6; return p; }
                let r,g,b; if (s === 0) { r=g=b=l; } else { const q = l < 0.5 ? l*(1+s) : l+s-l*s; const p = 2*l-q; r=h2rgb(p,q,(h/360)+1/3); g=h2rgb(p,q,(h/360)); b=h2rgb(p,q,(h/360)-1/3);} 
                return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
              }
              // hex #rgb or #rrggbb
              m = c.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
              if (m){
                let x = m[1];
                if (x.length===3) x = x.split('').map(ch=>ch+ch).join('');
                const n = parseInt(x,16);
                return [(n>>16)&255, (n>>8)&255, n&255];
              }
              return [0,0,0];
            }

            // Compute relative luminance (WCAG) and set contrasting styles
            function applyContrast(el, bgColor){
              const [r,g,b] = parseColor(bgColor);
              function toLin(u){ const c=u/255; return c<=0.03928? c/12.92 : Math.pow((c+0.055)/1.055,2.4); }
              const L = 0.2126*toLin(r) + 0.7152*toLin(g) + 0.0722*toLin(b);
              const isLight = L > 0.55; // threshold tuned for our palette
              if (isLight){
                el.style.color = '#111';
                el.style.background = 'rgba(255,255,255,0.88)';
                el.style.textShadow = '0 1px 1px rgba(0,0,0,0.18)';
                el.style.border = '1px solid rgba(0,0,0,0.08)';
              } else {
                el.style.color = '#fff';
                el.style.background = 'rgba(0,0,0,0.72)';
                el.style.textShadow = '0 1px 2px rgba(0,0,0,0.45)';
                el.style.border = '1px solid rgba(255,255,255,0.08)';
              }
            }

            function ensureDOM() {
              if (!viewport) {
                viewport = document.createElement('div');
                viewport.id = 'viewport';
                viewport.setAttribute('aria-hidden','true');
                stageWrap.appendChild(viewport);
              }
              if (!floor) {
                floor = document.createElement('canvas');
                floor.id = 'floor';
                viewport.appendChild(floor);
              }
              if (!overlay) {
                overlay = document.createElementNS('http://www.w3.org/2000/svg','svg');
                overlay.id = 'overlay';
                viewport.appendChild(overlay);
              }
              if (!labels) {
                labels = document.createElement('div');
                labels.id = 'labels';
                viewport.appendChild(labels);
              }
            }

            function worldToScreen(x, y) {
              const v = vehicle();
              const rect = stageWrap.getBoundingClientRect();
              const sx = (rect.width || 1) / Math.max(1, v.inner_cm.L);
              const sy = (rect.height || 1) / Math.max(1, v.inner_cm.W);
              // stageWrap and #viewport share the same origin (absolute inset:0)
              return { x: x * sx, y: y * sy, sx, sy };
            }

            function ensureObserver(){
              if (!ro) {
                try {
                  ro = new ResizeObserver((entries) => {
                    for (const entry of entries) {
                      const el = entry.target;
                      const id = el.getAttribute('data-id');
                      if (!id) continue;
                      labelSizeCache.delete(id);
                      // Re-pick position just for this item
                      const it = (state.items || []).find(x => String(x.id) === String(id));
                      if (it) {
                        try { pickPosition(it); } catch(_) {}
                      }
                    }
                  });
                } catch (_) {
                  ro = null;
                }
              }
            }

            function measureLabel(el){
              ensureDOM();
              if (!el) return { w: 0, h: 0 };
              const id = el.getAttribute('data-id') || '';
              const cached = labelSizeCache.get(id);
              if (cached) return cached;
              // Temporarily ensure visibility for measurement
              const prev = el.style.visibility;
              el.style.visibility = prev || '' ? prev : 'hidden';
              const r = el.getBoundingClientRect();
              const res = { w: Math.max(1, Math.round(r.width)), h: Math.max(1, Math.round(r.height)) };
              labelSizeCache.set(id, res);
              try { ensureObserver(); ro && ro.observe(el); } catch(_){}
              if (!prev) el.style.visibility = '';
              return res;
            }

            function rectArea(a){ return Math.max(0, a.w) * Math.max(0, a.h); }
            function intersectArea(a,b){
              const x1 = Math.max(a.left, b.left);
              const y1 = Math.max(a.top, b.top);
              const x2 = Math.min(a.left + a.w, b.left + b.w);
              const y2 = Math.min(a.top + a.h, b.top + b.h);
              const w = x2 - x1; const h = y2 - y1;
              return (w > 0 && h > 0) ? (w * h) : 0;
            }

            function getOtherBoxesRects(excludeId){
              const v = vehicle();
              const scale = worldToScreen(0,0);
              const out = [];
              for (const it of (state.items || [])){
                if (!it || String(it.id) === String(excludeId)) continue;
                if (it.overflow) continue; // only inside cargo area for scoring
                const { l, w } = dims2D(it);
                const left = it.x * scale.sx;
                const top  = it.y * scale.sy;
                out.push({ left, top, w: Math.max(1, l * scale.sx), h: Math.max(1, w * scale.sy) });
              }
              return out;
            }

            function getPlacedLabelRects(excludeId){
              const out = [];
              for (const [id, r] of placed.entries()){
                if (String(id) === String(excludeId)) continue;
                out.push({ left: r.left, top: r.top, w: r.w, h: r.h });
              }
              return out;
            }

            function pickPosition(item){
              ensureDOM();
              const el = buildLabel(item);
              const { w, h } = measureLabel(el);
              const v = vehicle();
              const scale = worldToScreen(0,0);
              const d = dims2D(item);
              // World rect (inside cargo area)
              let ix = item.x, iy = item.y;
              let il = d.l, iw = d.w;
              // Skip if overflowed out of hull: place in top-left as fallback
              if (item.overflow) {
                el.style.left = '4px'; el.style.top = '4px';
                placed.set(String(item.id), { left: 4, top: 4, w, h });
                return 'nw';
              }
              const left = ix * scale.sx; const top = iy * scale.sy;
              const bw = Math.max(1, il * scale.sx); const bh = Math.max(1, iw * scale.sy);
              const cx = left + bw / 2; const cy = top + bh / 2;
              const pad = 2;
              const candidates = ['center','nw','ne','sw','se'];
              const isPrint = document.documentElement.classList.contains('print');
              const mode = isPrint ? 'outside' : ((item.label && item.label.mode) || 'auto');
              const anchorPref = (item.label && item.label.anchor) || null;
              const anchors = (mode === 'inside' && anchorPref) ? [anchorPref] : candidates;

              const otherLabels = getPlacedLabelRects(item.id);
              const otherBoxes  = getOtherBoxesRects(item.id);

              let best = { score: Infinity, ax: 'center', rect: null };
              for (const a of anchors){
                let lx = left + (bw - w) / 2; let ly = top + (bh - h) / 2;
                if (a === 'nw') { lx = left + pad; ly = top + pad; }
                if (a === 'ne') { lx = left + bw - w - pad; ly = top + pad; }
                if (a === 'sw') { lx = left + pad; ly = top + bh - h - pad; }
                if (a === 'se') { lx = left + bw - w - pad; ly = top + bh - h - pad; }
                const rect = { left: Math.round(lx), top: Math.round(ly), w, h };
                // penalties
                let overlapL = 0; for (const r of otherLabels) overlapL += intersectArea(rect, r);
                let overlapB = 0; for (const r of otherBoxes) overlapB += intersectArea(rect, r);
                const lcx = rect.left + rect.w / 2; const lcy = rect.top + rect.h / 2;
                const dist2 = (lcx - cx) * (lcx - cx) + (lcy - cy) * (lcy - cy);
                // weights: labels >> boxes > distance
                const score = overlapL * 10 + overlapB * 2 + dist2 * 0.02;
                if (score < best.score) best = { score, ax: a, rect };
              }
              // fallback to outside if crowded, or if in print mode we force outside
              const overlapInside = (()=>{ let o=0; for(const r of otherLabels) o+=intersectArea(best.rect,r); for(const r of otherBoxes) o+=intersectArea(best.rect,r); return o;})();
              const crowded = (mode === 'auto') && (overlapInside / Math.max(1, w*h) > 0.30);
              let final = best;
              let leader = null;
              if (crowded || isPrint || mode === 'outside') {
                const outPad = Math.max(6, pad + 4);
                const rectE = { left: Math.round(left + bw + outPad), top: Math.round(cy - h/2), w, h };
                const rectW = { left: Math.round(left - w - outPad), top: Math.round(cy - h/2), w, h };
                // clamp Y within stage
                const stage = stageWrap.getBoundingClientRect();
                function clampY(r){ if (r.top < 2) r.top = 2; const maxY = (stage.height|0) - r.h - 2; if (r.top > maxY) r.top = maxY; }
                clampY(rectE); clampY(rectW);
                const stageCx = (stage.width || 1) / 2;
                const eDist = Math.abs((rectE.left + rectE.w/2) - stageCx);
                const wDist = Math.abs((rectW.left + rectW.w/2) - stageCx);
                final = (eDist <= wDist) ? { score: 0, ax: 'e-out', rect: rectE } : { score: 0, ax: 'w-out', rect: rectW };
                leader = (final.ax === 'e-out')
                  ? { x1: Math.round(left + bw), y1: Math.round(cy), x2: Math.round(final.rect.left), y2: Math.round(final.rect.top + final.rect.h/2) }
                  : { x1: Math.round(left), y1: Math.round(cy), x2: Math.round(final.rect.left + final.rect.w), y2: Math.round(final.rect.top + final.rect.h/2) };
              }
              el.style.left = final.rect.left + 'px';
              el.style.top  = final.rect.top + 'px';
              placed.set(String(item.id), final.rect);
              try { item.label = item.label || {}; item.label.anchor = final.ax; } catch(_){ }
              if (leader) {
                try {
                  const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
                  ln.setAttribute('x1', leader.x1); ln.setAttribute('y1', leader.y1);
                  ln.setAttribute('x2', leader.x2); ln.setAttribute('y2', leader.y2);
                  ln.setAttribute('class','leaderline');
                  overlay.appendChild(ln);
                } catch(_) {}
              }
              return final.ax;
            }

          function buildLabel(item) {
            ensureDOM();
            const id = String(item.id);
            let el = labels.querySelector(`.label[data-id="${CSS.escape(id)}"]`);
            if (!el) {
              el = document.createElement('div');
              el.className = 'label';
              el.dataset.id = id;
              labels.appendChild(el);
            }
            // Dimensions D×S×W: D/S from 2D oriented dims; W from height
            const d2 = dims2D(item);
            const D = d2.l ?? item.L ?? item.h ?? '—';
            const S = d2.w ?? item.W ?? item.w ?? '—';
            const W = item.H ?? item.height ?? '—';
            const kg = Math.max(0, item.weight || 0);
            const typ = item.type || '—';
            // Reset content and (re)build text + icons
            el.innerHTML = '';
            const body = document.createElement('span');
            body.className = 'body';
            body.textContent = `${D}×${S}×${W}, ${kg} kg, ${typ}`;
            body.title = body.textContent;
            el.appendChild(body);
            // Clear old icons, then append active ones
            el.querySelectorAll('svg.ico').forEach(n => n.remove());
            const flags = item.flags || {};
            function addIco(id){
              const sv = document.createElementNS('http://www.w3.org/2000/svg','svg');
              sv.setAttribute('class','ico');
              const use = document.createElementNS('http://www.w3.org/2000/svg','use');
              use.setAttribute('href', `#${id}`);
              sv.appendChild(use);
              el.appendChild(sv);
            }
            if (flags.noStack === true) addIco('i-nostack');
            if (flags.fragile === true) addIco('i-fragile');
            // Contrast vs the item background color
            try { applyContrast(el, getItemColor(item)); } catch (_) {}
            return el;
          }

            function layoutLabels() {
              ensureDOM();
              placed.clear();
              if (overlay) { try { overlay.innerHTML = ''; } catch(_){} }
              const ids = new Set();
              const items = (state.items || []).slice().filter(Boolean);
              // Larger boxes first
              items.sort((a,b) => {
                const da = dims2D(a), db = dims2D(b);
                return (db.l*db.w) - (da.l*da.w);
              });
              for (const it of items){
                ids.add(String(it.id));
                pickPosition(it);
              }
              // Remove labels for items that no longer exist
              Array.from(labels.querySelectorAll('.label')).forEach((n) => {
                if (!ids.has(n.getAttribute('data-id') || '')) n.remove();
              });
              // Highlight according to selection
              try { highlightSelected(); } catch(_) {}
            }

            function highlightSelected(){
              const sel = String(state.selectedId || '');
              Array.from(labels.querySelectorAll('.label')).forEach(el => {
                const on = (el.getAttribute('data-id') || '') === sel;
                el.classList.toggle('is-selected', !!on);
              });
            }

            function updateAll() {
              ensureDOM();
              try { layoutLabels(); } catch(_) {}
              viewport.style.display = 'block';
              viewport.setAttribute('aria-hidden', 'false');
              try { highlightSelected(); } catch(_) {}
            }

            // public API
            return { buildLabel, layoutLabels, updateAll, worldToScreen, measureLabel, pickPosition, highlightSelected };
          })();

          // Expose globally for debugging if needed
          window.overlayLabels = overlayLabels;
          // Keep label highlight in sync with selection changes
          try { mount.addEventListener('selectionchange', () => { try { overlayLabels.highlightSelected(); } catch (_) {} }); } catch (_) {}
          window.addEventListener('resize', () => {
            // try { overlayLabels.updateAll(); } catch (_) {}
          });
          function within(it, veh) {
            const { l, w } = dims2D(it);
            return (
              it.x >= 0 &&
              it.y >= 0 &&
              it.x + l <= veh.inner_cm.L &&
              it.y + w <= veh.inner_cm.W
            );
          }
          function overlap(a, b) {
            const A = dims2D(a),
              B = dims2D(b);
            return (
              a.x < b.x + B.l &&
              a.x + A.l > b.x &&
              a.y < b.y + B.w &&
              a.y + A.w > b.y
            );
          }
          function anyCollision(it, exceptId) {
            return state.items.some((x) => x.id !== exceptId && overlap(it, x));
          }
          function snap(v) {
            const g = vehicle().grid_cm;
            return Math.round(v / g) * g;
          }
          function meters(cm) {
            return cm / 100;
          }
          function ldmOf(it, veh) {
            const { l, w } = dims2D(it);
            return (
              meters(l) * (meters(w) / meters(veh.inner_cm.W)) * it.stackCount
            );
          }

          // Generate a distinct color for each item based on its position in the list and stack count.
          // This helps visually differentiate different cargo pieces and hints at stacking (lighter colors for higher stacks).
          function getItemColor(it) {
            // Stable color based on dimensions only (same D/S/W -> same color)
            const L = Math.max(it.L, it.W) | 0;
            const W = Math.min(it.L, it.W) | 0;
            const H = (it.H | 0) || 0;
            const key = `${L}x${W}x${H}`;
            let hash = 0;
            for (let i = 0; i < key.length; i++) {
              hash = (hash * 131 + key.charCodeAt(i)) % 360;
            }
            const hue = (hash + 360) % 360;
            const sat = 62;
            const light = mount.getAttribute("data-theme") === "light" ? 45 : 40;
            return `hsl(${hue}, ${sat}%, ${light}%)`;
          }

          function pushHistory() {
            state.history.push(
              deepClone({
                items: state.items,
                vehicleIndex: state.vehicleIndex,
              })
            );
            if (state.history.length > 50) state.history.shift();
            state.future.length = 0;
          }
          function undo() {
            const last = state.history.pop();
            if (!last) return;
            state.future.push(
              deepClone({
                items: state.items,
                vehicleIndex: state.vehicleIndex,
              })
            );
            state.items = deepClone(last.items);
            state.vehicleIndex = last.vehicleIndex;
            state.selectedId = null;
            renderAll();
          }
          function redo() {
            const next = state.future.pop();
            if (!next) return;
            pushHistory();
            state.items = deepClone(next.items);
            state.vehicleIndex = next.vehicleIndex;
            state.selectedId = null;
            renderAll();
          }

          function saveLocal() {
            localStorage.setItem(
              "vanpack_state",
              JSON.stringify({
                v: state.vehicleIndex,
                items: state.items,
                lang,
              })
            );
            alert("Zapisano w przeglądarce.");
          }
          function loadLocal() {
            try {
              const s = JSON.parse(localStorage.getItem("vanpack_state"));
              if (s) {
                state.vehicleIndex = s.v || 0;
                state.items = s.items || [];
                lang = s.lang || lang;
                // Theme follows system preference; ignore saved theme
              }
            } catch {}
          }
          function shareLink() {
            const data = btoa(
              unescape(
                encodeURIComponent(
                  JSON.stringify({
                    v: state.vehicleIndex,
                    items: state.items,
                    lang,
                    theme: mount.getAttribute("data-theme"),
                  })
                )
              )
            );
            const url = location.origin + location.pathname + "#vp=" + data;
            navigator.clipboard?.writeText(url);
            alert("Link skopiowany do schowka.");
          }
          function loadFromHash() {
            const m = location.hash.match(/#vp=([^&]+)/);
            if (!m) return false;
            try {
              const obj = JSON.parse(decodeURIComponent(escape(atob(m[1]))));
              state.vehicleIndex = obj.v || 0;
              state.items = obj.items || [];
              lang = obj.lang || lang;
              // Theme follows system preference; ignore saved theme
              return true;
            } catch {
              return false;
            }
          }
          function toSvgPoint(evt) {
            const pt = board.createSVGPoint();
            pt.x = evt.clientX;
            pt.y = evt.clientY;
            const sp = pt.matrixTransform(board.getScreenCTM().inverse());
            return { x: sp.x, y: sp.y };
          }
          function showError(msg) {
            errBox.textContent = msg;
            errBox.setAttribute("aria-hidden", "false");
            setTimeout(() => errBox.setAttribute("aria-hidden", "true"), 4000);
          }

          // ===================== VEHICLE UI =====================
          function renderVehSelect() {
            const groups = [
              ...new Set(VEHICLES.map((v) => v.group || "Pojazd")),
            ];
            vehSel.innerHTML = "";
            groups.forEach((g) => {
              const og = document.createElement("optgroup");
              og.label = g;
              VEHICLES.filter((v) => (v.group || "Pojazd") === g).forEach(
                (v) => {
                  const opt = document.createElement("option");
                  opt.value = String(VEHICLES.indexOf(v));
                  opt.textContent =
                    v.name_pl + (v.europallets ? ` • ${v.europallets} EP` : "");
                  og.appendChild(opt);
                }
              );
              vehSel.appendChild(og);
            });
            vehSel.value = String(state.vehicleIndex);
            vehSel.onchange = () => {
              if (
                state.items.length &&
                !confirm(
                  "Zmiana pojazdu zresetuje ułożone elementy. Kontynuować?"
                )
              ) {
                vehSel.value = String(state.vehicleIndex);
                return;
              }
              pushHistory();
              state.vehicleIndex = +vehSel.value;
              state.items = [];
              state.selectedId = null;
              state.variants = { plans: [], index: 0 };
              renderAll();
            };
          }

          vCreate.addEventListener("click", () => {
            const L = +mount.querySelector("#vL").value || 0;
            const W = +mount.querySelector("#vW").value || 0;
            const H = +mount.querySelector("#vH").value || 0;
            const Kg = +mount.querySelector("#vKg").value || 0;
            const EP = +mount.querySelector("#vEP").value || 0;
            const Grid = +mount.querySelector("#vGrid").value || 5;
            const id = "custom_" + Date.now();
            const name = `Custom ${L / 100}×${W / 100}×${H / 100} m`;
            Store.mutate("createVehicle", (s) => {
              VEHICLES.push({
                id,
                group: "Custom",
                name_pl: name,
                inner_cm: { L, W, H },
                payload_kg: Kg,
                europallets: EP,
                grid_cm: Grid,
              });
              s.vehicleIndex = VEHICLES.length - 1;
              s.items = [];
              s.selectedId = null;
              s.variants = { plans: [], index: 0 };
            });
          });

          function renderSpecs() {
            const v = vehicle();
            const capVol =
              (v.inner_cm.L * v.inner_cm.W * v.inner_cm.H) / 1_000_000;
            specsDims.textContent = `${t("lwh")}: ${v.inner_cm.L}×${
              v.inner_cm.W
            }×${v.inner_cm.H} cm`;
            specsPayload.textContent = `${t("payload")}: ${v.payload_kg} kg`;
            specsPallets.textContent = `${t("pallets")}: ${v.europallets}`;
            specsLDM.textContent = `${t("ldm")}: ~${(
              v.inner_cm.L / 100
            ).toFixed(1)} (max) • ${capVol.toFixed(1)} m³`;
          }

          // ===================== PRESETS =====================
          function renderPresets() {
            presetList.innerHTML = "";
            PRESETS.forEach((p) => {
              const row = document.createElement("div");
              row.className = "preset";
              const left = document.createElement("div");
              left.innerHTML = `<div style="font-weight:600">${p.label}</div><small>${p.dims.L}×${p.dims.W}×${p.dims.H} • ${p.weight} kg</small>`;
              const right = document.createElement("div");
              right.className = "qty";
              right.innerHTML = `<label>Ilość</label><input type="number" min="1" value="1"> <button class="btn secondary">Dodaj</button>`;
              right.querySelector("button").addEventListener("click", () => {
                const n = Math.max(1, +right.querySelector("input").value || 1);
                pushHistory();
                for (let i = 0; i < n; i++) {
                  addItemFromPreset(p, { autoPlace: true });
                }
                // Auto‑pack automatically when adding multiple items
                if (n > 1) {
                  autopackUltra(0, true);
                } else {
                  renderAll();
                }
              });
              row.appendChild(left);
              row.appendChild(right);
              presetList.appendChild(row);
            });
          }

          // ===================== SVG =====================
          function buildSVG() {
            const v = vehicle();
            // Extend viewBox to the right if we have overflow items to visualize outside cargo area
            const ovItems = (state.items || []).filter((it) => it && it.overflow);
            let pad = 0;
            if (ovItems.length) {
              // approximate needed columns based on total height
              const totalH = ovItems.reduce((s, it) => {
                const d = dims2D(it);
                return s + (d.w || 0) + 5;
              }, 0);
              const cols = Math.max(1, Math.ceil(totalH / Math.max(1, v.inner_cm.W)));
              const maxL = ovItems.reduce((m, it) => Math.max(m, dims2D(it).l || 0), 0);
              pad = cols * (maxL + 10) + 10; // some spacing
            }
            board.setAttribute("viewBox", `0 0 ${v.inner_cm.L + pad} ${v.inner_cm.W}`);
            board.innerHTML = "";
            hudLayer.innerHTML = "";
            // Global symbols/defs (icons etc.)
            const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
            // No‑stack icon: two boxes + strike-through
            const symNoStack = document.createElementNS('http://www.w3.org/2000/svg','symbol');
            symNoStack.setAttribute('id','i-nostack');
            symNoStack.setAttribute('viewBox','0 0 24 24');
            const nsR1 = document.createElementNS('http://www.w3.org/2000/svg','rect');
            nsR1.setAttribute('x','3'); nsR1.setAttribute('y','13'); nsR1.setAttribute('width','8'); nsR1.setAttribute('height','6'); nsR1.setAttribute('rx','1.2');
            const nsR2 = document.createElementNS('http://www.w3.org/2000/svg','rect');
            nsR2.setAttribute('x','13'); nsR2.setAttribute('y','5'); nsR2.setAttribute('width','8'); nsR2.setAttribute('height','6'); nsR2.setAttribute('rx','1.2');
            const nsSlash = document.createElementNS('http://www.w3.org/2000/svg','path');
            nsSlash.setAttribute('d','M4 20 L20 4'); nsSlash.setAttribute('fill','none'); nsSlash.setAttribute('stroke','currentColor'); nsSlash.setAttribute('stroke-width','2'); nsSlash.setAttribute('stroke-linecap','round');
            symNoStack.appendChild(nsR1); symNoStack.appendChild(nsR2); symNoStack.appendChild(nsSlash);
            defs.appendChild(symNoStack);
            // Fragile icon: wine glass + crack
            const symFragile = document.createElementNS('http://www.w3.org/2000/svg','symbol');
            symFragile.setAttribute('id','i-fragile');
            symFragile.setAttribute('viewBox','0 0 24 24');
            const frBowl = document.createElementNS('http://www.w3.org/2000/svg','path');
            frBowl.setAttribute('d','M6 3h12v4a6 6 0 0 1-6 6a6 6 0 0 1-6-6V3z');
            const frStem = document.createElementNS('http://www.w3.org/2000/svg','path');
            frStem.setAttribute('d','M12 13v5'); frStem.setAttribute('fill','none'); frStem.setAttribute('stroke','currentColor'); frStem.setAttribute('stroke-width','2'); frStem.setAttribute('stroke-linecap','round');
            const frBase = document.createElementNS('http://www.w3.org/2000/svg','rect');
            frBase.setAttribute('x','8'); frBase.setAttribute('y','20'); frBase.setAttribute('width','8'); frBase.setAttribute('height','2'); frBase.setAttribute('rx','1');
            const frCrack = document.createElementNS('http://www.w3.org/2000/svg','path');
            frCrack.setAttribute('d','M12 3l1.5 3l-2 2l2 1.5'); frCrack.setAttribute('fill','none'); frCrack.setAttribute('stroke','currentColor'); frCrack.setAttribute('stroke-width','1.8'); frCrack.setAttribute('stroke-linecap','round'); frCrack.setAttribute('stroke-linejoin','round');
            symFragile.appendChild(frBowl); symFragile.appendChild(frStem); symFragile.appendChild(frBase); symFragile.appendChild(frCrack);
            defs.appendChild(symFragile);
            board.appendChild(defs);
            const gGrid = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "g"
            );
            const step = v.grid_cm;
            for (let x = 0; x <= v.inner_cm.L; x += step) {
              const line = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line"
              );
              line.setAttribute("x1", x);
              line.setAttribute("y1", 0);
              line.setAttribute("x2", x);
              line.setAttribute("y2", v.inner_cm.W);
              line.setAttribute("class", "gridline");
              gGrid.appendChild(line);
            }
            for (let y = 0; y <= v.inner_cm.W; y += step) {
              const line = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line"
              );
              line.setAttribute("x1", 0);
              line.setAttribute("y1", y);
              line.setAttribute("x2", v.inner_cm.L);
              line.setAttribute("y2", y);
              line.setAttribute("class", "gridline");
              gGrid.appendChild(line);
            }
            board.appendChild(gGrid);
            const hull = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "rect"
            );
            hull.setAttribute("x", 0);
            hull.setAttribute("y", 0);
            hull.setAttribute("width", v.inner_cm.L);
            hull.setAttribute("height", v.inner_cm.W);
            hull.setAttribute("rx", 3);
            hull.setAttribute("class", "hull");
            board.appendChild(hull);
            // Ruler inside cargo space (top and left)
            const gRuler = document.createElementNS("http://www.w3.org/2000/svg", "g");
            const minor = Math.max(5, v.grid_cm);
            const major = 100; // cm
            // Top ruler (x-axis)
            for (let x = 0; x <= v.inner_cm.L; x += minor) {
              const t = document.createElementNS("http://www.w3.org/2000/svg", "line");
              t.setAttribute("x1", x);
              t.setAttribute("y1", 0);
              t.setAttribute("x2", x);
              t.setAttribute("y2", x % major === 0 ? 8 : 4);
              t.setAttribute("class", "rulerTick");
              gRuler.appendChild(t);
              if (x % major === 0) {
                const tx = document.createElementNS("http://www.w3.org/2000/svg", "text");
                tx.setAttribute("x", x + 1);
                tx.setAttribute("y", 10);
                tx.setAttribute("class", "rulerText");
                tx.textContent = String(x);
                gRuler.appendChild(tx);
              }
            }
            // Left ruler (y-axis)
            for (let y = 0; y <= v.inner_cm.W; y += minor) {
              const t = document.createElementNS("http://www.w3.org/2000/svg", "line");
              t.setAttribute("x1", 0);
              t.setAttribute("y1", y);
              t.setAttribute("x2", y % major === 0 ? 8 : 4);
              t.setAttribute("y2", y);
              t.setAttribute("class", "rulerTick");
              gRuler.appendChild(t);
              if (y % major === 0) {
                const ty = document.createElementNS("http://www.w3.org/2000/svg", "text");
                ty.setAttribute("x", 10);
                ty.setAttribute("y", y + 3);
                ty.setAttribute("class", "rulerText");
                ty.textContent = String(y);
                gRuler.appendChild(ty);
              }
            }
            board.appendChild(gRuler);
            // Section plane marker at middle of length
            const secx = v.inner_cm.L / 2;
            const sline = document.createElementNS("http://www.w3.org/2000/svg", "line");
            sline.setAttribute("x1", secx);
            sline.setAttribute("y1", 0);
            sline.setAttribute("x2", secx);
            sline.setAttribute("y2", v.inner_cm.W);
            sline.setAttribute("class", "sectionline");
            board.appendChild(sline);
            const gItems = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "g"
            );
            gItems.setAttribute("id", "gItems");
            board.appendChild(gItems);
          }

          // ===================== SIDE CUT RENDER (W×H at middle length) =====================
          function renderSection() {
            if (!section) return;
            const v = vehicle();
            const Xc = v.inner_cm.L / 2;
            if (secLabel) secLabel.textContent = `Przekrój D=${Math.round(Xc)} cm (środek)`;
            section.setAttribute("viewBox", `0 0 ${v.inner_cm.W} ${v.inner_cm.H}`);
            section.innerHTML = "";

            // grid
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            const step = Math.max(10, v.grid_cm);
            for (let x = 0; x <= v.inner_cm.W; x += step) {
              const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
              ln.setAttribute("x1", x);
              ln.setAttribute("y1", 0);
              ln.setAttribute("x2", x);
              ln.setAttribute("y2", v.inner_cm.H);
              ln.setAttribute("class", "sec-gridline");
              g.appendChild(ln);
            }
            for (let y = 0; y <= v.inner_cm.H; y += step) {
              const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
              ln.setAttribute("x1", 0);
              ln.setAttribute("y1", y);
              ln.setAttribute("x2", v.inner_cm.W);
              ln.setAttribute("y2", y);
              ln.setAttribute("class", "sec-gridline");
              g.appendChild(ln);
            }
            section.appendChild(g);

            // hull box (0..W, 0..H)
            const hull2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            hull2.setAttribute("x", 0);
            hull2.setAttribute("y", 0);
            hull2.setAttribute("width", v.inner_cm.W);
            hull2.setAttribute("height", v.inner_cm.H);
            hull2.setAttribute("rx", 3);
            hull2.setAttribute("class", "hull");
            section.appendChild(hull2);

            // items that intersect plane Xc
            const items = (state.items || []).filter((it) => !it.overflow);
            for (const it of items) {
              const d = dims2D(it);
              const x1 = it.x;
              const x2 = it.x + d.l;
              if (!(Xc >= x1 && Xc <= x2)) continue;
              const widthSpan = d.w;
              const heightSpan = (it.H || 0) * (it.stackCount || 1);
              if (heightSpan <= 0) continue;
              const x = Math.max(0, it.y);
              const w = Math.min(widthSpan, v.inner_cm.W - x);
              const h = Math.min(heightSpan, v.inner_cm.H);
              const y = Math.max(0, v.inner_cm.H - h);

              const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
              r.setAttribute("x", x);
              r.setAttribute("y", y);
              r.setAttribute("width", w);
              r.setAttribute("height", h);
              r.setAttribute("rx", 1.5);
              r.setAttribute("data-id", it.id);
              const col = getItemColor(it);
              // darken stroke slightly
              let strokeCol = col;
              const m = /hsl\((\d+),\s*(\d+)%\,\s*(\d+)%\)/.exec(col);
              if (m) {
                const h0 = m[1], s0 = m[2];
                let lval = parseInt(m[3], 10) - 18;
                if (lval < 5) lval = 5;
                strokeCol = `hsl(${h0}, ${s0}%, ${lval}%)`;
              }
              r.style.fill = col;
              r.style.stroke = state.selectedId === it.id ? 'var(--accent)' : strokeCol;
              r.style.strokeWidth = state.selectedId === it.id ? '1.6' : '0.8';
              r.style.cursor = 'pointer';
              section.appendChild(r);
            }
          }

          // ===================== 3D RENDER (isometric preview) =====================
          function hslParts(hsl) {
            const m = /hsl\((\d+),\s*(\d+)%\,\s*(\d+)%\)/.exec(hsl);
            if (!m) return { h: 215, s: 60, l: 42 };
            return { h: +m[1], s: +m[2], l: +m[3] };
          }
          function hslAdjust(hsl, dl) {
            const p = hslParts(hsl);
            const l = Math.max(0, Math.min(100, p.l + dl));
            return `hsl(${p.h}, ${p.s}%, ${l}%)`;
          }
          function projectIso(x, y, z, scale, ox, oy) {
            const px = (x - y) * 0.8660254 * scale + ox;
            const py = ((x + y) * 0.5 - z) * scale + oy;
            return { x: px, y: py };
          }
          function compute3DScaleOrigin(v, cw, ch) {
            // Approximate extents for isometric projection
            const rangeX = 0.8660254 * (v.inner_cm.L + v.inner_cm.W);
            const rangeY = 0.5 * (v.inner_cm.L + v.inner_cm.W) + v.inner_cm.H;
            const scale = 0.9 * Math.min(cw / Math.max(1, rangeX), ch / Math.max(1, rangeY));
            const ox = cw * 0.5;
            const oy = ch * 0.6; // slightly lower to leave room for hull
            return { scale, ox, oy };
          }
          function render3D() {
            if (!board3d) return;
            const rect = board3d.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const cw = Math.max(200, rect.width | 0);
            const ch = Math.max(200, rect.height | 0);
            if (board3d.width !== (cw * dpr)) {
              board3d.width = cw * dpr;
              board3d.height = ch * dpr;
            }
            const ctx = board3d.getContext("2d");
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, cw, ch);

            const v = vehicle();
            const { scale, ox, oy } = compute3DScaleOrigin(v, cw, ch);

            // Grid (floor)
            const gridStep = Math.max(20, v.grid_cm * 2);
            ctx.lineWidth = 1;
            ctx.strokeStyle = mount.getAttribute("data-theme") === "light" ? "#e6ecfb" : "#26334e";
            ctx.globalAlpha = 0.7;
            for (let x = 0; x <= v.inner_cm.L; x += gridStep) {
              const a = projectIso(x, 0, 0, scale, ox, oy);
              const b = projectIso(x, v.inner_cm.W, 0, scale, ox, oy);
              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(b.x, b.y);
              ctx.stroke();
            }
            for (let y = 0; y <= v.inner_cm.W; y += gridStep) {
              const a = projectIso(0, y, 0, scale, ox, oy);
              const b = projectIso(v.inner_cm.L, y, 0, scale, ox, oy);
              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(b.x, b.y);
              ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // Hull wireframe
            function line3(a, b, color, w = 1.4) {
              ctx.strokeStyle = color;
              ctx.lineWidth = w;
              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(b.x, b.y);
              ctx.stroke();
            }
            const hullPts = {
              A: projectIso(0, 0, 0, scale, ox, oy),
              B: projectIso(v.inner_cm.L, 0, 0, scale, ox, oy),
              C: projectIso(v.inner_cm.L, v.inner_cm.W, 0, scale, ox, oy),
              D: projectIso(0, v.inner_cm.W, 0, scale, ox, oy),
              Ap: projectIso(0, 0, v.inner_cm.H, scale, ox, oy),
              Bp: projectIso(v.inner_cm.L, 0, v.inner_cm.H, scale, ox, oy),
              Cp: projectIso(v.inner_cm.L, v.inner_cm.W, v.inner_cm.H, scale, ox, oy),
              Dp: projectIso(0, v.inner_cm.W, v.inner_cm.H, scale, ox, oy),
            };
            const hullLine = mount.getAttribute("data-theme") === "light" ? "#89a3ff" : "#3a4d77";
            line3(hullPts.A, hullPts.B, hullLine);
            line3(hullPts.B, hullPts.C, hullLine);
            line3(hullPts.C, hullPts.D, hullLine);
            line3(hullPts.D, hullPts.A, hullLine);
            line3(hullPts.Ap, hullPts.Bp, hullLine);
            line3(hullPts.Bp, hullPts.Cp, hullLine);
            line3(hullPts.Cp, hullPts.Dp, hullLine);
            line3(hullPts.Dp, hullPts.Ap, hullLine);
            line3(hullPts.A, hullPts.Ap, hullLine, 1.2);
            line3(hullPts.B, hullPts.Bp, hullLine, 1.2);
            line3(hullPts.C, hullPts.Cp, hullLine, 1.2);
            line3(hullPts.D, hullPts.Dp, hullLine, 1.2);

            // Items as prisms
            const items = state.items.map((it) => ({ it, d: it.x + it.y + (it.H * it.stackCount) * 0.3 }));
            items.sort((a, b) => a.d - b.d); // back to front

            for (const { it } of items) {
              const { l, w } = dims2D(it);
              const h = it.H * (it.stackCount || 1);
              const base = [
                projectIso(it.x, it.y, 0, scale, ox, oy),
                projectIso(it.x + l, it.y, 0, scale, ox, oy),
                projectIso(it.x + l, it.y + w, 0, scale, ox, oy),
                projectIso(it.x, it.y + w, 0, scale, ox, oy),
              ];
              const top = [
                projectIso(it.x, it.y, h, scale, ox, oy),
                projectIso(it.x + l, it.y, h, scale, ox, oy),
                projectIso(it.x + l, it.y + w, h, scale, ox, oy),
                projectIso(it.x, it.y + w, h, scale, ox, oy),
              ];
              const baseCol = getItemColor(it);
              const sideCol = hslAdjust(baseCol, -10);
              const topCol = hslAdjust(baseCol, +8);

              // top face
              ctx.fillStyle = topCol;
              ctx.strokeStyle = hslAdjust(baseCol, -15);
              ctx.lineWidth = 1.2;
              ctx.beginPath();
              ctx.moveTo(top[0].x, top[0].y);
              for (let i = 1; i < 4; i++) ctx.lineTo(top[i].x, top[i].y);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();

              // side faces (right and left)
              function poly(points, fill, stroke) {
                ctx.fillStyle = fill;
                ctx.strokeStyle = stroke;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
              }
              poly([top[1], top[2], base[2], base[1]], sideCol, hslAdjust(baseCol, -20));
              poly([top[0], top[1], base[1], base[0]], hslAdjust(sideCol, -4), hslAdjust(baseCol, -20));

              // front edge accents
              ctx.strokeStyle = hslAdjust(baseCol, -25);
              ctx.lineWidth = 1.1;
              ctx.beginPath();
              ctx.moveTo(base[0].x, base[0].y);
              ctx.lineTo(base[1].x, base[1].y);
              ctx.moveTo(base[1].x, base[1].y);
              ctx.lineTo(base[2].x, base[2].y);
              ctx.stroke();

              // subtle grid on top face to hint stacking
              const step = Math.max(20, v.grid_cm * 2);
              ctx.strokeStyle = hslAdjust(topCol, -12);
              ctx.lineWidth = 0.8;
              const nx = Math.max(1, Math.round(l / step));
              for (let i = 1; i < nx; i++) {
                const t = i / nx;
                const p1 = projectIso(it.x + l * t, it.y, h, scale, ox, oy);
                const p2 = projectIso(it.x + l * t, it.y + w, h, scale, ox, oy);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
              }
            }
          }

          function renderItems() {
            const g = board.querySelector("#gItems");
            g.innerHTML = "";
            hudLayer.innerHTML = "";
            const rect = board.getBoundingClientRect();
            const v = vehicle();
            const sx = rect.width / v.inner_cm.L,
              sy = rect.height / v.inner_cm.W;
            const pxPerCm = Math.min(sx, sy);
            const isCompact = pxPerCm < 3; // requirement: when zoomed out
            // defs for clipping labels inside items
            let defs = board.querySelector('defs');
            if (!defs) { defs = document.createElementNS('http://www.w3.org/2000/svg','defs'); board.insertBefore(defs, board.firstChild); }
            // Layout for overflow area to the right of the hull
            let colX = v.inner_cm.L + 5;
            let colY = 0;
            let colW = 0;
            state.items.forEach((it) => {
              const { l, w } = dims2D(it);
              // Determine drawing coordinates, moving overflow items to columns on the right
              let drawX = it.x;
              let drawY = it.y;
              if (it.overflow) {
                if (colY + w > v.inner_cm.W) {
                  // new column
                  colX += colW + 10;
                  colY = 0;
                  colW = 0;
                }
                drawX = colX;
                drawY = colY;
                colY += w + 5;
                if (l > colW) colW = l;
              }
              const r = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "rect"
              );
              r.setAttribute("x", drawX);
              r.setAttribute("y", drawY);
              r.setAttribute("width", l);
              r.setAttribute("height", w);
              r.setAttribute("rx", 1.5);
              r.setAttribute(
                "class",
                "item" + (state.selectedId === it.id ? " selected" : "")
              );
              r.setAttribute("data-id", it.id);
              r.setAttribute("tabindex", "0");
              // Apply dynamic color based on item index and stack count
              const col = getItemColor(it);
              // derive a darker color for the stroke by reducing lightness
              let strokeCol = col;
              const m = /hsl\((\d+),\s*(\d+)%\,\s*(\d+)%\)/.exec(col);
              if (m) {
                const h = m[1];
                const s = m[2];
                let lval = parseInt(m[3], 10) - 20;
                if (lval < 5) lval = 5;
                strokeCol = `hsl(${h}, ${s}%, ${lval}%)`;
              }
              // Set via style rather than attribute to ensure it overrides theme CSS
              r.style.fill = col;
              r.style.stroke = strokeCol;
              // Append base rectangle early so label measurement (getBBox) sees DOM
              g.appendChild(r);

              // Clip-path to keep indicators inside the rectangle
              const clipId = `cp_${it.id}`;
              const cp = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
              cp.setAttribute('id', clipId);
              const cpr = document.createElementNS('http://www.w3.org/2000/svg','rect');
              cpr.setAttribute('x', drawX); cpr.setAttribute('y', drawY);
              cpr.setAttribute('width', l); cpr.setAttribute('height', w);
              cp.appendChild(cpr);
              defs.appendChild(cp);

              // Choose contrasting label colors vs item fill
              let txtFill = '#f6f8ff', txtStroke = '#0b1020';
              if (m) {
                const light = parseInt(m[3], 10);
                if (light > 55) { // light item → darker text
                  txtFill = '#0b1020';
                  txtStroke = 'rgba(255,255,255,0.35)';
                }
              }
              // Centered, two-line label inside the pallet: first line D×S (compact) or D×S×W (normal), second line kg (×stack)
              const gLab = document.createElementNS('http://www.w3.org/2000/svg','g');
              gLab.setAttribute('clip-path', `url(#${clipId})`);
              const cx = drawX + l / 2;
              const cy = drawY + w / 2;
              const d2 = dims2D(it);
              const fullDims = `${d2.l}×${d2.w}×${it.H}`;
              const compactDims = `${d2.l}×${d2.w}`;
              const gText = document.createElementNS('http://www.w3.org/2000/svg','g');
              // main dims
              const labelDims = document.createElementNS('http://www.w3.org/2000/svg','text');
              labelDims.setAttribute('x', cx);
              labelDims.setAttribute('y', cy - 3);
              labelDims.setAttribute('text-anchor','middle');
              labelDims.setAttribute('dominant-baseline','middle');
              labelDims.setAttribute('class','label dimA');
              labelDims.style.fill = txtFill; labelDims.style.stroke = txtStroke;
              labelDims.textContent = isCompact ? compactDims : fullDims;
              gText.appendChild(labelDims);
              // secondary line: weight (+ stack count), hidden in compact via class/CSS
              const labelKg = document.createElementNS('http://www.w3.org/2000/svg','text');
              labelKg.setAttribute('x', cx);
              labelKg.setAttribute('y', cy + 7);
              labelKg.setAttribute('text-anchor','middle');
              labelKg.setAttribute('dominant-baseline','middle');
              labelKg.setAttribute('class','label dimB');
              labelKg.style.fill = txtFill; labelKg.style.stroke = txtStroke;
              const kgTxt = `${Math.max(0, it.weight||0)} kg${it.stackCount>1?` ×${it.stackCount}`:''}`;
              labelKg.textContent = kgTxt;
              gText.appendChild(labelKg);
              // Tooltip: always full
              const tip = `${fullDims}, ${Math.max(0, it.weight||0)} kg, ${it.type||'—'}`;
              gLab.setAttribute('title', tip);
              // Fit the two-line label into the rect (keep inside, scale down if needed)
              try {
                gLab.appendChild(gText);
                if (isCompact) gLab.classList.add('compact'); else gLab.classList.remove('compact');
                g.appendChild(gLab);
                const bbox = gText.getBBox();
                const pad = 4; // cm units
                const maxW = Math.max(1, l - pad);
                const maxH = Math.max(1, w - pad);
                const s = Math.min(1, Math.max(0.2, Math.min(maxW / Math.max(1, bbox.width), maxH / Math.max(1, bbox.height))));
                if (s < 1) {
                  const t = `translate(${cx},${cy}) scale(${s}) translate(${-cx},${-cy})`;
                  gText.setAttribute('transform', t);
                }
              } catch(_) {
                gLab.appendChild(gText);
                if (isCompact) gLab.classList.add('compact'); else gLab.classList.remove('compact');
                g.appendChild(gLab);
              }

              // Optional small icons inside the item rect (top‑right), clipped to item
              const flags = it.flags || {};
              if (flags.noStack || flags.fragile) {
                const iconSize = 4; // in cm (SVG units)
                let ix = drawX + l - iconSize - 1.5;
                const iy = drawY + 1.8;
                if (flags.noStack) {
                  const u1 = document.createElementNS('http://www.w3.org/2000/svg','use');
                  u1.setAttribute('href','#i-nostack');
                  u1.setAttribute('x', ix);
                  u1.setAttribute('y', iy);
                  u1.setAttribute('width', iconSize);
                  u1.setAttribute('height', iconSize);
                  u1.setAttribute('fill', txtFill);
                  gLab.appendChild(u1);
                  ix -= iconSize + 1;
                }
                if (flags.fragile) {
                  const u2 = document.createElementNS('http://www.w3.org/2000/svg','use');
                  u2.setAttribute('href','#i-fragile');
                  u2.setAttribute('x', ix);
                  u2.setAttribute('y', iy);
                  u2.setAttribute('width', iconSize);
                  u2.setAttribute('height', iconSize);
                  u2.setAttribute('fill', txtFill);
                  gLab.appendChild(u2);
                }
              }

              const bx = drawX + l - 3.5,
                by = drawY + 3.5;
              const rbHit = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              rbHit.setAttribute("cx", bx);
              rbHit.setAttribute("cy", by);
              rbHit.setAttribute("r", 7);
              rbHit.setAttribute("class", "rotHit");
              rbHit.setAttribute("data-rot", it.id);
              const rb = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              rb.setAttribute("cx", bx);
              rb.setAttribute("cy", by);
              rb.setAttribute("r", 3.2);
              rb.setAttribute("class", "rotBtn");
              rb.setAttribute("data-rot", it.id);
              const rbIcon = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              rbIcon.setAttribute("x", bx - 1.6);
              rbIcon.setAttribute("y", by + 1.3);
              rbIcon.setAttribute("class", "label");
              rbIcon.textContent = "↻";

              // gLab has been appended above for measurement
              g.appendChild(rbHit);
              g.appendChild(rb);
              g.appendChild(rbIcon);
            });
            selPanel.classList.toggle("active", !!state.selectedId);
          }

          function recalc() {
            const v = vehicle();
            let vol = 0,
              kg = 0,
              ldm = 0;
            state.items.forEach((it) => {
              vol += volItem(it);
              kg += weightItem(it);
              ldm += ldmOf(it, v);
            });
            const capVol =
              (v.inner_cm.L * v.inner_cm.W * v.inner_cm.H) / 1_000_000;
            volBar.max = 100;
            volBar.value = Math.min(100, (vol / capVol) * 100);
            kgBar.max = 100;
            kgBar.value = Math.min(100, (kg / v.payload_kg) * 100);
            volText.textContent = `${vol.toFixed(2)} / ${capVol.toFixed(1)} m³`;
            kgText.textContent = `${Math.round(kg)} / ${
              v.payload_kg
            } kg • LDM ~ ${ldm.toFixed(2)}`;

            const overload = kg - v.payload_kg;
            fitBadge.className = "badge " + (overload > 0 ? "bad" : "ok");
            fitBadge.textContent =
              overload > 0
                ? `Przekroczono ładowność o ${Math.abs(
                    Math.round(overload)
                  )} kg`
                : t("fits_yes");

            let maxX = 0,
              usedWidth = 0;
            const rows = buildShelvesSnapshot();
            rows.forEach((row) => {
              maxX = Math.max(maxX, row.x);
              usedWidth += row.h;
            });
            leftBadge.textContent = t("leftover", {
              L: Math.max(0, v.inner_cm.L - Math.round(maxX)),
              W: Math.max(0, v.inner_cm.W - Math.round(usedWidth)),
            });

            // Update axle load info + warnings/suggestion after recalculation
            warnAndSuggest();
          }

          // Compute distribution across axles with optional vehicle.ax {front,rear,fmax,rmax}
          // Returns detailed metrics and updates the UI summary line.
          function computeAxleLoads(items, veh) {
            const infoEl = mount.querySelector("#axleInfo");
            const ax = veh.ax || {};
            const L = veh.inner_cm?.L || 0;
            const frontPos = Number(ax.front ?? 0); // cm from origin (front)
            const rearPos = Number(ax.rear ?? L);   // cm from origin (rear axle position)
            const fmax = Number(ax.fmax ?? veh.front_axle_kg ?? 0) || 0;
            const rmax = Number(ax.rmax ?? veh.rear_axle_kg ?? 0) || 0;

            // Total weight considering stacking
            let totalKg = 0, cxSum = 0;
            for (const it of items) {
              const kg = weightItem(it); // already multiplies by stackCount
              const { l } = dims2D(it);
              const cx = (Number(it.x) || 0) + l / 2; // cm from front
              totalKg += kg;
              cxSum += kg * cx;
            }
            // Center of mass along length
            const Cx = totalKg ? cxSum / totalKg : (L || 0) / 2;
            const span = Math.max(1, (rearPos - frontPos));
            // Simple beam reaction forces (front and rear supports)
            let Rf = totalKg * (rearPos - Cx) / span; // front reaction
            let Rr = totalKg - Rf;                    // rear reaction
            // Guard against tiny negatives from rounding
            Rf = Math.max(0, Rf);
            Rr = Math.max(0, Rr);

            const res = {
              front_kg: Math.round(Rf),
              rear_kg: Math.round(Rr),
              front_pct: fmax ? Math.round((Rf / fmax) * 100) : 0,
              rear_pct: rmax ? Math.round((Rr / rmax) * 100) : 0,
              totalKg: Math.round(totalKg),
              cx_cm: Math.round(Cx),
            };

            if (infoEl) {
              if (!totalKg) {
                infoEl.textContent = "Brak danych o osiach";
              } else {
                const pctF = fmax ? ` (${res.front_pct}%${res.front_pct>100?"!":""})` : "";
                const pctR = rmax ? ` (${res.rear_pct}%${res.rear_pct>100?"!":""})` : "";
                infoEl.textContent = `Całkowita: ${res.totalKg} kg • Przód: ${res.front_kg} kg${pctF} • Tył: ${res.rear_kg} kg${pctR}`;
              }
            }
            return res;
          }

          // Build warnings + simple vehicle suggestion based on axle and payload
          function warnAndSuggest() {
            const v = vehicle();
            const ax = computeAxleLoads(state.items || [], v);
            const warnings = [];
            if (ax.front_pct > 100) warnings.push(`Przeciążona oś przednia: ${ax.front_pct}%`);
            if (ax.rear_pct > 100) warnings.push(`Przeciążona oś tylna: ${ax.rear_pct}%`);
            if ((state.items || []).some((it) => (it.H || 0) > v.inner_cm.H)) warnings.push("Za wysokie elementy vs wnętrze");
            if ((state.items || []).some((it) => it.stackable === false)) warnings.push("Pozycje niepiętrowalne");
            const totalKg = (state.items || []).reduce((s, it) => s + weightItem(it), 0);
            if (totalKg > v.payload_kg) warnings.push("Sugeruję większy pojazd (przekroczono ładowność).");
            const notPlaced = (state.items || []).filter((it) => it && it.overflow).length;
            if (notPlaced > 0) warnings.push(`Nie zmieściło się: ${notPlaced} szt. (poza ładownią)`);

            state.warnings = warnings;
            const warnEl = mount.querySelector('#warnList');
            if (warnEl) {
              warnEl.innerHTML = '';
              if (!warnings.length) {
                warnEl.style.display = 'none';
              } else {
                warnEl.style.display = 'flex';
                for (const w of warnings) {
                  const b = document.createElement('span');
                  b.className = 'badge bad';
                  b.textContent = w;
                  warnEl.appendChild(b);
                }
              }
            }
            return ax;
          }

          function buildShelvesSnapshot() {
            const v = vehicle();
            const items = state.items.map((it) => ({ ...it, ...dims2D(it) }));
            items.sort((a, b) => b.w - a.w);
            const shelves = [];
            let y = 0;
            items.forEach((it) => {
              let placed = false;
              for (const sh of shelves) {
                if (
                  it.w <= v.inner_cm.W - sh.y &&
                  sh.x + it.l <= v.inner_cm.L
                ) {
                  sh.x += it.l;
                  sh.h = Math.max(sh.h, it.w);
                  placed = true;
                  break;
                }
              }
              if (!placed) {
                if (y + it.w <= v.inner_cm.W) {
                  shelves.push({ x: it.l, h: it.w, y });
                  y += it.w;
                }
              }
            });
            return shelves;
          }

          function renderAll() {
            renderVehSelect();
            renderSpecs();
            if (state.viewMode === "3d") {
              // show 3D canvas, hide 2D SVG + HUD
              board.style.display = "none";
              hudLayer.style.display = "none";
              board3d.style.display = "block";
              stageWrap?.classList.remove('compare');
              if (boardB) boardB.style.display = 'none';
              render3D();
              // Hide overlay in 3D mode
              try {
                const vp = mount.querySelector('#viewport');
                if (vp) { vp.style.display = 'none'; vp.setAttribute('aria-hidden','true'); }
              } catch(_) {}
            } else {
              board3d.style.display = "none";
              hudLayer.style.display = "block";
              board.style.display = "block";
              buildSVG();
              renderItems();
              // Overlay labels: enabled only for print mode (outside labels with leaders)
              try {
                if (document.documentElement.classList.contains('print')) {
                  overlayLabels.updateAll();
                }
              } catch (_) {}
              if (state.compareOn && state.variants?.plans?.length) {
                stageWrap?.classList.add('compare');
                if (boardB) boardB.style.display = 'block';
                renderCompareB();
              } else {
                stageWrap?.classList.remove('compare');
                if (boardB) boardB.style.display = 'none';
              }
            }
            renderAxleOverlay();
            renderSection();
            recalc();
            bindItemEvents();
            updateVariantLabel();
            // Update overlay labels at end of render (print/outside case)
            try { if (document.documentElement.classList.contains('print')) { overlayLabels.updateAll(); } } catch(_){}
          }

          function renderAxleOverlay() {
            if (!board) return;
            const v = vehicle();
            const old = board.querySelector('#gAxle');
            if (old) old.remove();
            if (!state.items.length) return;
            const ax = computeAxleLoads(state.items, v);
            if (!ax || !isFinite(ax.cx_cm)) return;
            const g = document.createElementNS('http://www.w3.org/2000/svg','g');
            g.setAttribute('id','gAxle');
            // CoG line
            const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
            ln.setAttribute('x1', ax.cx_cm);
            ln.setAttribute('y1', 0);
            ln.setAttribute('x2', ax.cx_cm);
            ln.setAttribute('y2', v.inner_cm.W);
            ln.setAttribute('class','axline');
            g.appendChild(ln);
            // CoG marker (middle width)
            const mk = document.createElementNS('http://www.w3.org/2000/svg','circle');
            mk.setAttribute('cx', ax.cx_cm);
            mk.setAttribute('cy', Math.max(6, Math.min(v.inner_cm.W-6, v.inner_cm.W/2)));
            mk.setAttribute('r', 2.6);
            mk.setAttribute('class','axmark');
            g.appendChild(mk);
            // Bars for front/rear loads (relative to max if available, else to total)
            const hb = 4; // height of bar
            const pad = 1;
            const fRatio = (ax.front_pct && ax.front_pct>0) ? Math.min(1, ax.front_pct/100) : (ax.front_kg/(ax.front_kg+ax.rear_kg||1));
            const rRatio = (ax.rear_pct && ax.rear_pct>0) ? Math.min(1, ax.rear_pct/100) : (ax.rear_kg/(ax.front_kg+ax.rear_kg||1));
            const fRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
            fRect.setAttribute('x', pad);
            fRect.setAttribute('y', pad);
            fRect.setAttribute('width', Math.max(2, (v.inner_cm.L/2 - 2*pad) * fRatio));
            fRect.setAttribute('height', hb);
            fRect.setAttribute('class','axbar');
            g.appendChild(fRect);
            const rRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
            const rightX = v.inner_cm.L/2 + pad;
            rRect.setAttribute('x', rightX);
            rRect.setAttribute('y', pad);
            rRect.setAttribute('width', Math.max(2, (v.inner_cm.L/2 - 2*pad) * rRatio));
            rRect.setAttribute('height', hb);
            rRect.setAttribute('class','axbar');
            g.appendChild(rRect);
            // Texts
            const tf = document.createElementNS('http://www.w3.org/2000/svg','text');
            tf.setAttribute('x', pad+2);
            tf.setAttribute('y', hb + pad + 3);
            tf.setAttribute('class','axtext');
            tf.textContent = `F ${ax.front_kg} kg${ax.front_pct?` (${ax.front_pct}%)`:''}`;
            g.appendChild(tf);
            const tr = document.createElementNS('http://www.w3.org/2000/svg','text');
            tr.setAttribute('x', rightX + 2);
            tr.setAttribute('y', hb + pad + 3);
            tr.setAttribute('class','axtext');
            tr.textContent = `R ${ax.rear_kg} kg${ax.rear_pct?` (${ax.rear_pct}%)`:''}`;
            g.appendChild(tr);
            board.appendChild(g);
          }

          function renderCompareB() {
            if (!boardB) return;
            const v = vehicle();
            // Pick next variant as B (wrap if needed)
            let idxB = (state.variants?.index ?? 0) + 1;
            const n = state.variants?.plans?.length || 0;
            if (!n) return;
            idxB = idxB % n;
            const itemsB = deepClone(state.variants.plans[idxB] || state.items || []);

            // Compute overflow padding similar to buildSVG()
            const ovItems = (itemsB || []).filter((it) => it && it.overflow);
            let pad = 0;
            if (ovItems.length) {
              const totalH = ovItems.reduce((s, it) => {
                const d = dims2D(it);
                return s + (d.w || 0) + 5;
              }, 0);
              const cols = Math.max(1, Math.ceil(totalH / Math.max(1, v.inner_cm.W)));
              const maxL = ovItems.reduce((m, it) => Math.max(m, dims2D(it).l || 0), 0);
              pad = cols * (maxL + 10) + 10;
            }
            boardB.setAttribute('viewBox', `0 0 ${v.inner_cm.L + pad} ${v.inner_cm.W}`);
            boardB.innerHTML = '';
            // grid
            const gGrid = document.createElementNS('http://www.w3.org/2000/svg','g');
            const step = v.grid_cm;
            for (let x = 0; x <= v.inner_cm.L; x += step) {
              const line = document.createElementNS('http://www.w3.org/2000/svg','line');
              line.setAttribute('x1', x); line.setAttribute('y1', 0);
              line.setAttribute('x2', x); line.setAttribute('y2', v.inner_cm.W);
              line.setAttribute('class','gridline');
              gGrid.appendChild(line);
            }
            for (let y = 0; y <= v.inner_cm.W; y += step) {
              const line = document.createElementNS('http://www.w3.org/2000/svg','line');
              line.setAttribute('x1', 0); line.setAttribute('y1', y);
              line.setAttribute('x2', v.inner_cm.L); line.setAttribute('y2', y);
              line.setAttribute('class','gridline');
              gGrid.appendChild(line);
            }
            boardB.appendChild(gGrid);
            // hull
            const hull = document.createElementNS('http://www.w3.org/2000/svg','rect');
            hull.setAttribute('x',0); hull.setAttribute('y',0);
            hull.setAttribute('width', v.inner_cm.L);
            hull.setAttribute('height', v.inner_cm.W);
            hull.setAttribute('rx',3);
            hull.setAttribute('class','hull');
            boardB.appendChild(hull);

            // items (static preview)
            let colX = v.inner_cm.L + 5, colY = 0, colW = 0;
            for (const it of itemsB) {
              const { l, w } = dims2D(it);
              let drawX = it.x, drawY = it.y;
              if (it.overflow) {
                if (colY + w > v.inner_cm.W) { colX += colW + 10; colY = 0; colW = 0; }
                drawX = colX; drawY = colY; colY += w + 5; if (l > colW) colW = l;
              }
              const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
              r.setAttribute('x', drawX); r.setAttribute('y', drawY);
              r.setAttribute('width', l); r.setAttribute('height', w);
              r.setAttribute('rx', 1.5); r.setAttribute('class','item');
              const col = getItemColor(it);
              let strokeCol = col; const m = /hsl\((\d+),\s*(\d+)%\,\s*(\d+)%\)/.exec(col);
              if (m) { const h=m[1], s=m[2]; let lv=parseInt(m[3],10)-20; if (lv<5) lv=5; strokeCol=`hsl(${h}, ${s}%, ${lv}%)`; }
              r.style.fill = col; r.style.stroke = strokeCol;
              boardB.appendChild(r);
            }
          }

          // ===================== ITEMS API =====================
          function addItemFromPreset(p, opts = {}) {
            const it = {
              id: uid(),
              type: p.id,
              ...p.dims,
              weight: p.weight,
              stackable: p.stackable !== false,
              stackCount: 1,
              x: 0,
              y: 0,
              rot: 0,
              flags: (p.stackable === false) ? { noStack: true } : { }
            };
            if (opts.autoPlace) placeNewItem(it);
            state.items.push(it);
            state.selectedId = it.id;
            dispatchSelectionChange();
          }

          function addCustomLine() {
            const raw = (mount.querySelector('#cOne')?.value || '').trim();
            const stackable = !!mount.querySelector('#cStack')?.checked;
            if (!raw) { showError('Podaj D×S×W×kg (opcjonalnie ×ilość)'); return; }
            // Split by commas/semicolon/newline
            const segs = raw.split(/[;,\n]+/).map(s => s.trim()).filter(Boolean);
            const RX = /^\s*(\d+(?:[.,]\d+)?)\s*[x×*]\s*(\d+(?:[.,]\d+)?)\s*[x×*]\s*(\d+(?:[.,]\d+)?)\s*[x×*]\s*(\d+(?:[.,]\d+)?)(?:\s*[x×*]\s*(\d+))?\s*$/i;
            let added = 0;
            pushHistory();
            for (const s of segs) {
              const m = s.match(RX);
              if (!m) continue;
              let L = Math.round(parseFloat(String(m[1]).replace(',', '.')));
              let W = Math.round(parseFloat(String(m[2]).replace(',', '.')));
              let H = Math.round(parseFloat(String(m[3]).replace(',', '.')));
              let Kg = Math.round(parseFloat(String(m[4]).replace(',', '.')));
              const Q = Math.max(1, parseInt(m[5] || '1', 10));
              if (L < W) { const tmp=L; L=W; W=tmp; }
              for (let i=0;i<Q;i++){
                const it = { id: uid(), type: 'custom', L, W, H, weight: Kg, stackable, stackCount: 1, x:0, y:0, rot:0, flags: stackable ? {} : { noStack: true } };
                placeNewItem(it);
                state.items.push(it);
                added++;
              }
            }
            if (!added) { showError('Format: 120x80x180x350 [x2]'); return; }
            if (added > 1) autopackUltra(0, true); else renderAll();
            const inp = mount.querySelector('#cOne'); if (inp) inp.value = '';
          }

          function rotateSelected(dir) {
            const it = state.items.find((x) => x.id === state.selectedId);
            if (!it) return;
            pushHistory();
            it.rot = ((it.rot || 0) + (dir || 1) + 4) % 4;
            const v = vehicle();
            const { l, w } = dims2D(it);
            if (it.x + l > v.inner_cm.L) it.x = v.inner_cm.L - l;
            if (it.y + w > v.inner_cm.W) it.y = v.inner_cm.W - w;
            renderAll();
          }
          function deleteSelected() {
            const i = state.items.findIndex((x) => x.id === state.selectedId);
            if (i > -1) {
              pushHistory();
              state.items.splice(i, 1);
              state.selectedId = null;
              renderAll();
              dispatchSelectionChange();
            }
          }
          function changeStack(delta) {
            const it = state.items.find((x) => x.id === state.selectedId);
            if (!it || !it.stackable) return;
            const v = vehicle();
            const max = Math.max(1, Math.floor(v.inner_cm.H / it.H));
            it.stackCount = Math.min(max, Math.max(1, it.stackCount + delta));
            renderAll();
          }

          function stackAll() {
            pushHistory();
            const v = vehicle();
            const groups = new Map();
            for (const it of state.items) {
              const key = [
                it.type,
                it.L,
                it.W,
                it.H,
                it.weight,
                it.stackable ? "1" : "0",
              ].join("|");
              const arr = groups.get(key) || [];
              arr.push(it);
              groups.set(key, arr);
            }
            const next = [];
            for (const [key, arr] of groups.entries()) {
              const a = arr[0];
              if (!a.stackable) {
                next.push(...arr);
                continue;
              }
              const cap = Math.max(1, Math.floor(v.inner_cm.H / a.H));
              let total = arr.reduce((s, x) => s + x.stackCount, 0);
              while (total > 0) {
                const cnt = Math.min(cap, total);
                next.push({
                  ...deepClone(a),
                  id: uid(),
                  x: 0,
                  y: 0,
                  stackCount: cnt,
                });
                total -= cnt;
              }
            }
            state.items = next;
            renderAll();
          }

          // Copy/Paste
          function copySelected() {
            const it = state.items.find((x) => x.id === state.selectedId);
            if (!it) return;
            state.clipboard = deepClone(it);
            showError("Skopiowano wybrany element");
          }
          function pasteClipboard() {
            if (!state.clipboard) {
              showError("Schowek pusty");
              return;
            }
            pushHistory();
            const base = deepClone(state.clipboard);
            base.id = uid();
            const sel = state.items.find((x) => x.id === state.selectedId);
            if (sel) {
              const sD = dims2D(sel);
              const cand = [
                { x: snap(sel.x + sD.l + vehicle().grid_cm), y: sel.y },
                { x: sel.x, y: snap(sel.y + sD.w + vehicle().grid_cm) },
              ];
              for (const c of cand) {
                base.x = c.x;
                base.y = c.y;
                if (
                  within({ ...base }, vehicle()) &&
                  !anyCollision({ ...base }, null)
                ) {
                  state.items.push(base);
                  state.selectedId = base.id;
                  renderAll();
                  dispatchSelectionChange();
                  return;
                }
              }
            }
            placeNewItem(base);
            state.items.push(base);
            state.selectedId = base.id;
            renderAll();
            dispatchSelectionChange();
          }

          // ===================== AUTOPACK / VARIANTS =====================
          function computePlan(items, v, seed) {
            for (const it of items) {
              if (
                Math.min(it.W, it.L) > v.inner_cm.W &&
                Math.max(it.W, it.L) > v.inner_cm.W
              )
                return {
                  placed: [],
                  unplaced: items,
                  free: [{ x: 0, y: 0, w: v.inner_cm.L, h: v.inner_cm.W }],
                };
              if (it.H > v.inner_cm.H)
                return {
                  placed: [],
                  unplaced: items,
                  free: [{ x: 0, y: 0, w: v.inner_cm.L, h: v.inner_cm.W }],
                };
            }
            let free = [{ x: 0, y: 0, w: v.inner_cm.L, h: v.inner_cm.W }],
              placed = [],
              unplaced = [];
            items.sort((a, b) =>
              seed % 3 === 0
                ? Math.max(b.W, b.L) - Math.max(a.W, a.L) ||
                  Math.min(b.W, b.L) - Math.min(a.W, a.L)
                : Math.max(b.L, b.W) - Math.max(a.L, a.W) || b.W - a.W
            );
            for (const it of items) {
              let best = null;
              let chosenRot = 0;
              for (const o of seed % 2 ? [1, 0] : [0, 1]) {
                const tmp = { ...it, rot: o };
                const { l, w } = dims2D(tmp);
                const spot = bestFreeRect(free, l, w);
                if (spot) {
                  const waste = spot.w * spot.h - l * w;
                  if (!best || waste < best.waste) {
                    best = { rect: spot, waste, l, w };
                    chosenRot = o;
                  }
                }
              }
              if (!best) {
                unplaced.push(it);
                continue;
              }
              it.rot = chosenRot;
              it.x = best.rect.x;
              it.y = best.rect.y;
              placed.push(it);
              free = guillotineSplitAndNormalize(free, best.rect, {
                l: best.l,
                w: best.w,
              });
            }
            if (unplaced.length) {
              const out = shelfPack(unplaced, v, placed, free);
              placed = out.placed;
              unplaced = out.unplaced;
              free = out.free;
            }
            return { placed, unplaced, free };
          }

          function autopackUltra(seed = 0, allowAutoStack = true) {
            pushHistory();
            const v = vehicle();
            const items = state.items.map((it) => ({ ...it }));
            const totalKg = items.reduce((s, it) => s + weightItem(it), 0);
            if (totalKg > v.payload_kg) {
              showError(`Za ciężko o ${Math.round(totalKg - v.payload_kg)} kg`);
            }

            const seeds = [0, 1, 2, 3, 4].map((s) => (s + seed) % 7);
            const plans = seeds.map((s) => computePlan(deepClone(items), v, s));
            const scored = plans
              .map((p, i) => ({
                i,
                un: p.unplaced.length,
                waste: p.free.reduce((a, r) => a + r.w * r.h, 0),
              }))
              .sort((a, b) => a.un - b.un || a.waste - b.waste);
            state.variants = {
              plans: plans.map((p) => {
                const placed = p.placed.map((x) => ({ ...x, overflow: false }));
                const unplaced = p.unplaced.map((x) => ({ ...x, overflow: true }));
                return placed.concat(unplaced);
              }),
              index: scored[0].i,
            };
            applyVariant(scored[0].i, { noHistory: true });
            const bestPlan = plans[scored[0].i];
            if (bestPlan.unplaced.length && allowAutoStack) {
              stackAll();
              autopackUltra(seed + 1, false);
            }
          }

          function applyVariant(idx, opts = {}) {
            if (!state.variants.plans.length) return;
            if (!opts.noHistory) pushHistory();
            state.variants.index = Math.max(
              0,
              Math.min(state.variants.plans.length - 1, idx)
            );
            state.items = deepClone(state.variants.plans[state.variants.index]);
            renderAll();
          }

          function updateVariantLabel() {
            varLabel.textContent = `${t("variants")} ${
              state.variants.plans.length ? state.variants.index + 1 : 0
            }/${state.variants.plans.length || 0}`;
          }

          function bestFreeRect(free, l, w) {
            let best = null;
            for (const r of free) {
              if (l <= r.w && w <= r.h) {
                const areaWaste = r.w * r.h - l * w;
                const shortSide = Math.min(r.w - l, r.h - w);
                const score = areaWaste * 1e6 + shortSide;
                if (!best || score < best.score) {
                  best = { rect: r, score };
                }
              }
            }
            return best ? best.rect : null;
          }

          function guillotineSplitAndNormalize(free, usedRect, box) {
            const out = [];
            for (const r of free) {
              if (r !== usedRect) {
                out.push(r);
                continue;
              }
              const r1 = { x: r.x + box.l, y: r.y, w: r.w - box.l, h: box.w };
              const r2 = { x: r.x, y: r.y + box.w, w: r.w, h: r.h - box.w };
              if (r1.w > 0 && r1.h > 0) out.push(r1);
              if (r2.w > 0 && r2.h > 0) out.push(r2);
            }
            return normalizeFree(out);
          }

          function normalizeFree(list) {
            list = list.filter(
              (a, i) =>
                !list.some(
                  (b, j) =>
                    j !== i &&
                    a.x >= b.x &&
                    a.y >= b.y &&
                    a.x + a.w <= b.x + b.w &&
                    a.y + a.h <= b.y + b.h
                )
            );
            list = list.map((r) => ({
              x: snap(r.x),
              y: snap(r.y),
              w: snap(r.w),
              h: snap(r.h),
            }));
            return list;
          }

          function shelfPack(unplaced, v, placed, free) {
            let y = 0,
              shelfH = 0,
              x = 0;
            unplaced.sort((a, b) => Math.max(b.W, b.L) - Math.max(a.W, a.L));
            const rest = [];
            for (const it of unplaced) {
              const { l, w } = dims2D(it);
              if (w > v.inner_cm.W || l > v.inner_cm.L) {
                rest.push(it);
                continue;
              }
              if (x + l <= v.inner_cm.L) {
                it.x = x;
                it.y = y;
                x += l;
                shelfH = Math.max(shelfH, w);
                placed.push(it);
              } else if (y + shelfH + w <= v.inner_cm.W) {
                y += shelfH;
                x = 0;
                shelfH = 0;
                it.x = 0;
                it.y = y;
                x = l;
                shelfH = Math.max(shelfH, w);
                placed.push(it);
              } else {
                rest.push(it);
              }
            }
            free = [
              { x: x, y: y, w: v.inner_cm.L - x, h: shelfH },
              {
                x: 0,
                y: y + shelfH,
                w: v.inner_cm.L,
                h: v.inner_cm.W - (y + shelfH),
              },
            ].filter((r) => r.w > 0 && r.h > 0);
            return { placed, unplaced: rest, free };
          }

          function placeNewItem(it) {
            const v = vehicle();
            const free = computeFreeRectsFromPlaced(v, state.items);
            for (const rot of [0, 1]) {
              const { l, w } = dims2D({ ...it, rot });
              const spot = bestFreeRect(free, l, w);
              if (spot) {
                it.rot = rot;
                it.x = snap(spot.x);
                it.y = snap(spot.y);
                return true;
              }
            }
            it.x = 0;
            it.y = 0;
            it.rot = 0;
            return false;
          }

          function computeFreeRectsFromPlaced(v, items) {
            let free = [{ x: 0, y: 0, w: v.inner_cm.L, h: v.inner_cm.W }];
            const placed = items.map((it) => ({
              x: it.x,
              y: it.y,
              w: dims2D(it).l,
              h: dims2D(it).w,
            }));
            for (const p of placed) {
              const next = [];
              for (const r of free) {
                if (
                  !(
                    p.x >= r.x + r.w ||
                    p.x + p.w <= r.x ||
                    p.y >= r.y + r.h ||
                    p.y + p.h <= r.y
                  )
                ) {
                  const left = { x: r.x, y: r.y, w: p.x - r.x, h: r.h };
                  const right = {
                    x: p.x + p.w,
                    y: r.y,
                    w: r.x + r.w - (p.x + p.w),
                    h: r.h,
                  };
                  const top = { x: r.x, y: r.y, w: r.w, h: p.y - r.y };
                  const bottom = {
                    x: r.x,
                    y: p.y + p.h,
                    w: r.w,
                    h: r.y + r.h - (p.y + p.h),
                  };
                  [left, right, top, bottom].forEach((q) => {
                    if (q.w > 0 && q.h > 0) next.push(q);
                  });
                } else next.push(r);
              }
              free = normalizeFree(next);
            }
            return free;
          }

          // ===================== DRAG / KEYBOARD + DOCKING =====================
          let drag = null; // {id, offXcm, offYcm, pre:{x,y}}
          const DOCK = 5; // cm

          function bindItemEvents() {
            board.querySelectorAll("[data-rot]").forEach((c) => {
              c.addEventListener("pointerdown", (e) => {
                e.stopPropagation();
                const id = c.getAttribute("data-rot");
                state.selectedId = id;
                rotateSelected(+1);
              });
            });

            board.querySelectorAll("rect.item").forEach((r) => {
              r.addEventListener("pointerdown", (e) => {
                const id = r.getAttribute("data-id");
                state.selectedId = id;
                renderItems();
                try { dispatchSelectionChange(); } catch (_) {}
                const it = state.items.find((x) => x.id === id);
                const p = toSvgPoint(e);
                drag = {
                  id,
                  offXcm: p.x - it.x,
                  offYcm: p.y - it.y,
                  pre: { x: it.x, y: it.y },
                };
                r.setPointerCapture(e.pointerId);
                mount.classList.add("dragging");
              });
              r.addEventListener("keydown", (e) => {
                const step = vehicle().grid_cm;
                const it = state.items.find(
                  (x) => x.id === r.getAttribute("data-id")
                );
                if (!it) return;
                if (
                  [
                    "ArrowUp",
                    "ArrowDown",
                    "ArrowLeft",
                    "ArrowRight",
                    "Delete",
                    "Backspace",
                    "r",
                    "R",
                    "+",
                    "-",
                  ].includes(e.key)
                ) {
                  e.preventDefault();
                }
                if (e.key === "ArrowLeft") {
                  pushHistory();
                  it.x = Math.max(0, it.x - step);
                }
                if (e.key === "ArrowRight") {
                  pushHistory();
                  const { l } = dims2D(it);
                  it.x = Math.min(vehicle().inner_cm.L - l, it.x + step);
                }
                if (e.key === "ArrowUp") {
                  pushHistory();
                  it.y = Math.max(0, it.y - step);
                }
                if (e.key === "ArrowDown") {
                  pushHistory();
                  const { w } = dims2D(it);
                  it.y = Math.min(vehicle().inner_cm.W - w, it.y + step);
                }
                if (e.key === "Delete" || e.key === "Backspace") {
                  deleteSelected();
                }
                if (e.key === "r" || e.key === "R") {
                  rotateSelected(+1);
                }
                if (e.key === "+") {
                  changeStack(+1);
                }
                if (e.key === "-") {
                  changeStack(-1);
                }
                renderAll();
              });
            });
          }

          // Click on section rectangles to select item
          section?.addEventListener("pointerdown", (e) => {
            const t = e.target;
            if (t && t.getAttribute && t.hasAttribute("data-id")) {
              state.selectedId = t.getAttribute("data-id");
              renderAll();
              dispatchSelectionChange();
            }
          });

          board.addEventListener("pointermove", (e) => {
            if (!drag) return;
            const id = state.selectedId;
            const it = state.items.find((x) => x.id === id);
            if (!it) return;
            const v = vehicle();
            const p = toSvgPoint(e);
            let nx = snap(p.x - drag.offXcm);
            let ny = snap(p.y - drag.offYcm);
            const { l, w } = dims2D(it);
            nx = Math.max(0, Math.min(v.inner_cm.L - l, nx));
            ny = Math.max(0, Math.min(v.inner_cm.W - w, ny));
            if (Math.abs(nx - 0) <= DOCK) nx = 0;
            if (Math.abs(nx + l - v.inner_cm.L) <= DOCK) nx = v.inner_cm.L - l;
            if (Math.abs(ny - 0) <= DOCK) ny = 0;
            if (Math.abs(ny + w - v.inner_cm.W) <= DOCK) ny = v.inner_cm.W - w;
            for (const other of state.items) {
              if (other.id === id) continue;
              const d = dims2D(other);
              if (
                Math.abs(nx - (other.x + d.l)) <= DOCK &&
                !(ny + w <= other.y || ny >= other.y + d.w)
              )
                nx = other.x + d.l;
              if (
                Math.abs(nx + l - other.x) <= DOCK &&
                !(ny + w <= other.y || ny >= other.y + d.w)
              )
                nx = other.x - l;
              if (
                Math.abs(ny - (other.y + d.w)) <= DOCK &&
                !(nx + l <= other.x || nx >= other.x + d.l)
              )
                ny = other.y + d.w;
              if (
                Math.abs(ny + w - other.y) <= DOCK &&
                !(nx + l <= other.x || nx >= other.x + d.l)
              )
                ny = other.y - w;
            }
            it.x = nx;
            it.y = ny;
            board
              .querySelectorAll("rect.item")
              .forEach((n) => n.classList.remove("collide"));
            if (anyCollision(it, id))
              board
                .querySelector(`rect.item[data-id="${id}"]`)
                ?.classList.add("collide");
            renderItems();
            // live CoG/axle overlay + info update while dragging
            renderAxleOverlay();
            const axLive = computeAxleLoads(state.items, vehicle());
            const infoEl = mount.querySelector('#axleInfo');
            if (infoEl && axLive && axLive.totalKg) {
              const pctF = axLive.front_pct ? ` (${axLive.front_pct}%${axLive.front_pct>100?'!':''})` : '';
              const pctR = axLive.rear_pct ? ` (${axLive.rear_pct}%${axLive.rear_pct>100?'!':''})` : '';
              infoEl.textContent = `Całkowita: ${axLive.totalKg} kg • Przód: ${axLive.front_kg} kg${pctF} • Tył: ${axLive.rear_kg} kg${pctR}`;
            }
          });

          board.addEventListener("pointerup", (e) => {
            if (!drag) return;
            const id = drag.id;
            const it = state.items.find((x) => x.id === id);
            const invalid = !within(it, vehicle()) || anyCollision(it, id);
            if (invalid) {
              it.x = drag.pre.x;
              it.y = drag.pre.y;
            }
            pushHistory();
            drag = null;
            mount.classList.remove("dragging");
            renderAll();
            try { if (document.documentElement.classList.contains('print')) { overlayLabels.updateAll(); } } catch(_){}
          });

          // ===================== BULK PARSER — ULTRA v8 (dims+qty+kg, table+inline mix, RU/UA) =====================
          // Wspiera: pal/plt/pallet/palette/euro/epal/eur/ep oraz skrót **p** (kontekstowo).
          // Tryb tabelowy + wiersze inline: "1 400x150x150 862kg" oraz "1p 120x21x33" w tym samym polu.
          // Usuwa nadmiarowe spacje/entery wizualnie (nie psuje treści).

          // ——— USTAWIENIA ———
          const H_POLICY_DEFAULT = "hybrid"; // 'strict'|'zero'|'default'|'by_type'|'infer_layers'|'hybrid'
          const H_DEFAULT_CM = 160;
          const PALLET_ADD_HEIGHT_CM = 14.4;
          const MIN_DIM_MM = 30,
            MAX_DIM_MM = 5000;
          const CONF_LOW = 0.7;

          // ——— POMOCE ———
          function normDec(s) {
            return parseFloat(String(s).replace(/\s+/g, "").replace(",", "."));
          }
          function toCm(v, u) {
            if (!u) return v;
            const x = u.toLowerCase();
            if (x === "cm") return v;
            if (x === "mm") return v / 10;
            if (x === "m") return v * 100;
            if (x === "in" || x === '"' || x === "″") return v * 2.54;
            if (
              x === "ft" ||
              x === "'" ||
              x === "′" ||
              x === "фт" ||
              x === "фут"
            )
              return v * 30.48;
            return v;
          }
          function clampMm(vmm) {
            return vmm < MIN_DIM_MM || vmm > MAX_DIM_MM ? null : vmm;
          }
          function mmFromCm(cm) {
            return Math.round(cm * 10);
          }
          function within(v, min, max) {
            return v >= min && v <= max;
          }
          function isEURDims(L, W) {
            const a = [L, W].sort((x, y) => y - x);
            return within(a[0], 119, 121) && within(a[1], 79, 81);
          }

          // ——— PRE‑NORMALIZACJA ———
          function preNormalize(text) {
            let s = String(text || "");
            s = s
              .replace(/[хХ]/g, "x")
              .replace(/\bмм\b/gi, "mm")
              .replace(/\bсм\b/gi, "cm")
              .replace(/\bм\b/gi, "m");
            s = s.replace(/(\d)\s*(?:na|на|by|per|auf)\s*(\d)/gi, "$1x$2"); // 50na30
            s = s.replace(/(\d)(mm|cm|m|in|("|″)|ft|('|′))/gi, "$1 $2"); // 80cm → 80 cm
            s = s.replace(/(\d)(?=[A-Za-z\u00C0-\u024F\u0400-\u04FF])/g, "$1 "); // 4ep→4 ep, 10p→10 p
            s = s.replace(/(\d)\s+(?=\d{3}\b)/g, "$1"); // 12 000 → 12000
            return s;
          }
          function tidyWhitespaceVisual(v) {
            return String(v)
              .replace(/[ \t]{2,}/g, " ")
              .replace(/(\r?\n){2,}/g, "\n");
          }
          function sanitizeForLogistics(text) {
            return preNormalize(text)
              .replace(
                /\b\d[\d\s.,]*\s*(?:zł|pln|eur|€|\$|usd|uah|₴|rub|₽)\b/gi,
                " "
              )
              .replace(/\b\d{1,2}[./-]\d{1,2}(?:[./-]\d{2,4})?\b/g, " ")
              .replace(/\b\d{4}[./-]\d{1,2}[./-]\d{1,2}\b/g, " ")
              .replace(/\b\d{1,2}:\d{2}\b/g, " ")
              .replace(/\b(?:\+?\d[\d\-.\s()]{6,})\b/g, " ")
              .replace(/(?:#|nr\.?\s*)\d[\d/.-]*/gi, " ");
          }

          // ——— SŁOWNIKI ———
          const UNIT_ANY = "(?:mm|cm|m|in|\"|″|ft|'|′)";
          const XSEP = "(?:x|×|\\*|·|/)";
          const NUM = "\\d+(?:[.,]\\d+)?";
          const HEIGHT_KEYS =
            "(?:h|ht|hgt|wys\\.?|выс\\.?|вис\\.?|высота|висота|вис)";

          const TYPE_TOKEN = {
            pallet:
              /\b(?:pal(?:et|ety|eta)?|plt|pallet|palette|euro|epal|eur|ep|поддон|палет|палета|паллета|піддон|європалета|європіддон|европоддон)\b/i,
            box: /\b(?:box|karton|ctn|case|colli|короб|коробка|ящик|ящ\.)\b/i,
            roll: /\b(?:roll|rolka|rolki|рулон)\b/i,
            bag: /\b(?:bag|worek|мешок|мішок)\b/i,
            drum: /\b(?:drum|beczka|barrel|бочка)\b/i,
            ibc: /\b(?:ibc|paletopojemnik|еврокуб|єврокуб)\b/i,
          };
          // „p” rozpoznajemy kontekstowo (blisko liczby i wymiarów) w typeNear().

          // ——— BAZY PALET ———
          function palletBaseFromSeg(seg) {
            const s = seg.toLowerCase();
            const half =
              /(pół|pol|half|полу|пів|1\/2|eur6|d[üu]sseldorf|dus)\b/i.test(s);
            const quart = /(ćwier|quarter|четверть|1\/4|чверть)\b/i.test(s);
            if (half) return { code: "EUR6", Lcm: 80, Wcm: 60 };
            if (quart) return { code: "QEUR", Lcm: 60, Wcm: 40 };
            if (/\b(eur2|przem|industrial|uk|fin)\b/i.test(s))
              return { code: "EUR2", Lcm: 120, Wcm: 100 };
            if (/\b(eur|epal|euro|ep)\b/i.test(s))
              return { code: "EUR1", Lcm: 120, Wcm: 80 };
            if (/\b(chep)\b/i.test(s) && /\buk\b/i.test(s))
              return { code: "CHEP-1200x1000", Lcm: 120, Wcm: 100 };
            if (/\b(chep)\b/i.test(s))
              return { code: "CHEP-1200x800", Lcm: 120, Wcm: 80 };
            if (/\b(48\s*x\s*40|40\s*x\s*48|gma|usa|сша)\b/i.test(s))
              return { code: "US-48x40", Lcm: 121.9, Wcm: 101.6 };
            if (/\b(iso|1100\s*x\s*1100|asia|азиат)\b/i.test(s))
              return { code: "ISO-1100x1100", Lcm: 110, Wcm: 110 };
            return { code: "", Lcm: null, Wcm: null };
          }
          function palletDimsByCode(code) {
            switch ((code || "").toUpperCase()) {
              case "EUR1":
                return { Lcm: 120, Wcm: 80 };
              case "EUR2":
                return { Lcm: 120, Wcm: 100 };
              case "EUR3":
                return { Lcm: 120, Wcm: 100 };
              case "EUR6":
                return { Lcm: 80, Wcm: 60 };
              case "QEUR":
                return { Lcm: 60, Wcm: 40 };
              case "CHEP-1200X800":
                return { Lcm: 120, Wcm: 80 };
              case "CHEP-1200X1000":
                return { Lcm: 120, Wcm: 100 };
              case "US-48X40":
                return { Lcm: 121.9, Wcm: 101.6 };
              case "ISO-1100X1100":
                return { Lcm: 110, Wcm: 110 };
              case "FIN":
                return { Lcm: 120, Wcm: 100 };
              default:
                return { Lcm: null, Wcm: null };
            }
          }
          function defaultHByType(code) {
            if (code === "EUR6") return 90;
            if (code === "QEUR") return 60;
            return 160;
          }

          // ——— WYMIARY (globalne z indeksami) ———
          const TRIPLE_ANY_G = new RegExp(
            String.raw`(?<a>${NUM})\s*(?<ua>${UNIT_ANY})?\s*${XSEP}\s*(?<b>${NUM})\s*(?<ub>${UNIT_ANY})?\s*${XSEP}\s*(?<c>${NUM})\s*(?<uc>${UNIT_ANY})?`,
            "ig"
          );
          const SPACE_TRIPLE_G = new RegExp(
            String.raw`(?<a>${NUM})\s+(?<b>${NUM})\s+(?<c>${NUM})(?:\s*(?<u>${UNIT_ANY}))?`,
            "ig"
          );
          const LABELED_G = new RegExp(
            String.raw`(?:l|len|dł|dl|д|довжина)\s*[:=]?\s*(?<a>${NUM})\s*(?<ua>${UNIT_ANY})?.{0,12}(?:w|szer|b|breite|ш|ширина)\s*[:=]?\s*(?<b>${NUM})\s*(?<ub>${UNIT_ANY})?.{0,12}(?:h|wys|höhe|в|высота|висота)\s*[:=]?\s*(?<c>${NUM})\s*(?<uc>${UNIT_ANY})?`,
            "ig"
          );
          const DOUBLE_ANY_G = new RegExp(
            String.raw`(?<a>${NUM})\s*(?<ua>${UNIT_ANY})?\s*${XSEP}\s*(?<b>${NUM})\s*(?<ub>${UNIT_ANY})?`,
            "ig"
          );
          const DIAM_G = new RegExp(
            String.raw`(?:ø|⌀|phi|diam(?:eter)?|диаметр|діаметр)\s*(?<d>${NUM})\s*(?<ud>${UNIT_ANY})?\s*(?:${XSEP}|x)\s*(?<l>${NUM})\s*(?<ul>${UNIT_ANY})?`,
            "ig"
          );
          const HEIGHT_ONLY = new RegExp(
            String.raw`(?:^|[^\w])(?:${HEIGHT_KEYS})\s*[:=]?\s*(?<h>${NUM})\s*(?<uh>${UNIT_ANY})?(?:\b|$)`,
            "i"
          );

          // ——— ILOŚĆ ———
          function qtyNear(seg, idxStart) {
            const L = Math.max(0, idxStart - 60);
            const ctx = seg.slice(L, idxStart + 1);
            let m = ctx.match(
              /\b(\d+)\s*(?:warstw|warstwy|сло[йя]|уровн\w+|шар(?:и)?|рівн\w+)\b.*?\bpo\s*(\d+)\b/i
            );
            if (m) return parseInt(m[1], 10) * parseInt(m[2], 10);
            m = ctx.match(
              /\b(\d+)\s*x\s*(?:pal(?:et|ety|eta)?|plt|pallet|palette|euro|epal|eur|ep|p|szt|pcs|шт|ctn|box)\b/i
            );
            if (m) return parseInt(m[1], 10);
            m = ctx.match(
              /\b(\d+)\s*(?:pal(?:et|ety|eta)?|plt|pallet|palette|euro|epal|eur|ep|p|szt|pcs|шт|ctn|box)\b/i
            );
            if (m) return parseInt(m[1], 10);
            return 1;
          }

          // ——— TYP (z 'p' kontekstowo) ———
          function typeNear(seg, idxStart) {
            const L = Math.max(0, idxStart - 60);
            const ctx = seg.slice(L, idxStart + 1);
            let unit_type = null;
            for (const [kind, rx] of Object.entries(TYPE_TOKEN)) {
              if (rx.test(ctx)) {
                unit_type = kind;
                break;
              }
            }
            if (!unit_type && /\b\d+\s*p\b/i.test(ctx)) unit_type = "pallet";
            let code = "";
            if (unit_type === "pallet") code = palletBaseFromSeg(ctx).code;
            return { unit_type, code };
          }

          // ——— WYSOKOŚĆ ———
          function parseHeightAround(seg, idxStart) {
            const R = Math.min(seg.length, idxStart + 60);
            const right = seg.slice(idxStart, R);
            let m = right.match(HEIGHT_ONLY);
            if (!m) {
              const L = Math.max(0, idxStart - 60);
              const left = seg.slice(L, idxStart);
              m = left.match(HEIGHT_ONLY);
            }
            if (!m) return null;
            const h = toCm(normDec(m.groups.h), m.groups.uh || null);
            return clampMm(mmFromCm(h)) == null ? null : h;
          }

          // ——— WAGA ———
          function weightNear(seg, idxStart, qty) {
            const L = Math.max(0, idxStart - 60);
            const R = Math.min(seg.length, idxStart + 80);
            const ctx = seg.slice(L, R);
            let m = ctx.match(
              new RegExp(
                String.raw`(?:po|per|na)\s*(${NUM})\s*(?:kg|кг)\b`,
                "i"
              )
            );
            if (m) return { unit_w: normDec(m[1]), total_w: null };
            m = ctx.match(new RegExp(String.raw`(${NUM})\s*(?:kg|кг)\b`, "i"));
            if (m) {
              const v = normDec(m[1]);
              return qty <= 1
                ? { unit_w: v, total_w: null }
                : { unit_w: null, total_w: v };
            }
            m = ctx.match(new RegExp(String.raw`(?:kg|кг)\s*(${NUM})\b`, "i"));
            if (m) {
              const v = normDec(m[1]);
              return qty <= 1
                ? { unit_w: v, total_w: null }
                : { unit_w: null, total_w: v };
            }
            m = ctx.match(
              new RegExp(
                String.raw`(${NUM})\s*(?:kg|кг)\s*/\s*(?:pal(?:et|ety|eta)?|plt|pallet|pcs?|szt|шт|p)\b`,
                "i"
              )
            );
            if (m) return { unit_w: normDec(m[1]), total_w: null };
            m = ctx.match(
              new RegExp(
                String.raw`(?:total|gross|brutto|netto)\s*(${NUM})\s*(?:kg|кг|t)\b`,
                "i"
              )
            );
            if (m) {
              let v = normDec(m[1]);
              if (/t\b/i.test(m[0])) v *= 1000;
              return { unit_w: null, total_w: v };
            }
            return { unit_w: null, total_w: null };
          }

          // ——— WYMIARY: znajdź wszystkie wystąpienia ———
          function findAllDims(seg) {
            const found = [];
            function pushTriple(m, idx) {
              let a = normDec(m.groups.a),
                b = normDec(m.groups.b),
                c = normDec(m.groups.c);
              const ua = m.groups.ua,
                ub = m.groups.ub,
                uc = m.groups.uc;
              let L = toCm(a, ua || uc || null),
                W = toCm(b, ub || uc || null),
                H = toCm(c, uc || null);
              if (!ua && !ub && !uc && [L, W, H].every((v) => v >= 300))
                [L, W, H] = [L / 10, W / 10, H / 10];
              if ([L, W, H].every((v) => clampMm(mmFromCm(v)) != null))
                found.push({
                  start: idx,
                  end: idx + m[0].length,
                  L: Math.max(L, W),
                  W: Math.min(L, W),
                  H,
                  conf: 0.9,
                });
            }
            function pushSpaceTriple(m, idx) {
              let a = normDec(m.groups.a),
                b = normDec(m.groups.b),
                c = normDec(m.groups.c);
              const u = m.groups.u || null;
              if (u) {
                a = toCm(a, u);
                b = toCm(b, u);
                c = toCm(c, u);
              } else if ([a, b, c].every((v) => v >= 300)) {
                a /= 10;
                b /= 10;
                c /= 10;
              }
              if ([a, b, c].every((v) => clampMm(mmFromCm(v)) != null))
                found.push({
                  start: idx,
                  end: idx + m[0].length,
                  L: Math.max(a, b),
                  W: Math.min(a, b),
                  H: c,
                  conf: 0.8,
                });
            }
            function pushDouble(m, idx) {
              let a = normDec(m.groups.a),
                b = normDec(m.groups.b);
              const ua = m.groups.ua,
                ub = m.groups.ub;
              let L = toCm(a, ua || ub || null),
                W = toCm(b, ub || ua || null);
              if ([L, W].every((v) => clampMm(mmFromCm(v)) != null))
                found.push({
                  start: idx,
                  end: idx + m[0].length,
                  L: Math.max(L, W),
                  W: Math.min(L, W),
                  H: null,
                  conf: 0.65,
                });
            }
            function pushLabeled(m, idx) {
              const a = toCm(normDec(m.groups.a), m.groups.ua),
                b = toCm(normDec(m.groups.b), m.groups.ub),
                c = toCm(normDec(m.groups.c), m.groups.uc);
              if ([a, b, c].every((v) => clampMm(mmFromCm(v)) != null))
                found.push({
                  start: idx,
                  end: idx + m[0].length,
                  L: Math.max(a, b),
                  W: Math.min(a, b),
                  H: c,
                  conf: 0.95,
                });
            }
            function pushDiam(m, idx) {
              const d = toCm(normDec(m.groups.d), m.groups.ud),
                l = toCm(normDec(m.groups.l), m.groups.ul);
              if ([d, l].every((v) => clampMm(mmFromCm(v)) != null))
                found.push({
                  start: idx,
                  end: idx + m[0].length,
                  L: Math.max(d, l),
                  W: Math.min(d, l),
                  H: null,
                  dia: d,
                  conf: 0.8,
                });
            }
            for (const m of seg.matchAll(TRIPLE_ANY_G)) pushTriple(m, m.index);
            for (const m of seg.matchAll(LABELED_G)) pushLabeled(m, m.index);
            for (const m of seg.matchAll(DIAM_G)) pushDiam(m, m.index);
            for (const m of seg.matchAll(SPACE_TRIPLE_G))
              pushSpaceTriple(m, m.index);
            for (const m of seg.matchAll(DOUBLE_ANY_G)) pushDouble(m, m.index);

            found.sort((a, b) => a.start - b.start || b.conf - a.conf);
            const dedup = [];
            for (const f of found) {
              if (dedup.some((d) => !(f.end <= d.start || f.start >= d.end)))
                continue;
              dedup.push(f);
            }
            return dedup;
          }

          // ——— TRYB TABELA (również inline) ———
          const TABLE_HDR_RX =
            /\b(pallets?|palety|поддоны|піддони)\b|\b(length|width|height|weight|waga|длина|ширина|высота|довжина|висота|höhe|breite|länge)\b/i;
          function guessTableUnit(raw) {
            if (/\bmm\)/i.test(raw) || /\bmm\b/i.test(raw)) return "mm";
            if (/\bcm\)/i.test(raw) || /\bcm\b/i.test(raw)) return "cm";
            if (
              /\bm\)/i.test(raw) &&
              !/\bmm\b/i.test(raw) &&
              !/\bcm\b/i.test(raw)
            )
              return "m";
            return "cm";
          }
          function headerSuggestsUnitWeight(raw) {
            return /\b(per\s*(?:pallet|piece|pcs?)|kg\/(?:pal|plt|pcs?|szt)|waga\s*szt|weight\s*per)\b/i.test(
              raw
            );
          }
          function extractTableSegments(raw) {
            if (!TABLE_HDR_RX.test(raw)) return [];
            const unit = guessTableUnit(raw);
            const unitIsPer = headerSuggestsUnitWeight(raw);
            const used = [];
            const segs = [];
            const NUMR = `${NUM}`;
            function isFree(i, len) {
              return !used.some((r) => !(i + len <= r[0] || i >= r[1]));
            }
            function mark(i, len) {
              used.push([i, i + len]);
            }

            // qty + L + W + H (+ kg) — pionowo lub spacjami
            const RE_Q_LWH = new RegExp(
              String.raw`\b(?<qty>\d{1,4})\s*[\r\n\t ]+\s*(?<L>${NUMR})\s*[\r\n\t ]+\s*(?<W>${NUMR})\s*[\r\n\t ]+\s*(?<H>${NUMR})(?:\s*[\r\n\t ]+(?<kg>(?:${NUMR})))?`,
              "g"
            );
            for (const m of raw.matchAll(RE_Q_LWH)) {
              const idx = m.index,
                len = m[0].length;
              if (!isFree(idx, len)) continue;
              let q = parseInt(m.groups.qty, 10);
              let L = toCm(normDec(m.groups.L), unit),
                W = toCm(normDec(m.groups.W), unit),
                H = toCm(normDec(m.groups.H), unit);
              if ([L, W, H].some((v) => clampMm(mmFromCm(v)) == null)) continue;
              const kg = m.groups.kg ? Math.round(normDec(m.groups.kg)) : null;
              const kgStr = kg != null ? ` kg ${kg}` : "";
              segs.push(
                `${q} p ${Math.round(L)}x${Math.round(W)}x${Math.round(
                  H
                )} ${unit}${kgStr}${unitIsPer ? " /p" : ""}`
              );
              mark(idx, len);
            }

            // L + W + H (+ kg) → domyślnie qty=1
            const RE_LWH = new RegExp(
              String.raw`\b(?<L>${NUMR})\s*[\r\n\t ]+\s*(?<W>${NUMR})\s*[\r\n\t ]+\s*(?<H>${NUMR})(?:\s*[\r\n\t ]+(?<kg>(?:${NUMR})))?`,
              "g"
            );
            for (const m of raw.matchAll(RE_LWH)) {
              const idx = m.index,
                len = m[0].length;
              if (!isFree(idx, len)) continue;
              let L = toCm(normDec(m.groups.L), unit),
                W = toCm(normDec(m.groups.W), unit),
                H = toCm(normDec(m.groups.H), unit);
              if ([L, W, H].some((v) => clampMm(mmFromCm(v)) == null)) continue;
              const kg = m.groups.kg ? Math.round(normDec(m.groups.kg)) : null;
              const kgStr = kg != null ? ` kg ${kg}` : "";
              segs.push(
                `1 p ${Math.round(L)}x${Math.round(W)}x${Math.round(
                  H
                )} ${unit}${kgStr}${unitIsPer ? " /p" : ""}`
              );
              mark(idx, len);
            }

            // **NOWE**: wiersz inline "1 400x150x150 862kg" lub "1 400x150x150 kg 862"
            const RE_INLINE = new RegExp(
              String.raw`\b(?<qty>\d{1,4})\s+(?<L>${NUMR})\s*(?:x|×|\*|\/)\s*(?<W>${NUMR})\s*(?:x|×|\*|\/)\s*(?<H>${NUMR})(?:\s*(?:kg|кг)\s*(?<kg1>${NUMR})|\s*(?<kg2>${NUMR})\s*(?:kg|кг))?`,
              "gi"
            );
            for (const m of raw.matchAll(RE_INLINE)) {
              const idx = m.index,
                len = m[0].length;
              if (!isFree(idx, len)) continue;
              const q = parseInt(m.groups.qty, 10);
              let L = toCm(normDec(m.groups.L), unit),
                W = toCm(normDec(m.groups.W), unit),
                H = toCm(normDec(m.groups.H), unit);
              if ([L, W, H].some((v) => clampMm(mmFromCm(v)) == null)) continue;
              const kg = m.groups.kg1
                ? Math.round(normDec(m.groups.kg1))
                : m.groups.kg2
                ? Math.round(normDec(m.groups.kg2))
                : null;
              const kgStr = kg != null ? ` kg ${kg}` : "";
              segs.push(
                `${q} p ${Math.round(L)}x${Math.round(W)}x${Math.round(
                  H
                )} ${unit}${kgStr}${unitIsPer ? " /p" : ""}`
              );
              mark(idx, len);
            }

            return segs;
          }

          // ——— FLAGI ———
          const STACK_POS =
            /\b(?:piętrow|pietrow|stack(?:able)?|stack all|stacking allowed|штабел|stackuj)\b/i;
          const STACK_NEG =
            /\b(?:nie\s*piętrow|nie\s*pietrow|non-?stack|no stack|не\s*штаб)\b/i;
          function detectStackFlags(seg) {
            return { pos: STACK_POS.test(seg), neg: STACK_NEG.test(seg) };
          }
          function hasNoPallet(seg) {
            return /\b(?:bez palety|bez\s*poddona|без\s*поддона|без\s*палеты|без\s*палети|без\s*піддона)\b/i.test(
              seg
            );
          }

          // ——— GŁÓWNA FUNKCJA ———
          function extractLogistics(raw) {
            const original = String(raw || "");
            const text = sanitizeForLogistics(original);
            const low = text.toLowerCase();

            // segmenty klasyczne + pseudo‑segmenty z tabel (także inline)
            const segA = low
              .split(/[\n;•]+|(?<!\d)[,.](?!\d)/g)
              .map((s) => s.trim())
              .filter(Boolean);
            const tableSegs = extractTableSegments(original);
            const segments = segA.concat(tableSegs);

            const items = [];
            const orderKeys = [];

            for (const seg of segments) {
              const dimsList = findAllDims(seg);
              if (!dimsList.length) continue;

              const stack = detectStackFlags(seg);
              const addPal = hasNoPallet(seg);

              for (const d of dimsList) {
                let { unit_type: ut, code } = typeNear(seg, d.start);
                // jeśli mamy nagłówki tabeli w całym tekście i brak typu → załóż paletę
                if (!ut && tableSegs.length) {
                  ut = "pallet";
                  code = code || palletBaseFromSeg(seg).code;
                }

                if (
                  !ut &&
                  !/(?:wymiary|rozmiar|dimension|größe|размер|розмір)/i.test(
                    seg
                  )
                )
                  continue;

                const qty = qtyNear(seg, d.start);
                let L = d.L,
                  W = d.W,
                  H = d.H;
                const diameter = d.dia || null;

                const w = weightNear(seg, d.start, qty);

                // paleta → baza
                let pallet_code = code;
                if (ut === "pallet" && (L == null || W == null)) {
                  const b = palletBaseFromSeg(seg);
                  pallet_code = b.code || code;
                  if (b.Lcm && b.Wcm) {
                    L = b.Lcm;
                    W = b.Wcm;
                  }
                }

                // H polityka
                if (H == null) {
                  if (ut === "pallet") {
                    if (H_POLICY_DEFAULT === "by_type")
                      H = defaultHByType(pallet_code);
                    else if (H_POLICY_DEFAULT === "default") H = H_DEFAULT_CM;
                    else if (H_POLICY_DEFAULT === "hybrid")
                      H = defaultHByType(pallet_code) ?? H_DEFAULT_CM;
                    else if (H_POLICY_DEFAULT === "zero") H = 0;
                    else {
                      const hLocal = parseHeightAround(seg, d.start);
                      if (hLocal != null) H = hLocal;
                    }
                  } else {
                    const hLocal = parseHeightAround(seg, d.start);
                    H =
                      hLocal != null
                        ? hLocal
                        : H_POLICY_DEFAULT === "zero"
                        ? 0
                        : null;
                  }
                }

                if (addPal && H != null) H += PALLET_ADD_HEIGHT_CM;

                const plausible =
                  (L == null || clampMm(mmFromCm(L)) != null) &&
                  (W == null || clampMm(mmFromCm(W)) != null) &&
                  (H == null || clampMm(mmFromCm(H)) != null);
                const conf = d.conf || 0.7;
                const needs_review = !plausible || conf < CONF_LOW ? 1 : 0;

                const item = {
                  idx: d.start,
                  type: ut || "other",
                  subtype:
                    ut === "pallet" ? pallet_code || "unknown" : "unknown",
                  qty,
                  length_cm: L != null ? Math.round(L) : null,
                  width_cm:
                    W != null
                      ? Math.round(W)
                      : diameter != null
                      ? Math.round(diameter)
                      : null,
                  height_cm: H != null ? Math.round(H) : null,
                  diameter_cm: diameter != null ? Math.round(diameter) : null,
                  unit_weight_kg:
                    w.unit_w != null ? Math.round(w.unit_w) : null,
                  total_weight_kg:
                    w.total_w != null ? Math.round(w.total_w) : null,
                  stackable: stack.neg ? false : stack.pos ? true : null,
                  notes: addPal ? "bez palety +14.4 cm" : "",
                  lang: /[а-яёіїєґ]/i.test(seg) ? "ru/uk" : "pl/en/de",
                  confidence: Math.max(0, Math.min(1, conf)),
                  needs_review,
                };

                items.push(item);
                orderKeys.push({
                  key: `${item.type}|${item.subtype}|${item.length_cm}|${
                    item.width_cm
                  }|${item.height_cm || 0}`,
                  idx: item.idx,
                });
              }
            }

            // AGREGACJA z zachowaniem kolejności
            const order = [];
            const seen = new Set();
            for (const g of orderKeys) {
              if (!seen.has(g.key)) {
                seen.add(g.key);
                order.push(g.key);
              }
            }
            const grouped = new Map();
            for (const it of items) {
              const k = `${it.type}|${it.subtype}|${it.length_cm}|${
                it.width_cm
              }|${it.height_cm || 0}`;
              if (grouped.has(k)) {
                const x = grouped.get(k);
                x.qty += it.qty;
                x.needs_review |= it.needs_review;
                x.confidence = Math.min(x.confidence, it.confidence);
                if (
                  x.unit_weight_kg != null &&
                  it.unit_weight_kg != null &&
                  x.unit_weight_kg !== it.unit_weight_kg
                )
                  x.needs_review = 1;
                if (it.total_weight_kg != null)
                  x.total_weight_kg =
                    (x.total_weight_kg || 0) + it.total_weight_kg;
              } else grouped.set(k, { ...it });
            }
            const aggregated = order
              .map((k) => {
                for (const [gk, val] of grouped.entries()) {
                  if (gk.endsWith(k.split("|").slice(2).join("|"))) return val;
                }
                return null;
              })
              .filter(Boolean);

            return { items: aggregated, warnings: [] };
          }

          // ——— PODGLĄD ———
          function prettyExtractPreview(res) {
            if (!res.items.length) return "— nic nie wykryto —";
            return res.items
              .map((it) => {
                const qty = it.qty || 1;
                const dims = it.diameter_cm
                  ? `${it.diameter_cm}Ø×${it.length_cm || 0}`
                  : `${it.length_cm || 0}x${it.width_cm || 0}x${
                      it.height_cm || 0
                    }`;
                const kind =
                  it.type === "pallet"
                    ? it.subtype === "EUR6"
                      ? "półpaleta"
                      : it.subtype === "QEUR"
                      ? "ćwierćpaleta"
                      : "paleta"
                    : it.type;
                const w =
                  it.unit_weight_kg != null
                    ? ` • ${it.unit_weight_kg} kg/szt`
                    : it.total_weight_kg != null
                    ? ` • ${it.total_weight_kg} kg (total)`
                    : "";
                const flag = it.needs_review ? " • △ sprawdź" : "";
                return `${qty} ${kind} ${dims}${w}${flag}`;
              })
              .join("\n");
          }


          function applyExtractedItems(items) {
            if (!items || !items.length) return false;
            pushHistory();
            for (const it of items) {
              const qty = Math.max(1, it.qty || 1);

              let L = it.length_cm,
                W = it.width_cm,
                H = it.height_cm;
              if ((L == null || W == null) && it.type === "pallet") {
                const base = palletDimsByCode(it.subtype || "");
                if (!L && base.Lcm != null) L = base.Lcm;
                if (!W && base.Wcm != null) W = base.Wcm;
              }
              if (H == null) {
                if (it.type === "pallet")
                  H =
                    defaultHByType((it.subtype || "").toString()) ??
                    H_DEFAULT_CM;
                else H = 0;
              }

              const perKg =
                it.unit_weight_kg != null
                  ? it.unit_weight_kg
                  : it.total_weight_kg != null && qty > 0
                  ? Math.round(it.total_weight_kg / qty)
                  : 0;

              let nodeType = "custom";
              if (
                it.type === "pallet" &&
                (/eur|epal|ep/i.test(it.subtype || "") || isEURDims(L, W))
              )
                nodeType = "eur_pallet";

              L = Math.round(L ?? 120);
              W = Math.round(W ?? (it.diameter_cm || 80));
              H = Math.round(H ?? (it.diameter_cm || 80));

              for (let i = 0; i < qty; i++) {
                const node = {
                  id: uid(),
                  type: nodeType,
                  L,
                  W,
                  H,
                  weight: Math.round(perKg || 0),
                  stackable: it.stackable == null ? true : !!it.stackable,
                  stackCount: 1,
                  x: 0,
                  y: 0,
                  rot: 0,
                  flags: (it.stackable === false) ? { noStack: true } : {}
                };
                placeNewItem(node);
                state.items.push(node);
              }
            }
            // Auto‑pack immediately after bulk add
            autopackUltra(0, true);
            return true;
          }

          // ——— SPINANIE Z UI ———
          bulkText.addEventListener("input", () => {
            const txt = bulkText.value || "";
            const res = extractLogistics(txt);
            if (res.items && res.items.length) {
              bulkOut.textContent = prettyExtractPreview(res);
            } else {
              // Fallback to MEGA‑PROMPT lightweight parser preview
              try {
                const fallbackItems = parseRawText(txt) || [];
                bulkOut.textContent = prettyExtractPreview({ items: fallbackItems });
              } catch {
                bulkOut.textContent = prettyExtractPreview({ items: [] });
              }
            }
          });
          bulkText.addEventListener("paste", () =>
            setTimeout(() => {
              bulkText.value = tidyWhitespaceVisual(bulkText.value);
            }, 0)
          );
          bulkText.addEventListener("blur", () => {
            bulkText.value = tidyWhitespaceVisual(bulkText.value);
          });

          bulkAdd.addEventListener("click", () => {
            const txt = bulkText.value || "";
            const res = extractLogistics(txt);
            let items = (res && res.items) ? res.items : [];
            if (!items.length) {
              // Fallback to MEGA‑PROMPT lightweight parser application
              try {
                const fallbackItems = parseRawText(txt) || [];
                if (fallbackItems.length) {
                  items = fallbackItems;
                }
              } catch {}
            }
            if (!items.length) {
              showError("Nie wykryto żadnych pozycji");
              return;
            }
            applyExtractedItems(items);
          });

          // View toggle 2D/3D
          view3DBtn?.addEventListener("click", () => {
            state.viewMode = state.viewMode === "3d" ? "2d" : "3d";
            view3DBtn.textContent = state.viewMode === "3d" ? "🗺️ Widok 2D" : "🎥 3D widok";
            renderAll();
            try { if (document.documentElement.classList.contains('print')) { overlayLabels.updateAll(); } } catch(_){}
          });
          window.addEventListener("resize", () => {
            if (state.viewMode === "3d") render3D();
            // Re-render items to recalc compact labels on zoom/resize
            renderItems();
            renderSection();
            try {
              if (document.documentElement.classList.contains('print')) {
                overlayLabels.updateAll();
              }
            } catch(_) {}
          });
          
          // ===================== MEGA‑PROMPT LIGHT PARSER (non-intrusive) =====================
          // Standalone, minimal parser helpers. Does not modify existing parser functions.
          function normalizeUnits(raw) {
            // Reuse existing preNormalize where possible, then apply small cleanups.
            let s = preNormalize(String(raw || ""));
            s = s
              .replace(/×/g, "x")
              .replace(/\*/g, "x")
              .replace(/·/g, "x")
              .replace(/\s{2,}/g, " ")
              .trim();
            return s;
          }

          function detectType(tok){
            const t = String(tok || "").toLowerCase();
            if (/(europal|epal|eur|euro|pallet|palet|palette|plt|поддон|палет|піддон)/.test(t)) return "pallet";
            if (/(box|carton|ctn|case|karton|krab|caja|scatola|doos)/.test(t)) return "box";
            if (/(roll|rolka|рулон|rulle|ruolon|tekercs)/.test(t)) return "roll";
            if (/(drum|barrel|beczka|бочка)/.test(t)) return "drum";
            if (/(bag|worek|мешок|sac|saco|bolsa)/.test(t)) return "bag";
            if (/\bibc\b|eurocube|еврокуб|єврокуб/.test(t)) return "ibc";
            return "other";
          }

          function mapPalletSubtype(label, L, W){
            const s = String(label || "").toLowerCase();
            // preferuj po nazwie; w razie braku – po rozmiarze
            if (/eur1|euro\s*120\s*[x×*]\s*80|chep.*1200.*800/.test(s) || (L===120 && W===80)) return "EUR1";
            if (/eur2|120\s*[x×*]\s*100|chep.*1200.*1000/.test(s) || (L===120 && W===100)) return "EUR2";
            if (/eur3|100\s*[x×*]\s*120/.test(s) || (L===120 && W===100)) return "EUR3";
            if (/eur6|80\s*[x×*]\s*60/.test(s) || (L===80  && W===60))  return "EUR6";
            if (/qeur|60\s*[x×*]\s*40/.test(s) || (L===60  && W===40))  return "QEUR";
            if (/us.*48\s*[x×*]\s*40|121\.9.*101\.6/.test(s))           return "US-48x40";
            if (/iso.*1100\s*[x×*]\s*1100|110\s*[x×*]\s*110/.test(s))   return "ISO-1100x1100";
            return "unknown";
          }

          function parseLWH(raw){
            // obsługa LxWxH oraz etykiet L/W/H; zwraca {L,W,H, byLabel}
            const s = normalizeUnits(raw);
            const byLabel = {};
            // etykiety
            const labRe = /\b(L(en|ength|änge)?|Dł|Dl|Длина)\s*[:=]?\s*(\d+(\.\d+)?)\s*(mm|cm|m|")?\b.*?\b(W(idth|eite)?|Szer|Ширина)\s*[:=]?\s*(\d+(\.\d+)?)\s*(mm|cm|m|")?\b.*?\b(H(eight|öhe)?|Wys|Высота)\s*[:=]?\s*(\d+(\.\d+)?)\s*(mm|cm|m|")?\b/i;
            const mLab = s.match(labRe);
            if (mLab){
              byLabel.L = {v:+mLab[3], u:(mLab[5]||"cm")};
              byLabel.W = {v:+mLab[9], u:(mLab[11]||"cm")};
              byLabel.H = {v:+mLab[15],u:(mLab[17]||"cm")};
            }
            // trójka/podwójka
            const m = s.match(/(\d+(?:[.,]\d+)?)\s*[x×*\/]\s*(\d+(?:[.,]\d+)?)\s*(?:[x×*\/]\s*(\d+(?:[.,]\d+)?))?\s*(mm|cm|m|")?/i);
            if (!m && !mLab) return null;

            const unit = (m?.[4] || byLabel.L?.u || "cm").toLowerCase();
            const toCm = v => {
              const n = parseFloat(String(v).replace(",","."));
              if (unit==="mm") return Math.round(n/10);
              if (unit==='m')  return Math.round(n*100);
              if (unit==='"')  return Math.round(n*2.54);
              return Math.round(n); // cm
            };
            let L = m ? toCm(m[1]) : toCm(byLabel.L.v);
            let W = m ? toCm(m[2]) : toCm(byLabel.W.v);
            let H = m ? (m[3]? toCm(m[3]) : 0) : toCm(byLabel.H.v);
            if (L < W) [L,W] = [W,L]; // normalizacja
            if (Math.min(L,W) < 3 || Math.max(L,W,H) > 500) return null;
            return { L,W,H, byLabel: !!mLab };
          }

          function parseDiameter(raw){
            const s = normalizeUnits(raw);
            const dm = s.match(/(ø|⌀|phi|diam(?:eter)?|Durchmesser|diámetro|diametro)\s*[:=]?\s*(\d+(?:[.,]\d+)?)\s*(mm|cm|m|")?/i);
            if (!dm) return null;
            const u = (dm[3]||"cm").toLowerCase();
            const toCm = v => u==="mm"?Math.round(v/10):u==="m"?Math.round(v*100):u==='"'?Math.round(v*2.54):Math.round(v);
            return toCm(parseFloat(String(dm[2]).replace(",", ".")));
          }

          function parseWeights(raw){
            const s = normalizeUnits(raw).toLowerCase();
            const unit = /(\d+(?:[.,]\d+)?)\s*(t|kg)\b/gi;
            let total=null, per=null, note="";
            // per szt/pal
            const perM = s.match(/(\d+(?:[.,]\d+)?)\s*(kg|t)\s*(?:\/|na|per|pro|je|\/\s*(?:szt|pcs|pal|plt))/i);
            if (perM) { const v=parseFloat(perM[1].replace(",", ".")); per = perM[2]==="t"? v*1000 : v; }
            // total
            let m=null; while ((m = unit.exec(s))) { const v=parseFloat(m[1].replace(",", ".")); const kg = m[2]==="t"? v*1000:v; total = (total||0)+kg; }
            if (/brutto|gross/.test(s)) note="brutto"; if (/netto/.test(s)) note=(note?note+";":"")+"netto";
            return { total_weight_kg: total||null, unit_weight_kg: per||null, note };
          }

          function aggregateItems(items){
            const key = it => [it.type,it.subtype,it.length_cm,it.width_cm,it.height_cm].join("|");
            const map = new Map();
            for (const it of items){
              const k = key(it);
              if (!map.has(k)) map.set(k,{...it});
              else{
                const acc = map.get(k);
                acc.qty += it.qty||1;
                if (acc.total_weight_kg!=null || it.total_weight_kg!=null) {
                  acc.total_weight_kg = (acc.total_weight_kg||0) + (it.total_weight_kg||0);
                }
                if (acc.unit_weight_kg!=null && it.unit_weight_kg!=null && acc.unit_weight_kg!==it.unit_weight_kg){
                  acc.needs_review = 1;
                }
                acc.confidence = Math.min(acc.confidence||0.95, it.confidence||0.95);
              }
            }
            return Array.from(map.values());
          }

          function parseRawText(text){
            // minimalny parser: skanuje liniami, wykrywa typ/ilość/wymiary/średnicę i wagę
            const lines = normalizeUnits(text).split(/\n|;/);
            const out = [];
            for (const ln of lines){
              const l = ln.trim(); if (!l) continue;
              const qtyM = l.match(/\b(\d{1,4})\s*(pcs|szt|шт|ks|db|ud|uds|ctn|box|pallet|pal|plt|ibc)?\b/i);
              const qty = qtyM ? Math.max(1, parseInt(qtyM[1],10)) : 1;
              const type = detectType(l);
              const dims = parseLWH(l);
              if (!dims && !/ø|⌀|phi|diam/i.test(l)) continue;

              let {L,W,H} = dims || {L:0,W:0,H:0};
              const diam = parseDiameter(l);
              if (diam) { W = diam; }

              let subtype = type==="pallet" ? mapPalletSubtype(l, L, W) : "unknown";
              if (type==="pallet" && H===0) H = 160; // domyślna H dla palet
              if (type!=="pallet" && H===0) { /* zostaw 0 i oznacz review */ }

              const { unit_weight_kg, total_weight_kg, note } = parseWeights(l);
              out.push({
                type, subtype, qty,
                length_cm:L, width_cm:W, height_cm:H, diameter_cm: diam||null,
                unit_weight_kg: unit_weight_kg||null, total_weight_kg: total_weight_kg||null,
                stackable: /stapelbar|stackable|stohovat|piętr/.test(l) ? true : /non-?stack|nicht stapel|nie ?piętr|не штаб/i.test(l) ? false : null,
                notes: note||"",
                lang: "auto",
                confidence: dims?.byLabel ? 0.9 : 0.75,
                needs_review: (H===0||!dims) ? 1 : 0
              });
            }
            return aggregateItems(out);
          }
          // ===================== /MEGA‑PROMPT LIGHT PARSER =====================

          // ===================== /BULK PARSER — ULTRA v8 =====================
          // One‑line custom add
          mount.querySelector("#cAddOne")?.addEventListener("click", addCustomLine);
          mount
            .querySelector('[data-act="undo"]')
            .addEventListener("click", undo);
          mount
            .querySelector('[data-act="redo"]')
            .addEventListener("click", redo);
          mount
            .querySelector('[data-act="autopack"]')
            .addEventListener("click", () => autopackUltra(0, true));
          mount
            .querySelector('[data-act="altpack"]')
            .addEventListener("click", () =>
              autopackUltra((Math.random() * 100) | 0, true)
            );
          mount
            .querySelector('[data-act="compare"]')
            .addEventListener("click", () => {
              state.compareOn = !state.compareOn;
              renderAll();
            });
          mount
            .querySelector('[data-act="stackAll"]')
            .addEventListener("click", stackAll);
          mount
            .querySelector('[data-act="prevVar"]')
            .addEventListener("click", () =>
              applyVariant(state.variants.index - 1)
            );
          mount
            .querySelector('[data-act="nextVar"]')
            .addEventListener("click", () =>
              applyVariant(state.variants.index + 1)
            );
          mount
            .querySelector('[data-act="reset"]')
            .addEventListener("click", () => {
              if (confirm("Wyczyścić wszystkie elementy?")) {
                pushHistory();
                state.items = [];
                state.selectedId = null;
                state.variants = { plans: [], index: 0 };
                renderAll();
              }
            });
          mount
            .querySelector('[data-act="save"]')
            .addEventListener("click", saveLocal);
          mount
            .querySelector('[data-act="share"]')
            .addEventListener("click", shareLink);
          mount
            .querySelector('[data-act="rotL"]')
            .addEventListener("click", () => rotateSelected(-1));
          mount
            .querySelector('[data-act="rotR"]')
            .addEventListener("click", () => rotateSelected(+1));
          mount
            .querySelectorAll('[data-act="delete"]')
            .forEach((b) => b.addEventListener("click", deleteSelected));

          // Brakujące akcje przycisków Piętrowanie +/− (obok wybranego elementu)
          mount
            .querySelector('[data-act="stack-+"]')
            ?.addEventListener("click", () => changeStack(+1));
          mount
            .querySelector('[data-act="stack--"]')
            ?.addEventListener("click", () => changeStack(-1));

          // Modal
          mount
            .querySelector('[data-act="quote"]')
            .addEventListener("click", () => {
              const v = vehicle();
              const out = summarize();
              const lines = listItems()
                .map(
                  (x) =>
                    `• ${x.qty}× ${x.name} ${x.dims} • ${x.weight_each} kg/szt`
                )
                .join("<br>");
              mount.querySelector("#summary").innerHTML = `Pojazd: <b>${
                v.name_pl
              }</b> • ${out.items} szt. • ${out.volume_m3.toFixed(
                2
              )} m³ • ${Math.round(out.weight_kg)} kg<br>${lines}`;
              modal.setAttribute("open", "");
            });
          modal.addEventListener("click", (e) => {
            if (e.target === modal) modal.removeAttribute("open");
          });
          modal
            .querySelector('[data-act="modal-cancel"]')
            .addEventListener("click", () => modal.removeAttribute("open"));
          modal
            .querySelector('[data-act="modal-send"]')
            .addEventListener("click", () => {
              const from = mount.querySelector("#mFrom").value.trim();
              const to = mount.querySelector("#mTo").value.trim();
              if (!from || !to) {
                alert("Uzupełnij wymagane pola");
                return;
              }
              const payload = buildPayload();
              const body = buildEmailBody(payload);
              const mailto = `mailto:krastranseu@gmail.com?subject=${encodeURIComponent(
                "wycena z aplikacji"
              )}&body=${encodeURIComponent(body)}`;
              window.location.href = mailto;
              modal.removeAttribute("open");
            });

          // ===================== SUMMARY / PAYLOAD =====================
          function summarize() {
            let volume_m3 = 0,
              weight_kg = 0;
            state.items.forEach((it) => {
              volume_m3 += volItem(it);
              weight_kg += weightItem(it);
            });
            return { items: state.items.length, volume_m3, weight_kg };
          }
          function listItems() {
            return state.items.map((it) => ({
              name: presetName(it.type) || "custom",
              qty: it.stackCount,
              dims: `${it.L}×${it.W}×${it.H} cm`,
              weight_each: it.weight || 0,
            }));
          }
          function presetName(id) {
            const p = PRESETS.find((x) => x.id === id);
            return p ? p.label : "Element";
          }
          function buildPayload() {
            const v = vehicle();
            const sum = summarize();
            return {
              vehicle_id: v.id,
              vehicle_name: v.name_pl,
              items: state.items.map((it) => ({
                type: presetName(it.type),
                qty: it.stackCount,
                dims_cm: { L: it.L, W: it.W, H: it.H },
                weight_each_kg: it.weight || 0,
              })),
              total_volume_m3: sum.volume_m3,
              total_weight_kg: sum.weight_kg,
              packed_ratio: Math.min(1, volBar.value / 100),
            };
          }
          function buildEmailBody(payload) {
            const from = mount.querySelector("#mFrom").value.trim();
            const to = mount.querySelector("#mTo").value.trim();
            const ldate = mount.querySelector("#ldate").value;
            const lfrom = mount.querySelector("#lfrom").value;
            const lto = mount.querySelector("#lto").value;
            const udate = mount.querySelector("#udate").value;
            const ufrom = mount.querySelector("#ufrom").value;
            const uto = mount.querySelector("#uto").value;
            const notes = mount.querySelector("#mNotes").value.trim();
            const lines = payload.items
              .map(
                (x) =>
                  `• ${x.qty}× ${x.type} ${x.dims_cm.L}×${x.dims_cm.W}×${x.dims_cm.H} cm • ${x.weight_each_kg} kg/szt`
              )
              .join("\n");
            return [
              `POJAZD: ${payload.vehicle_name} (${payload.vehicle_id})`,
              `TRASA: ${from} → ${to}`,
              `ZAŁADUNEK: ${ldate || ""} ${lfrom || ""}–${lto || ""}`,
              `ROZŁADUNEK: ${udate || ""} ${ufrom || ""}–${uto || ""}`,
              `ELEMENTY:\n${lines}`,
              `SUMA: ${payload.total_volume_m3.toFixed(2)} m³ • ${Math.round(
                payload.total_weight_kg
              )} kg • wypełnienie ${(payload.packed_ratio * 100).toFixed(0)}%`,
              notes ? `UWAGI: ${notes}` : "",
            ]
              .filter(Boolean)
              .join("\n");
          }

          // ===================== INIT =====================
          function seedPresets() {
            state.items.push({
              id: uid(),
              type: "eur_pallet",
              L: 120,
              W: 80,
              H: 180,
              weight: 350,
              stackable: true,
              stackCount: 1,
              x: 0,
              y: 0,
              rot: 0,
              flags: {}
            });
            state.items.push({
              id: uid(),
              type: "eur_pallet",
              L: 120,
              W: 80,
              H: 180,
              weight: 350,
              stackable: true,
              stackCount: 1,
              x: 120,
              y: 0,
              rot: 0,
              flags: {}
            });
          }
          function firstTimeInit() {
            if (!loadFromHash()) loadLocal();
            renderPresets();
            renderAll();
            if (!state.items.length) {
              seedPresets();
              renderAll();
            }
          }

          // Shortcuts (global)
          window.addEventListener("keydown", (e) => {
            if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "c") {
              e.preventDefault();
              copySelected();
            }
            if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === "v") {
              e.preventDefault();
              pasteClipboard();
            }
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
              e.preventDefault();
              undo();
            }
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y") {
              e.preventDefault();
              redo();
            }
            if (e.key === "R" || e.key === "r") rotateSelected(+1);
            try { if (document.documentElement.classList.contains('print')) { overlayLabels.updateAll(); } } catch(_){}
            if (e.key === "Delete") {
              deleteSelected();
            }
            if (e.key === "+" || e.key === "=") {
              changeStack(+1);
            }
            if (e.key === "-") {
              changeStack(-1);
            }
            if (
              e.key === "ArrowLeft" &&
              e.shiftKey &&
              (e.metaKey || e.ctrlKey)
            ) {
              applyVariant(state.variants.index - 1);
            }
2            if (
              e.key === "ArrowRight" &&
              e.shiftKey &&
              (e.metaKey || e.ctrlKey)
            ) {
              applyVariant(state.variants.index + 1);
            }
          });

          firstTimeInit();
        } catch (err) {
          const root = document.getElementById("van-pack");
          const box = document.createElement("div");
          box.style.cssText =
            "background:#2b1111;color:#ffd7d7;border:1px solid #7a2b2b;border-radius:10px;padding:10px;margin:10px 0";
          box.textContent =
            "Błąd inicjalizacji: " + (err && err.message ? err.message : err);
          root.appendChild(box);
          console.error(err);
        }
      })();
    </script>

    <!-- VanPackLogoLite: logo i automatyczny montaż przy nazwie VanFit -->
    <script>
    /* VanPackLogoLite — zero zależności, ~1.5KB */
    window.VanPackLogoLite = (()=>{

      const SVG = (`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" aria-hidden="true">
        <defs>
          <style>
            :root{ --vp-a:#FFD48A; --vp-b:#FF6A00; --vp-stroke:#FFF6EB; --vp-v:#FFFFFF; }
            @media (prefers-color-scheme: dark){ :root{ --vp-a:#FFC777; --vp-b:#FF7E25; } }
            .s{fill:none;stroke:var(--vp-stroke);stroke-width:2;stroke-linejoin:round;stroke-linecap:round}
          </style>
          <linearGradient id="bg" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" style="stop-color:var(--vp-a)"/>
            <stop offset="1" style="stop-color:var(--vp-b)"/>
            <animateTransform attributeName="gradientTransform" type="rotate"
                              from="0 0.5 0.5" to="360 0.5 0.5" dur="24s" repeatCount="indefinite"/>
          </linearGradient>
          <linearGradient id="shine" gradientUnits="userSpaceOnUse" x1="-64" y1="0" x2="0" y2="0">
            <stop offset="0"  stop-color="#ffffff00"/>
            <stop offset=".5" stop-color="#ffffffcc"/>
            <stop offset="1"  stop-color="#ffffff00"/>
            <animate attributeName="x1" values="-64;128" dur="5.5s" repeatCount="indefinite"/>
            <animate attributeName="x2" values="0;192"   dur="5.5s" repeatCount="indefinite"/>
          </linearGradient>
        </defs>
        <rect x="2" y="2" width="60" height="60" rx="14" fill="url(#bg)"/>
        <g transform="translate(0 0)">
          <animateTransform attributeName="transform" type="translate"
            values="0 0; 0 -0.6; 0 0; 0 0.6; 0 0" dur="6s" repeatCount="indefinite"/>
          <g class="s">
            <path d="M20 26 L32 20 L44 26 L32 32 Z" fill="#ffffff18"/>
            <path d="M20 26 L20 38 L32 44 L32 32 Z" fill="#ffffff22"/>
            <path d="M44 26 L44 38 L32 44 L32 32 Z" fill="#ffffff12"/>
            <path d="M18 28 L46 28" stroke="url(#shine)" stroke-width="3" opacity=".6"/>
          </g>
          <g stroke-linecap="round" stroke-linejoin="round">
            <path d="M22 36 L30 42 L44 26" stroke="url(#shine)" stroke-width="6" opacity=".85"/>
            <path d="M22 36 L30 42 L44 26" stroke="var(--vp-v)" stroke-width="2"/>
          </g>
        </g>
      </svg>`).trim();

      const pickTextHost = (q)=> {
        if(q){ const c=document.querySelector(q); if(c) return c; }
        const roots=[document.querySelector('.topbar'), document.querySelector('.navbar'),
                     document.querySelector('header'), document.body].filter(Boolean);
        for(const r of roots){
          const els=[...r.querySelectorAll('*')];
          for(const el of els){
            if([...el.childNodes].some(n=>n.nodeType===3 && n.textContent.trim()==='Van Pack')) return el;
          }
        }
        return null;
      };

      const parseColor = (str)=>{
        if(!str) return {r:255,g:106,b:0};
        str=str.trim();
        if(str.startsWith('#')){
          let v=str.slice(1);
          if(v.length===3) v=[...v].map(h=>h+h).join('');
          const n=parseInt(v,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255};
        }
        const m=str.match(/rgba?\(([^)]+)\)/i);
        if(m){ const p=m[1].split(',').map(x=>parseFloat(x)); return {r:p[0],g:p[1],b:p[2]}; }
        // fallback
        return {r:255,g:106,b:0};
      };
      const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
      const mix=(r1,r2,t)=>({ r:Math.round(r1.r*(1-t)+r2.r*t), g:Math.round(r1.g*(1-t)+r2.g*t), b:Math.round(r1.b*(1-t)+r2.b*t) });
      const toHex=({r,g,b})=>`#${[r,g,b].map(v=>clamp(v,0,255).toString(16).padStart(2,'0')).join('')}`;

      const autoColors = (svg, host)=>{
        const cs = getComputedStyle(host);
        const accent = cs.getPropertyValue('--accent')
                     || cs.getPropertyValue('--color-accent')
                     || getComputedStyle(document.documentElement).getPropertyValue('--accent')
                     || cs.color || '#ff6a00';
        const base = parseColor(accent);
        const a = mix(base, {r:255,g:255,b:255}, 0.55);
        const b = mix(base, {r:0,  g:0,  b:0  }, 0.18);
        svg.style.setProperty('--vp-a', toHex(a));
        svg.style.setProperty('--vp-b', toHex(b));
        svg.style.setProperty('--vp-stroke', '#fff6eb');
        svg.style.setProperty('--vp-v', '#ffffff');
      };

      const createElement = (size=20)=>{
        const tpl=document.createElement('template'); tpl.innerHTML=SVG;
        const svg=tpl.content.firstElementChild; svg.setAttribute('width',size); svg.setAttribute('height',size);
        svg.style.verticalAlign='middle'; svg.style.borderRadius='8px'; svg.style.boxShadow='0 1px 0 rgba(0,0,0,.06)';
        return svg;
      };

      const mount = ({size=20,gap=8,containerQuery}={})=>{
        const host = pickTextHost(containerQuery);
        if(!host){ return null; }
        const svg = createElement(size);
        autoColors(svg, host);
        svg.style.marginRight = gap+'px';
        host.prepend(svg);
        const mql = matchMedia('(prefers-color-scheme: dark)');
        const ro  = new ResizeObserver(()=>autoColors(svg, host));
        mql.addEventListener('change', ()=>autoColors(svg, host));
        ro.observe(host);
        return svg;
      };

      const download = (filename='van-pack-logo-anim.svg')=>{
        const blob = new Blob([SVG], {type:'image/svg+xml'});
        const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename; a.click();
        setTimeout(()=>URL.revokeObjectURL(a.href), 0);
      };

      return { createElement, mount, download, SVG };
    })();

    document.addEventListener('DOMContentLoaded', ()=> {
      VanPackLogoLite.mount({ size: 20, gap: 8, containerQuery: '.brand' });
    });
    </script>
  </body>
</html>
